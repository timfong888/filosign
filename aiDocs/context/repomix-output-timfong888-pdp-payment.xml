This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.ai-agent/
  TASK_MANAGEMENT.md
docs/
  examples/
    hot-vault.md
    wagmi-vercel-hotvault.md
  integration/
    pdp-payments.md
  payments/
    contracts/
      payments-contract.md
    guides/
      first-rail.md
    payment-rails.md
  pdp/
    guides/
      creating-proof-set.md
      submitting-proofs.md
      verifying-proofs.md
    tools/
      pdptool-reference.md
  sdk/
    sdk-monitoring.md
    sdk-production.md
    sdk-quickstart.md
    sdk-workflow.md
  contracts-details.md
  contracts-guide.md
  contracts-reference.md
  contributing.md
  diagrams.md
  first-deal.md
  integration-guide.md
  introduction.md
  MVP.md
  navigation.md
  payments-overview.md
  pdp-overview.md
  quick-start.md
  setup-detailed.md
  setup.md
examples/
  hotvault-demo/
    client/
      public/
        file.svg
        globe.svg
        next.svg
        vercel.svg
        window.svg
      src/
        app/
          dashboard/
            _components/
              CostBanner.tsx
              DashboardHeader.tsx
              FileIcon.tsx
              FileRowComponent.tsx
              FilesTab.tsx
              FileUploadSection.tsx
              index.ts
              PaymentBalanceHeader.tsx
              PaymentSetupTab.tsx
              ProofDetailsDialog.tsx
              RemoveConfirmationDialog.tsx
              TokenBalanceCard.tsx
              TransactionHistory.tsx
              types.ts
              UploadProgress.tsx
            page.tsx
          globals.css
          layout.tsx
          page.tsx
        components/
          layout/
            client-layout.tsx
          ui/
            accordion.tsx
            alert-dialog.tsx
            alert.tsx
            aspect-ratio.tsx
            avatar.tsx
            badge.tsx
            breadcrumb.tsx
            button.tsx
            calendar.tsx
            card.tsx
            carousel.tsx
            chart.tsx
            checkbox.tsx
            collapsible.tsx
            command.tsx
            context-menu.tsx
            dialog.tsx
            drawer.tsx
            dropdown-menu.tsx
            form.tsx
            global-upload-progress.tsx
            hover-card.tsx
            input-otp.tsx
            input.tsx
            label.tsx
            menubar.tsx
            navigation-menu.tsx
            pagination.tsx
            popover.tsx
            progress.tsx
            proof-set-banner.tsx
            radio-group.tsx
            resizable.tsx
            scroll-area.tsx
            select.tsx
            separator.tsx
            sheet.tsx
            sidebar.tsx
            skeleton.tsx
            slider.tsx
            sonner.tsx
            switch.tsx
            table.tsx
            tabs.tsx
            textarea.tsx
            toggle-group.tsx
            toggle.tsx
            tooltip.tsx
            typography.tsx
            upload-progress.tsx
          ChunkedUploader.tsx
          icons.tsx
        contexts/
          AuthContext.tsx
          PaymentContext.tsx
        hooks/
          use-mobile.ts
          useBlockNumber.ts
          useUpload.ts
        lib/
          constants.ts
          contracts.ts
          utils.ts
        store/
          upload-store.ts
        theme/
          components.tsx
          config.ts
          ThemeProvider.tsx
        types/
          dashboard.ts
          window.d.ts
      .env.example
      .gitignore
      components.json
      eslint.config.mjs
      next.config.ts
      package.json
      postcss.config.mjs
      tsconfig.json
    server/
      cmd/
        api/
          main.go
      config/
        config.go
      docs/
        docs.go
      internal/
        api/
          handlers/
            auth.go
            chunked_upload.go
            download.go
            health.go
            piece.go
            root.go
            upload.go
          middleware/
            jwt.go
          routes/
            routes.go
        database/
          migration.go
          postgres.go
        models/
          piece.go
          proofset.go
          transaction.go
          user.go
          wallet.go
        services/
          ethereum.go
      pkg/
        logger/
          logger.go
      .env.example
      .gitignore
      go.mod
      Makefile
    README.md
plans/
  doc_reviews.md
  documentation-prompt
  prd-documentation.md
.gitignore
.meta
clone_filecoin_repos.sh
filoz.code-workspace
index.md
LICENSE
questions.md
README.md
repo_list.md
system-diagrams.md
update_repos.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".ai-agent/TASK_MANAGEMENT.md">
# AI Agent Task Management: PDP-Payments Documentation Project

> **‚ö†Ô∏è Note**: This file is for AI agents working on documentation generation, not for developers using the system. Developers should start with the [README.md](../README.md).

## Overview
This task management file tracks the autonomous technical documentation generation for the PDP-Payments (FWS) system. The goal is to create comprehensive documentation that serves both new developers and AI agents, with a focus on the "Golden Path" to hello world success.

## Primary Objectives
- [ ] Generate comprehensive technical documentation for PDP-Payments system
- [ ] Create clear "Golden Path" for new developer onboarding
- [ ] Ensure documentation is AI agent-consumable (Context7 MCP compatible)
- [ ] Establish iterative loop: Code Analysis ‚Üí Documentation ‚Üí Review

---

## Phase 1: Code Repository Analysis

### 1.1 Repository Setup and Access
- [x] Clone and analyze primary SDK repository: `synapse-sdk` (FilOzone/synapse-sdk)
- [x] Clone and analyze PDP repository: `pdp` (FilOzone/pdp)
- [x] Clone and analyze payments repository: `fws-payments` (FilOzone/fws-payments)
- [x] Clone and analyze demo repository: `hotvault-demo` (FilOzone/hotvault-demo)
- [x] Review existing documentation in working repo: `pdp-payment` (timfong888/pdp-payment)

### 1.2 Codebase Structure Analysis
- [x] Map out synapse-sdk architecture and key modules
- [x] Identify PDP system components and contracts
- [x] Analyze payment system architecture
- [x] Document hotvault-demo implementation patterns
- [x] Identify dependencies and build processes across repos

### 1.3 Golden Path Mapping
- [x] Trace wallet setup process for Calibration Net with USFDC
- [x] Map JSON-RPC setup for Filecoin transactions
- [x] Identify SDK integration points for local app development
- [x] Document photo storage workflow to SP via local app
- [x] Map proof retrieval mechanisms
- [x] Document image retrieval request process

---

## Phase 2: Documentation Writing

### 2.1 Core Documentation Structure
- [x] Update main README.md with improved overview and navigation
- [x] Create/update Getting Started guide with prerequisites
- [x] Document repository setup and installation process
- [x] Create configuration guide (environment variables, config files)

### 2.2 Golden Path Documentation ("Hello World")
- [x] **Step 1**: Create wallet setup guide for Calibration Net with USFDC faucet
- [x] **Step 2**: Create JSON-RPC setup guide for Filecoin transactions
- [x] **Step 3**: Create local app setup guide using synapse-sdk
- [x] **Step 4**: Create hotvault-demo reference guide with code snippets
- [ ] **Step 5**: Create photo storage tutorial (desktop to SP via local app)
- [ ] **Step 6**: Create proof availability verification guide
- [ ] **Step 7**: Create image retrieval request tutorial

### 2.3 Technical Architecture Documentation
- [ ] Document key concepts and system architecture
- [ ] Create API reference documentation
- [ ] Document contract interfaces and deployment addresses
- [ ] Create troubleshooting guide for common issues
- [ ] Create glossary for project-specific terms

### 2.4 Code Examples and Snippets
- [ ] Extract and document working code examples from hotvault-demo
- [ ] Create minimal working examples for each Golden Path step
- [ ] Ensure all code snippets are tested and functional
- [ ] Add proper language identifiers and formatting

---

## Phase 3: Documentation Review and Validation

### 3.1 New Developer Perspective Review
- [ ] Review documentation flow for logical progression
- [ ] Verify all prerequisites are clearly stated
- [ ] Test step-by-step instructions for completeness
- [ ] Check for jargon and ensure clear explanations
- [ ] Validate that Golden Path leads to successful "hello world"

### 3.2 AI Agent Consumability Review
- [ ] Verify markdown structure and semantic richness
- [ ] Ensure clear headings and consistent formatting
- [ ] Check for proper interlinking between sections
- [ ] Validate code snippets are properly demarcated
- [ ] Review for parseability by Context7 MCP

### 3.3 Technical Accuracy Review
- [ ] Verify all links are live and functional (no 404s)
- [ ] Test all code examples for functionality
- [ ] Validate contract addresses and deployment information
- [ ] Check SDK version compatibility
- [ ] Verify external documentation references

### 3.4 Organization and Navigation Review
- [ ] Ensure clear separation between SDK and contract interactions
- [ ] Verify logical information architecture
- [ ] Test navigation flow for new developers
- [ ] Check cross-references and internal links
- [ ] Validate table of contents and index accuracy

---

## Phase 4: Iteration and Improvement

### 4.1 Gap Analysis
- [ ] Identify missing information or unclear sections
- [ ] Note areas requiring web research for external knowledge
- [ ] Document feedback from testing Golden Path
- [ ] List areas needing additional code examples

### 4.2 External Research Tasks
- [ ] Research USFDC stablecoin setup best practices
- [ ] Investigate Filecoin JSON-RPC common patterns
- [ ] Review Calibration Net faucet procedures
- [ ] Research storage provider interaction patterns

### 4.3 Documentation Enhancement
- [ ] Add missing sections identified in gap analysis
- [ ] Enhance code examples based on testing feedback
- [ ] Improve troubleshooting section with common issues
- [ ] Add visual diagrams where helpful

---

## Continuous Loop Checkpoints

### Loop Iteration 1
- [ ] Complete Phase 1: Code Analysis
- [ ] Complete Phase 2: Initial Documentation
- [ ] Complete Phase 3: First Review
- [ ] Document findings and gaps

### Loop Iteration 2
- [ ] Address gaps from Iteration 1
- [ ] Enhance documentation based on review feedback
- [ ] Conduct second review cycle
- [ ] Test Golden Path end-to-end

### Loop Iteration 3
- [ ] Final refinements and polish
- [ ] Comprehensive review of all documentation
- [ ] Validate complete Golden Path workflow
- [ ] Prepare for production use

---

## Success Criteria
- [ ] New developer can complete Golden Path in under 2 hours
- [ ] All code examples execute successfully
- [ ] Documentation is AI agent-parseable
- [ ] Zero broken links or 404 errors
- [ ] Clear separation between SDK and primitive contract usage
- [ ] Comprehensive troubleshooting coverage

---

## Notes and Observations

### Progress Update - Phase 2 Documentation Writing
**Date**: Current session
**Status**: Significant progress on Golden Path documentation

**Completed:**
- ‚úÖ Updated main README.md with improved Golden Path navigation
- ‚úÖ **Step 1**: Complete wallet setup guide with USDFC minting process
- ‚úÖ **Step 2**: Comprehensive JSON-RPC setup with connection testing
- ‚úÖ **Step 3**: Synapse SDK integration with file upload examples
- ‚úÖ **Step 4**: Modern Hot Vault demo with Wagmi v2 + Next.js 14 patterns

**Key Findings:**
1. **USDFC Integration**: Successfully documented the complete flow from tFIL faucet ‚Üí USDFC minting ‚Üí MetaMask setup
2. **JSON-RPC Endpoints**: Identified multiple reliable endpoints (Glif, Ankr, ChainupCloud) for Calibration testnet
3. **Synapse SDK**: Currently uses mock implementation but provides clear API patterns for future real implementation
4. **Modern Web3 Patterns**: Integrated latest Wagmi v2 hooks and Next.js 14 App Router patterns from MCP libraries
5. **Developer Experience**: Each step builds logically on the previous, with clear prerequisites and troubleshooting

**MCP Integration Success**: Successfully leveraged Context7 MCP server to get:
- Wagmi v2 hooks and patterns for wallet connection
- Next.js 14 App Router API route patterns
- Modern TypeScript patterns for contract interactions
- Real-world code examples from production libraries

**Strategic Pivot**: Based on Synapse SDK analysis, implementing dual-path architecture:

### üéØ **New Dual-Path Documentation Architecture**

**Key Discovery**: Synapse SDK includes full PDP + Payments integration, making it ideal for developer-focused documentation.

#### üì± **Developer Path (SDK-First)**: Complete PDP + Payments Workflow
- **Goal**: 5-minute hello world with integrated payments
- **Audience**: Developers who want to build apps quickly
- **Value**: ~20 lines of code vs 200+ with raw contracts
- **Focus**: SDK abstracts complexity of coordinating PDP proofs with USDFC payments

#### ü§ñ **AI Agent Path (Contract-Direct)**: Maximum Technical Control
- **Goal**: Full technical detail and contract-level control
- **Audience**: AI agents and advanced developers
- **Value**: Complete access to all contract functionality
- **Focus**: Direct Wagmi/Viem contract interactions with full technical detail

### ‚úÖ **Implementation Tasks**

#### Phase 2B: Dual-Path Implementation
- [x] **Create SDK Golden Path** (Developer-focused)
  - [x] Step 1: Quick SDK Setup (`docs/sdk-quickstart.md`)
  - [x] Step 2: Complete Storage + Payment Workflow (`docs/sdk-workflow.md`)
  - [x] Step 3: Monitor & Verify (`docs/sdk-monitoring.md`)
  - [x] Step 4: Production Deployment (`docs/sdk-production.md`) - **Updated with Vercel + React**

- [ ] **Reorganize Contract Path** (AI Agent-focused)
  - [ ] Move existing technical docs to AI Agent path
  - [ ] Create contract integration guide (`docs/contracts-guide.md`)
  - [ ] Create PDP technical implementation (`docs/pdp-technical.md`)
  - [ ] Create payment technical implementation (`docs/payments-technical.md`)

- [x] **Update Navigation & README**
  - [x] Clear path separation in README.md
  - [x] Update all cross-references
  - [x] Add value proposition for each path
</file>

<file path="docs/examples/hot-vault.md">
# Step 4: Hot Vault Demo Reference

This is the fourth step in your Golden Path. You'll explore the Hot Vault demo - a complete reference implementation that demonstrates how to build a modern web3 storage application using the PDP-Payments system.

**üîó Live Demo Repository:** [https://github.com/FilOzone/hotvault-demo](https://github.com/FilOzone/hotvault-demo)


> **üí° Looking for a modern serverless approach?** Check out the [Wagmi-Vercel Hot Vault Guide](wagmi-vercel-hotvault.md) for a Docker-free, serverless implementation using Wagmi v2 and Vercel deployment.

## Prerequisites

- ‚úÖ Completed [Step 1: Setup Wallet & USDFC](../setup.md)
- ‚úÖ Completed [Step 2: Configure JSON-RPC](../setup-detailed.md)
- ‚úÖ Completed [Step 3: Install Synapse SDK](../quick-start.md)
- **Understanding of React/Next.js** (helpful but not required)

## What is Hot Vault?

Hot Vault is a **production-ready reference implementation** that demonstrates:

1. **Modern Web3 UX**: Seamless wallet connection with Wagmi + MetaMask
2. **File Storage**: Upload photos from your desktop to Filecoin storage providers
3. **Cryptographic Proofs**: Real-time verification that your files remain stored
4. **Automatic Payments**: USDFC payments to storage providers based on proof compliance
5. **Full-Stack Architecture**: Next.js frontend + API routes + blockchain integration

### Key Features

- üîê **Wallet Integration**: Connect with MetaMask using modern Wagmi patterns
- üìÅ **Drag & Drop Upload**: Intuitive file upload with progress tracking
- üîç **Proof Monitoring**: Real-time dashboard showing storage proof status
- üí∞ **Payment Tracking**: Transparent view of storage costs and payments
- üìä **Storage Analytics**: File size, storage duration, and cost analysis

## Architecture Overview

Hot Vault uses a modern full-stack architecture:

### Frontend (Next.js 14 + Wagmi)
- **React Components**: Modern UI with TypeScript
- **Wagmi Integration**: Type-safe wallet connections
- **Real-time Updates**: Live proof and payment status
- **File Management**: Upload, view, and manage stored files

### Backend (Next.js API Routes)
- **File Processing**: Handle uploads and generate CommP
- **Blockchain Integration**: Create proof sets and payment rails
- **Proof Submission**: Automated proof generation and submission
- **Payment Settlement**: Automatic payment processing

### Smart Contracts
- **PDP Verifier**: Manages proof sets and verification
- **PDP Service**: Defines storage SLA terms
- **Payments Contract**: Handles USDFC payment rails
- **Custom Arbiter**: Adjusts payments based on proof compliance

## How It Works: Complete Walkthrough

### 1. Wallet Connection (Modern Wagmi Pattern)

Hot Vault uses the latest Wagmi patterns for seamless wallet connection. The implementation demonstrates modern React patterns with TypeScript support.

**üìÅ Source:** [`components/WalletConnection.tsx`](https://github.com/FilOzone/hotvault-demo/blob/main/components/WalletConnection.tsx)

Key features:
- **useAccount Hook**: Manages connected wallet state
- **useConnect Hook**: Handles wallet connection with injected connector (MetaMask)
- **useDisconnect Hook**: Provides clean wallet disconnection
- **Responsive UI**: Shows connection status and wallet address truncation
- **TypeScript Support**: Full type safety with Wagmi v2

### 2. File Upload with Progress Tracking

Modern drag-and-drop file upload with real-time progress tracking and validation.

**üìÅ Source:** [`components/FileUpload.tsx`](https://github.com/FilOzone/hotvault-demo/blob/main/components/FileUpload.tsx)

Key features:
- **React Dropzone**: Modern drag-and-drop interface with file validation
- **Progress Tracking**: Real-time upload progress with visual indicators
- **File Validation**: Automatic file type and size validation (max 10MB)
- **Error Handling**: Comprehensive error handling with user feedback
- **FormData API**: Efficient file upload using modern browser APIs
- **Responsive Design**: Mobile-friendly upload interface

### 3. Next.js API Route for File Processing

Modern Next.js 14 App Router API route with proper error handling and Filecoin integration.

**üìÅ Source:** [`app/api/upload/route.ts`](https://github.com/FilOzone/hotvault-demo/blob/main/app/api/upload/route.ts)

Key features:
- **Next.js 14 App Router**: Modern API route structure with TypeScript
- **File Processing**: Handles multipart form data with proper validation
- **CAR File Generation**: Creates Content Addressable aRchive files for Filecoin
- **CommP Calculation**: Generates cryptographic proofs for file integrity
- **Error Handling**: Comprehensive error handling with proper HTTP status codes
- **Metadata Management**: Structured file metadata with unique identifiers
- **Database Integration**: Ready for database storage (currently using console logging)

### 4. Smart Contract Integration with Wagmi

Hot Vault uses Wagmi hooks for type-safe contract interactions with the PDP-Payments system.

**üìÅ Source:** [`hooks/useContracts.ts`](https://github.com/FilOzone/hotvault-demo/blob/main/hooks/useContracts.ts)

Key features:
- **useWriteContract Hook**: Type-safe contract function calls with Wagmi v2
- **useWaitForTransactionReceipt**: Real-time transaction confirmation tracking
- **Payment Rate Calculation**: Dynamic pricing based on file size (0.01 USDFC per MB per epoch)
- **Contract Configuration**: Pre-configured contract addresses and ABIs
- **Error Handling**: Comprehensive transaction error handling
- **TypeScript Support**: Full type safety for contract interactions
- **USDFC Integration**: Native stablecoin payment processing

### 5. PDP Proof Set Creation

Creating proof sets with modern error handling and user feedback for storage verification.

**üìÅ Source:** [`hooks/usePDPProofSet.ts`](https://github.com/FilOzone/hotvault-demo/blob/main/hooks/usePDPProofSet.ts)

Key features:
- **Proof Set Management**: Creates cryptographic proof sets for file storage verification
- **Payment Rail Integration**: Links proof sets to payment rails via encoded extra data
- **Sybil Fee Handling**: Automatic sybil fee calculation and payment (0.1 tFIL)
- **ABI Encoding**: Proper encoding of payment rail information for contract calls
- **Transaction Tracking**: Real-time transaction status with confirmation monitoring
- **Error Handling**: Comprehensive error handling for proof set creation failures

### 6. Real-time Storage Dashboard

Hot Vault provides a comprehensive dashboard for monitoring storage status with real-time updates.

**üìÅ Source:** [`components/StorageDashboard.tsx`](https://github.com/FilOzone/hotvault-demo/blob/main/components/StorageDashboard.tsx)

Key features:
- **Real-time Monitoring**: Live updates of proof submission and payment status
- **File Management**: Complete file listing with metadata and actions
- **Status Indicators**: Visual badges for proof and payment status
- **Storage Analytics**: Total files, storage used, and active proofs metrics
- **Contract Integration**: Direct contract reads for proof set information
- **Responsive Design**: Mobile-friendly table layout with overflow handling
- **TypeScript Interfaces**: Strongly typed file and status data structures

## Running the Hot Vault Demo

### Prerequisites

- **Node.js 18+** and **npm/yarn/pnpm**
- **MetaMask** with Filecoin Calibration testnet configured
- **tFIL and USDFC tokens** (from Steps 1-2)

### 1. Clone and Setup

```bash
# Clone the Hot Vault demo
git clone https://github.com/FilOzone/hotvault-demo.git
cd hotvault-demo

# Install dependencies
npm install

# Copy environment template
cp .env.example .env.local
```

### 2. Configure Environment

Edit `.env.local` with your settings:

```bash
# Wallet Configuration
NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID=your_project_id_here

# Filecoin Calibration Network
NEXT_PUBLIC_CHAIN_ID=314159
NEXT_PUBLIC_RPC_URL=https://api.calibration.node.glif.io/rpc/v1

# Contract Addresses (Calibration Testnet)
NEXT_PUBLIC_PDP_VERIFIER_ADDRESS=0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC
NEXT_PUBLIC_PDP_SERVICE_ADDRESS=0x6170dE2b09b404776197485F3dc6c968Ef948505
NEXT_PUBLIC_PAYMENTS_ADDRESS=0xc5e1333D3cD8a3F1f8A9f9A116f166cBD0bA307A
NEXT_PUBLIC_USDFC_TOKEN_ADDRESS=0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0

# Storage Provider Configuration
NEXT_PUBLIC_PROVIDER_ADDRESS=0x742d35Cc6634C0532925a3b8D4C9db96c4b4d8b6

# Database (for production)
DATABASE_URL=postgresql://user:password@localhost:5432/hotvault
```

### 3. Start Development Server

```bash
# Start the development server
npm run dev

# Open in browser
open http://localhost:3000
```

### 4. Test the Complete Flow

1. **Connect Wallet**: Click "Connect MetaMask" and approve the connection
2. **Upload File**: Drag and drop a photo (max 10MB)
3. **Create Payment Rail**: Approve USDFC spending and create payment rail
4. **Create Proof Set**: Pay sybil fee and create proof set
5. **Monitor Storage**: View real-time proof and payment status
6. **Download File**: Retrieve your stored file anytime

## Project Structure

```
hotvault-demo/
‚îú‚îÄ‚îÄ app/                          # Next.js 14 App Router
‚îÇ   ‚îú‚îÄ‚îÄ api/                      # API Routes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ upload/route.ts       # File upload handler
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ files/route.ts        # File listing
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ proofs/route.ts       # Proof status
‚îÇ   ‚îú‚îÄ‚îÄ dashboard/                # Storage dashboard
‚îÇ   ‚îî‚îÄ‚îÄ layout.tsx                # Root layout with Wagmi
‚îú‚îÄ‚îÄ components/                   # React Components
‚îÇ   ‚îú‚îÄ‚îÄ WalletConnection.tsx      # Wallet connection UI
‚îÇ   ‚îú‚îÄ‚îÄ FileUpload.tsx           # Drag & drop upload
‚îÇ   ‚îú‚îÄ‚îÄ StorageDashboard.tsx     # File management
‚îÇ   ‚îî‚îÄ‚îÄ ProofMonitor.tsx         # Real-time proof status
‚îú‚îÄ‚îÄ hooks/                        # Custom Wagmi hooks
‚îÇ   ‚îú‚îÄ‚îÄ useContracts.ts          # Contract interactions
‚îÇ   ‚îú‚îÄ‚îÄ usePDPProofSet.ts        # PDP operations
‚îÇ   ‚îî‚îÄ‚îÄ useFileStorage.ts        # File management
‚îú‚îÄ‚îÄ lib/                          # Utilities
‚îÇ   ‚îú‚îÄ‚îÄ contracts.ts             # Contract ABIs and addresses
‚îÇ   ‚îú‚îÄ‚îÄ filecoin-utils.ts        # CAR file and CommP generation
‚îÇ   ‚îî‚îÄ‚îÄ wagmi-config.ts          # Wagmi configuration
‚îî‚îÄ‚îÄ public/                       # Static assets
```

## Key Features Demonstrated

### 1. Modern Web3 UX Patterns
- **Seamless Wallet Connection**: One-click MetaMask integration with Wagmi
- **Transaction Status**: Real-time feedback for all blockchain operations
- **Error Handling**: User-friendly error messages and retry mechanisms
- **Loading States**: Proper loading indicators for async operations

### 2. File Storage Workflow
- **Drag & Drop Upload**: Intuitive file selection with progress tracking
- **CommP Generation**: Automatic cryptographic proof generation
- **Metadata Management**: Comprehensive file information storage
- **Storage Provider Integration**: Automated SP selection and deal creation

### 3. Payment Management
- **Automatic Rate Calculation**: Dynamic pricing based on file size
- **USDFC Integration**: Seamless stablecoin payments
- **Payment Rails**: Automated payment streaming to storage providers
- **Settlement Tracking**: Real-time payment status monitoring

### 4. Proof Verification
- **Real-time Monitoring**: Live proof submission status
- **Compliance Tracking**: Automated SLA compliance verification
- **Proof History**: Complete audit trail of all proof submissions
- **Failure Handling**: Automatic retry and notification systems

## Technology Stack

### Frontend
- **Next.js 14**: App Router with Server Components
- **Wagmi v2**: Type-safe Ethereum interactions
- **TanStack Query**: Data fetching and caching
- **Tailwind CSS**: Utility-first styling
- **TypeScript**: Full type safety

### Backend
- **Next.js API Routes**: Serverless API endpoints
- **Prisma**: Type-safe database ORM
- **PostgreSQL**: Production database
- **IPFS**: Decentralized file storage
- **Filecoin Utils**: CAR file and CommP generation

### Smart Contracts (Pre-deployed)
- **PDP Verifier**: Deployed on Calibration testnet
- **PDP Service**: Deployed on Calibration testnet
- **Payments Contract**: Deployed on Calibration testnet
- **USDFC Token**: Deployed stablecoin contract

## Troubleshooting

### Common Issues

**Wallet Connection Fails**
- Ensure MetaMask is installed and unlocked
- Check you're on Filecoin Calibration testnet
- Disable other wallet extensions

**File Upload Errors**
- Check file size (max 10MB)
- Ensure sufficient tFIL for gas fees
- Verify network connectivity

**Transaction Failures**
- Confirm sufficient USDFC balance
- Check gas price settings
- Wait for network congestion to clear

**Proof Submission Issues**
- Verify storage provider is online
- Check proof set configuration
- Monitor network epoch timing

## Next Steps

üéâ **Congratulations!** You've completed Step 4 of the Golden Path.

**Next**: [Step 5: Photo Storage Tutorial](../first-deal.md) - Upload your first photo from desktop to storage provider

## Production Deployment with Vercel

### Overview

Deploy your Hot Vault application to production using Vercel's modern deployment platform. This section covers the complete deployment process, environment configuration, and CI/CD setup.

### Prerequisites for Production

- **Vercel Account**: Sign up at [vercel.com](https://vercel.com)
- **GitHub Repository**: Your Hot Vault fork or clone
- **Environment Variables**: Production contract addresses and API keys
- **Domain (Optional)**: Custom domain for your application

### Step 1: Prepare for Deployment

1. **Fork the Repository**
   ```bash
   # Fork the Hot Vault demo repository
   git clone https://github.com/YOUR_USERNAME/hotvault-demo.git
   cd hotvault-demo
   ```

2. **Install Vercel CLI**
   ```bash
   npm install -g vercel
   vercel login
   ```

3. **Configure Environment Variables**

   Create a `.env.production` file:
   ```bash
   # Production Environment Variables
   NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID=your_production_project_id
   NEXT_PUBLIC_CHAIN_ID=314159
   NEXT_PUBLIC_RPC_URL=https://api.calibration.node.glif.io/rpc/v1

   # Production Contract Addresses
   NEXT_PUBLIC_PDP_VERIFIER_ADDRESS=0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC
   NEXT_PUBLIC_PDP_SERVICE_ADDRESS=0x6170dE2b09b404776197485F3dc6c968Ef948505
   NEXT_PUBLIC_PAYMENTS_ADDRESS=0xc5e1333D3cD8a3F1f8A9f9A116f166cBD0bA307A
   NEXT_PUBLIC_USDFC_TOKEN_ADDRESS=0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0

   # Database (Production)
   DATABASE_URL=postgresql://user:password@host:5432/hotvault_prod

   # Storage Configuration
   STORAGE_PROVIDER_ENDPOINT=https://your-storage-provider.com
   IPFS_GATEWAY=https://your-ipfs-gateway.com
   ```

### Step 2: Deploy to Vercel

1. **Connect Repository**
   ```bash
   vercel --prod
   ```

2. **Configure Project Settings**
   - **Framework Preset**: Next.js
   - **Build Command**: `npm run build`
   - **Output Directory**: `.next`
   - **Install Command**: `npm install`

3. **Set Environment Variables**
   ```bash
   # Set production environment variables
   vercel env add NEXT_PUBLIC_WALLET_CONNECT_PROJECT_ID production
   vercel env add NEXT_PUBLIC_CHAIN_ID production
   vercel env add DATABASE_URL production
   # ... add all other environment variables
   ```

### Step 3: Configure CI/CD Pipeline

Create `.github/workflows/deploy.yml`:

```yaml
name: Deploy to Vercel

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test

      - name: Build application
        run: npm run build

      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.ORG_ID }}
          vercel-project-id: ${{ secrets.PROJECT_ID }}
          vercel-args: '--prod'
```

### Step 4: Production Best Practices

1. **Security Configuration**
   - Enable HTTPS redirects
   - Configure CORS policies
   - Set up rate limiting
   - Implement proper error handling

2. **Performance Optimization**
   - Enable Vercel Edge Functions for API routes
   - Configure CDN caching for static assets
   - Implement image optimization
   - Use Vercel Analytics for monitoring

3. **Monitoring and Logging**
   - Set up Vercel Analytics
   - Configure error tracking (Sentry)
   - Implement health checks
   - Monitor contract interactions

### Step 5: Custom Domain Setup

1. **Add Custom Domain**
   ```bash
   vercel domains add yourdomain.com
   ```

2. **Configure DNS**
   - Add CNAME record pointing to `cname.vercel-dns.com`
   - Or add A record pointing to Vercel's IP addresses

3. **SSL Certificate**
   - Vercel automatically provisions SSL certificates
   - Certificates auto-renew every 90 days

### Deployment Hooks Integration

Configure deployment hooks for automated deployments:

```typescript
// vercel.json
{
  "functions": {
    "app/api/**/*.ts": {
      "runtime": "@vercel/node"
    }
  },
  "rewrites": [
    {
      "source": "/api/(.*)",
      "destination": "/api/$1"
    }
  ],
  "headers": [
    {
      "source": "/api/(.*)",
      "headers": [
        {
          "key": "Access-Control-Allow-Origin",
          "value": "*"
        },
        {
          "key": "Access-Control-Allow-Methods",
          "value": "GET, POST, PUT, DELETE, OPTIONS"
        }
      ]
    }
  ]
}
```

### Troubleshooting Production Issues

**Common Deployment Issues:**

1. **Environment Variables Not Loading**
   - Verify all environment variables are set in Vercel dashboard
   - Check variable names match exactly (case-sensitive)
   - Ensure `NEXT_PUBLIC_` prefix for client-side variables

2. **Contract Connection Failures**
   - Verify contract addresses are correct for target network
   - Check RPC endpoint is accessible and has sufficient rate limits
   - Ensure wallet connection works with production domain

3. **Build Failures**
   - Check Node.js version compatibility
   - Verify all dependencies are listed in package.json
   - Review build logs for specific error messages

## Additional Resources

- [Hot Vault Demo Repository](https://github.com/FilOzone/hotvault-demo)
- [Vercel Deployment Documentation](https://vercel.com/docs/deployments)
- [Wagmi Documentation](https://wagmi.sh/)
- [Next.js App Router Guide](https://nextjs.org/docs/app)
- [Filecoin Storage Documentation](https://docs.filecoin.io/storage-providers/)
- [USDFC Stablecoin Guide](https://docs.secured.finance/)
- [Vercel Environment Variables Guide](https://vercel.com/docs/projects/environment-variables)
</file>

<file path="docs/examples/wagmi-vercel-hotvault.md">
# Wagmi-Vercel Hot Vault: Modern Web3 Storage Application

This guide shows how to build a modern Hot Vault application using **Wagmi v2** for Web3 interactions and **Vercel** for deployment, eliminating the need for Docker containers and Go backend servers.

**üîó Reference Implementation:** [Original Hot Vault Demo](https://github.com/FilOzone/hotvault-demo)


> **üìö Comparing approaches?** See the [Traditional Hot Vault Guide](hot-vault.md) for the Docker-based reference implementation with detailed explanations of the core concepts.

## Why Wagmi + Vercel?

### Advantages Over Original Architecture

| Original Hot Vault | Wagmi-Vercel Hot Vault |
|-------------------|------------------------|
| ethers.js + Go backend | Wagmi v2 + Next.js API routes |
| Docker + PostgreSQL | Vercel + Serverless functions |
| Manual deployment | Automated CI/CD |
| Complex setup | One-click deployment |

### Key Benefits

- **üöÄ Faster Development**: Type-safe React hooks with Wagmi v2
- **‚òÅÔ∏è Serverless Architecture**: No Docker containers or server management
- **üîÑ Auto-scaling**: Vercel handles traffic spikes automatically
- **üõ°Ô∏è Built-in Security**: HTTPS, DDoS protection, and edge caching
- **üìä Analytics**: Built-in performance monitoring

## Prerequisites

- **Node.js 18+** and **npm/yarn/pnpm**
- **Vercel Account**: [Sign up free](https://vercel.com)
- **MetaMask** with Filecoin Calibration testnet
- **USDFC tokens** for payments

## Project Architecture

```
wagmi-vercel-hotvault/
‚îú‚îÄ‚îÄ app/                          # Next.js 14 App Router
‚îÇ   ‚îú‚îÄ‚îÄ api/                      # Serverless API routes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ upload/route.ts       # File upload handler
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ files/route.ts        # File management
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ contracts/route.ts    # Contract interactions
‚îÇ   ‚îú‚îÄ‚îÄ dashboard/                # Storage dashboard
‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx                # Root layout with Wagmi
‚îÇ   ‚îî‚îÄ‚îÄ page.tsx                  # Landing page
‚îú‚îÄ‚îÄ components/                   # React Components
‚îÇ   ‚îú‚îÄ‚îÄ WalletConnection.tsx      # Wagmi wallet integration
‚îÇ   ‚îú‚îÄ‚îÄ FileUpload.tsx           # Drag & drop upload
‚îÇ   ‚îú‚îÄ‚îÄ StorageDashboard.tsx     # File management UI
‚îÇ   ‚îî‚îÄ‚îÄ ContractInteraction.tsx  # PDP contract calls
‚îú‚îÄ‚îÄ hooks/                        # Custom Wagmi hooks
‚îÇ   ‚îú‚îÄ‚îÄ useCreatePaymentRail.ts  # Payment rail creation
‚îÇ   ‚îú‚îÄ‚îÄ useCreateProofSet.ts     # PDP proof set management
‚îÇ   ‚îî‚îÄ‚îÄ useFileStorage.ts        # File storage operations
‚îú‚îÄ‚îÄ lib/                          # Utilities
‚îÇ   ‚îú‚îÄ‚îÄ wagmi-config.ts          # Wagmi configuration
‚îÇ   ‚îú‚îÄ‚îÄ contracts.ts             # Contract ABIs and addresses
‚îÇ   ‚îî‚îÄ‚îÄ storage.ts               # File storage utilities
‚îî‚îÄ‚îÄ vercel.json                  # Vercel configuration
```

## Step 1: Initialize Project

```bash
# Create new Next.js project
npx create-next-app@latest wagmi-vercel-hotvault --typescript --tailwind --app
cd wagmi-vercel-hotvault

# Install Wagmi and dependencies
npm install wagmi viem @tanstack/react-query
npm install @vercel/blob @vercel/kv  # Vercel storage
npm install react-dropzone uuid      # File handling
```

## Step 2: Configure Wagmi

Create `lib/wagmi-config.ts`:

```typescript
import { http, createConfig } from 'wagmi'
import { filecoinCalibration } from 'wagmi/chains'
import { injected, metaMask } from 'wagmi/connectors'

export const config = createConfig({
  chains: [filecoinCalibration],
  connectors: [
    injected(),
    metaMask(),
  ],
  transports: {
    [filecoinCalibration.id]: http(
      process.env.NEXT_PUBLIC_RPC_URL || 
      'https://api.calibration.node.glif.io/rpc/v1'
    ),
  },
})

declare module 'wagmi' {
  interface Register {
    config: typeof config
  }
}
```

## Step 3: Contract Configuration

Create `lib/contracts.ts`:

```typescript
export const CONTRACTS = {
  // Filecoin Calibration Network addresses
  PDP_VERIFIER_ADDRESS: '0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC' as const,
  PDP_SERVICE_ADDRESS: '0x6170dE2b09b404776197485F3dc6c968Ef948505' as const,
  PAYMENTS_ADDRESS: '0xc5e1333D3cD8a3F1f8A9f9A116f166cBD0bA307A' as const,
  USDFC_TOKEN_ADDRESS: '0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0' as const,
  
  // ABIs (simplified for example)
  PAYMENTS_ABI: [
    {
      name: 'createRail',
      type: 'function',
      inputs: [
        { name: 'token', type: 'address' },
        { name: 'from', type: 'address' },
        { name: 'to', type: 'address' },
        { name: 'arbiter', type: 'address' },
        { name: 'rate', type: 'uint256' },
        { name: 'lockupPeriod', type: 'uint256' },
        { name: 'lockupFixed', type: 'uint256' },
        { name: 'commissionRate', type: 'uint256' },
      ],
      outputs: [{ name: 'railId', type: 'uint256' }],
    },
  ] as const,
  
  PDP_VERIFIER_ABI: [
    {
      name: 'createProofSet',
      type: 'function',
      inputs: [
        { name: 'service', type: 'address' },
        { name: 'extraData', type: 'bytes' },
      ],
      outputs: [{ name: 'proofSetId', type: 'uint256' }],
    },
  ] as const,
} as const
```

## Step 4: Wagmi Hooks for Contract Interactions

Create `hooks/useCreatePaymentRail.ts`:

```typescript
import { useWriteContract, useWaitForTransactionReceipt } from 'wagmi'
import { parseUnits } from 'viem'
import { CONTRACTS } from '@/lib/contracts'

export function useCreatePaymentRail() {
  const { writeContract, data: hash, isPending } = useWriteContract()
  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({
    hash,
  })

  const createRail = async (params: {
    clientAddress: `0x${string}`
    providerAddress: `0x${string}`
    fileSize: number
  }) => {
    // Calculate payment rate: 0.01 USDFC per MB per epoch
    const sizeInMB = params.fileSize / (1024 * 1024)
    const paymentRate = Math.max(0.01, sizeInMB * 0.01)

    writeContract({
      address: CONTRACTS.PAYMENTS_ADDRESS,
      abi: CONTRACTS.PAYMENTS_ABI,
      functionName: 'createRail',
      args: [
        CONTRACTS.USDFC_TOKEN_ADDRESS,
        params.clientAddress,
        params.providerAddress,
        CONTRACTS.PDP_SERVICE_ADDRESS, // arbiter
        parseUnits(paymentRate.toString(), 6), // USDFC has 6 decimals
        60n, // lockupPeriod (epochs)
        parseUnits('1', 6), // lockupFixed (1 USDFC)
        0n, // commissionRate
      ],
    })
  }

  return {
    createRail,
    isPending: isPending || isConfirming,
    isSuccess,
    hash,
  }
}
```

## Step 5: Serverless File Upload API

Create `app/api/upload/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { put } from '@vercel/blob'
import { v4 as uuidv4 } from 'uuid'

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData()
    const file = formData.get('file') as File

    if (!file) {
      return NextResponse.json(
        { error: 'No file provided' },
        { status: 400 }
      )
    }

    // Upload to Vercel Blob Storage
    const fileId = uuidv4()
    const filename = `${fileId}-${file.name}`

    const blob = await put(filename, file, {
      access: 'public',
      addRandomSuffix: false,
    })

    // Generate CommP (simplified - in production, use proper CAR file generation)
    const buffer = await file.arrayBuffer()
    const commP = `baga6ea4seaq${Buffer.from(buffer).toString('hex').slice(0, 32)}`

    // Store metadata in Vercel KV
    const metadata = {
      fileId,
      originalName: file.name,
      size: file.size,
      mimeType: file.type,
      commP,
      blobUrl: blob.url,
      uploadDate: new Date().toISOString(),
    }

    // In production, store in Vercel KV or database
    console.log('File metadata:', metadata)

    return NextResponse.json({
      success: true,
      fileId,
      commP,
      size: file.size,
      name: file.name,
      url: blob.url,
    })

  } catch (error) {
    console.error('Upload error:', error)
    return NextResponse.json(
      { error: 'Upload failed' },
      { status: 500 }
    )
  }
}
```

## Step 6: Modern Wallet Connection Component

Create `components/WalletConnection.tsx`:

```typescript
'use client'
import { useAccount, useConnect, useDisconnect } from 'wagmi'
import { injected } from 'wagmi/connectors'

export function WalletConnection() {
  const { address, isConnected } = useAccount()
  const { connect, isPending } = useConnect()
  const { disconnect } = useDisconnect()

  if (isConnected) {
    return (
      <div className="flex items-center gap-4 p-4 bg-green-50 rounded-lg">
        <div className="flex-1">
          <p className="text-sm text-green-700">Connected to</p>
          <p className="font-mono text-sm">
            {address?.slice(0, 6)}...{address?.slice(-4)}
          </p>
        </div>
        <button
          onClick={() => disconnect()}
          className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
        >
          Disconnect
        </button>
      </div>
    )
  }

  return (
    <div className="p-4 bg-blue-50 rounded-lg">
      <button
        onClick={() => connect({ connector: injected() })}
        disabled={isPending}
        className="w-full px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:opacity-50"
      >
        {isPending ? 'Connecting...' : 'Connect MetaMask'}
      </button>
    </div>
  )
}
```

## Step 7: File Upload with Drag & Drop

Create `components/FileUpload.tsx`:

```typescript
'use client'
import { useState, useCallback } from 'react'
import { useDropzone } from 'react-dropzone'
import { useCreatePaymentRail } from '@/hooks/useCreatePaymentRail'
import { useAccount } from 'wagmi'

interface UploadedFile {
  fileId: string
  name: string
  size: number
  commP: string
  url: string
}

export function FileUpload() {
  const { address } = useAccount()
  const [uploading, setUploading] = useState(false)
  const [uploadedFiles, setUploadedFiles] = useState<UploadedFile[]>([])
  const { createRail, isPending: isCreatingRail } = useCreatePaymentRail()

  const onDrop = useCallback(async (acceptedFiles: File[]) => {
    if (!address) {
      alert('Please connect your wallet first')
      return
    }

    const file = acceptedFiles[0]
    if (!file) return

    setUploading(true)

    try {
      // Upload file to Vercel Blob
      const formData = new FormData()
      formData.append('file', file)

      const response = await fetch('/api/upload', {
        method: 'POST',
        body: formData,
      })

      if (!response.ok) throw new Error('Upload failed')

      const result = await response.json()

      // Add to uploaded files list
      setUploadedFiles(prev => [...prev, result])

      // Create payment rail for the file
      await createRail({
        clientAddress: address,
        providerAddress: '0x742d35Cc6634C0532925a3b8D4C9db96c4b4d8b6', // Example provider
        fileSize: file.size,
      })

    } catch (error) {
      console.error('Upload error:', error)
      alert('Upload failed. Please try again.')
    } finally {
      setUploading(false)
    }
  }, [address, createRail])

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'image/*': ['.png', '.jpg', '.jpeg', '.gif'],
      'application/pdf': ['.pdf'],
      'text/*': ['.txt', '.md'],
    },
    maxSize: 10 * 1024 * 1024, // 10MB
    multiple: false,
  })

  return (
    <div className="space-y-6">
      <div
        {...getRootProps()}
        className={`border-2 border-dashed rounded-lg p-8 text-center cursor-pointer transition-colors ${
          isDragActive
            ? 'border-blue-500 bg-blue-50'
            : 'border-gray-300 hover:border-gray-400'
        }`}
      >
        <input {...getInputProps()} />
        {uploading || isCreatingRail ? (
          <div>
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto mb-4" />
            <p>
              {uploading ? 'Uploading file...' : 'Creating payment rail...'}
            </p>
          </div>
        ) : (
          <div>
            <p className="text-lg mb-2">
              {isDragActive ? 'Drop files here' : 'Drag & drop files here'}
            </p>
            <p className="text-sm text-gray-500">
              or click to select files (max 10MB)
            </p>
            <p className="text-xs text-gray-400 mt-2">
              Supports: Images, PDFs, Text files
            </p>
          </div>
        )}
      </div>

      {uploadedFiles.length > 0 && (
        <div className="bg-white rounded-lg shadow p-6">
          <h3 className="text-lg font-semibold mb-4">Uploaded Files</h3>
          <div className="space-y-3">
            {uploadedFiles.map((file) => (
              <div key={file.fileId} className="flex items-center justify-between p-3 bg-gray-50 rounded">
                <div>
                  <p className="font-medium">{file.name}</p>
                  <p className="text-sm text-gray-500">
                    {(file.size / 1024 / 1024).toFixed(2)} MB ‚Ä¢ CommP: {file.commP.slice(0, 20)}...
                  </p>
                </div>
                <a
                  href={file.url}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600"
                >
                  View
                </a>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  )
}
```

## Step 8: Main Application Layout

Create `app/layout.tsx`:

```typescript
'use client'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { WagmiProvider } from 'wagmi'
import { config } from '@/lib/wagmi-config'
import './globals.css'

const queryClient = new QueryClient()

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body>
        <WagmiProvider config={config}>
          <QueryClientProvider client={queryClient}>
            <div className="min-h-screen bg-gray-50">
              <header className="bg-white shadow-sm border-b">
                <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
                  <h1 className="text-2xl font-bold text-gray-900">
                    Wagmi-Vercel Hot Vault
                  </h1>
                  <p className="text-gray-600">
                    Modern Web3 storage with Filecoin PDP
                  </p>
                </div>
              </header>
              <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                {children}
              </main>
            </div>
          </QueryClientProvider>
        </WagmiProvider>
      </body>
    </html>
  )
}
```

Create `app/page.tsx`:

```typescript
import { WalletConnection } from '@/components/WalletConnection'
import { FileUpload } from '@/components/FileUpload'

export default function HomePage() {
  return (
    <div className="space-y-8">
      <div className="text-center">
        <h2 className="text-3xl font-bold text-gray-900 mb-4">
          Decentralized File Storage
        </h2>
        <p className="text-lg text-gray-600 max-w-2xl mx-auto">
          Upload files to Filecoin storage providers with automatic payment rails
          and cryptographic proof verification using PDP (Proof of Data Possession).
        </p>
      </div>

      <WalletConnection />
      <FileUpload />

      <div className="bg-blue-50 rounded-lg p-6">
        <h3 className="text-lg font-semibold text-blue-900 mb-2">
          How it works:
        </h3>
        <ol className="list-decimal list-inside space-y-2 text-blue-800">
          <li>Connect your MetaMask wallet to Filecoin Calibration network</li>
          <li>Upload files using drag & drop interface</li>
          <li>Automatic payment rail creation with USDFC tokens</li>
          <li>Files stored on Filecoin with cryptographic proofs</li>
          <li>Real-time monitoring of storage and payment status</li>
        </ol>
      </div>
    </div>
  )
}
```

## Step 9: Vercel Configuration

Create `vercel.json`:

```json
{
  "functions": {
    "app/api/**/*.ts": {
      "runtime": "@vercel/node"
    }
  },
  "env": {
    "NEXT_PUBLIC_RPC_URL": "https://api.calibration.node.glif.io/rpc/v1",
    "NEXT_PUBLIC_CHAIN_ID": "314159"
  },
  "headers": [
    {
      "source": "/api/(.*)",
      "headers": [
        {
          "key": "Access-Control-Allow-Origin",
          "value": "*"
        },
        {
          "key": "Access-Control-Allow-Methods",
          "value": "GET, POST, PUT, DELETE, OPTIONS"
        },
        {
          "key": "Access-Control-Allow-Headers",
          "value": "Content-Type, Authorization"
        }
      ]
    }
  ]
}
```

Create `package.json` scripts:

```json
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "deploy": "vercel --prod"
  }
}
```

## Step 10: Environment Variables

Create `.env.local` for development:

```bash
# Filecoin Calibration Network
NEXT_PUBLIC_CHAIN_ID=314159
NEXT_PUBLIC_RPC_URL=https://api.calibration.node.glif.io/rpc/v1

# Contract Addresses (Calibration Testnet)
NEXT_PUBLIC_PDP_VERIFIER_ADDRESS=0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC
NEXT_PUBLIC_PDP_SERVICE_ADDRESS=0x6170dE2b09b404776197485F3dc6c968Ef948505
NEXT_PUBLIC_PAYMENTS_ADDRESS=0xc5e1333D3cD8a3F1f8A9f9A116f166cBD0bA307A
NEXT_PUBLIC_USDFC_TOKEN_ADDRESS=0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0

# Vercel Storage (get from Vercel dashboard)
BLOB_READ_WRITE_TOKEN=your_blob_token_here
KV_REST_API_URL=your_kv_url_here
KV_REST_API_TOKEN=your_kv_token_here
```

## Step 11: Deploy to Vercel

### Option 1: Deploy via CLI

```bash
# Install Vercel CLI
npm install -g vercel

# Login to Vercel
vercel login

# Deploy
vercel --prod
```

### Option 2: Deploy via GitHub Integration

1. **Push to GitHub**:
   ```bash
   git init
   git add .
   git commit -m "Initial Wagmi-Vercel Hot Vault"
   git remote add origin https://github.com/YOUR_USERNAME/wagmi-vercel-hotvault.git
   git push -u origin main
   ```

2. **Connect to Vercel**:
   - Go to [vercel.com](https://vercel.com)
   - Click "New Project"
   - Import your GitHub repository
   - Configure environment variables in Vercel dashboard

3. **Set Environment Variables in Vercel**:
   - Go to Project Settings ‚Üí Environment Variables
   - Add all variables from `.env.local`
   - Deploy automatically triggers

## Key Differences from Original Hot Vault

| Feature | Original Hot Vault | Wagmi-Vercel Hot Vault |
|---------|-------------------|------------------------|
| **Web3 Library** | ethers.js | Wagmi v2 with React hooks |
| **Backend** | Go server + PostgreSQL | Next.js API routes |
| **Deployment** | Docker containers | Vercel serverless |
| **File Storage** | Local filesystem | Vercel Blob Storage |
| **Database** | PostgreSQL | Vercel KV (optional) |
| **Setup Complexity** | High (Docker, Go, DB) | Low (npm install) |
| **Scaling** | Manual | Automatic |
| **Cost** | Server hosting | Pay-per-use |

## Benefits of This Approach

### üöÄ **Developer Experience**
- **Type Safety**: Full TypeScript support with Wagmi hooks
- **Hot Reload**: Instant development feedback
- **Zero Config**: No Docker or database setup required

### ‚òÅÔ∏è **Production Ready**
- **Auto-scaling**: Handles traffic spikes automatically
- **Global CDN**: Fast file delivery worldwide
- **HTTPS**: Built-in SSL certificates

### üí∞ **Cost Effective**
- **Serverless**: Pay only for actual usage
- **No Infrastructure**: No server maintenance costs
- **Free Tier**: Generous free limits for development

### üîí **Security**
- **Edge Runtime**: Secure serverless execution
- **Environment Variables**: Secure secret management
- **DDoS Protection**: Built-in attack mitigation

## Next Steps

1. **Add PDP Proof Set Creation**: Implement the `useCreateProofSet` hook
2. **Real-time Monitoring**: Add WebSocket connections for live updates
3. **File Management**: Build a dashboard for managing uploaded files
4. **Payment Tracking**: Monitor USDFC payment rail status
5. **Error Handling**: Implement comprehensive error boundaries

## Conclusion

The Wagmi-Vercel Hot Vault demonstrates how modern Web3 applications can be built with:

- **Simplified Architecture**: No Docker or complex backend setup
- **Modern Tooling**: Wagmi v2 for type-safe Web3 interactions
- **Serverless Deployment**: Vercel for automatic scaling and global distribution
- **Developer Productivity**: Hot reload, TypeScript, and modern React patterns

This approach eliminates the complexity of the original Docker-based setup while providing a more scalable and maintainable solution for Web3 storage applications.

**üîó Ready to deploy?** Follow the steps above to get your Wagmi-Vercel Hot Vault running in production!
</file>

<file path="docs/integration/pdp-payments.md">
# Integrating PDP with Payments

This guide explains how to integrate the [Provable Data Possession (PDP)](../pdp-overview.md) system with the [Payments](../payments/concepts/overview.md) system to create a complete solution for verifiable storage with automatic payment adjustments based on service level compliance.

## Overview

The integration between PDP and Payments enables:

1. **Verifiable Storage**: Clients can verify that storage providers are actually storing their data
2. **Automatic Payment Adjustments**: Payments are automatically adjusted based on proof compliance
3. **SLA Enforcement**: Service Level Agreements are enforced through the arbitration mechanism
4. **Continuous Payment Flow**: Payments flow continuously as long as the service is provided correctly

## Integration Architecture

The integration works through these key components:

1. **Payment Rails**: Created in the Payments contract to facilitate ongoing payments
2. **Proof Sets**: Created in the PDP system to verify data possession
3. **Arbiter Contract**: Connects the two systems by adjusting payments based on proof compliance
4. **Extra Data**: Links the proof set to the payment rail

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Client    ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  Payments   ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ   Arbiter   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚ñ≤                                         ‚ñ≤
       ‚îÇ                                         ‚îÇ
       ‚ñº                                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Storage     ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ     PDP     ‚îÇ
‚îÇ Provider    ‚îÇ                          ‚îÇ   System    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Step-by-Step Integration Guide

### 1. Create a Payment Rail

First, create a payment rail in the Payments contract:

```javascript
// Using ethers.js to create a payment rail
const paymentRate = ethers.utils.parseUnits('0.01', 6); // 0.01 USDC per epoch
const lockupPeriod = 2880; // 1 day in epochs (assuming 30-second epochs)
const lockupFixed = ethers.utils.parseUnits('5', 6); // 5 USDC fixed lockup
const commissionRate = 250; // 2.5% commission

const tx = await payments.createRail(
    tokenAddress,
    clientAddress,
    providerAddress,
    arbiterAddress, // Address of your PDP arbiter contract
    paymentRate,
    lockupPeriod,
    lockupFixed,
    commissionRate
);

// Wait for the transaction to be mined
const receipt = await tx.wait();

// Get the rail ID from the event logs
const railId = receipt.events[0].args.railId;
console.log(`Created rail with ID: ${railId}`);
```

For more details on creating a payment rail, see [Setting Up a Payment Rail](../payments/guides/first-rail.md).

### 2. Create a Proof Set with Payment Information

Next, create a proof set in the PDP system, including the payment rail information in the extra data:

```javascript
// Encode the payment information in the extra data
const extraData = ethers.utils.defaultAbiCoder.encode(
    ['uint256', 'address'],
    [railId, paymentsContractAddress]
);

// Calculate the sybil fee
const sybilFee = await pdpVerifier.sybilFee();

// Create a proof set
const tx = await pdpVerifier.createProofSet(
    pdpServiceAddress, // Address of the SimplePDPService contract
    extraData,
    { value: sybilFee }
);

// Wait for the transaction to be mined
const receipt = await tx.wait();

// Get the proof set ID from the event logs
const proofSetId = receipt.events[0].args.setId;
console.log(`Created proof set with ID: ${proofSetId}`);
```

For more details on creating a proof set, see [Creating a Proof Set](../pdp/guides/creating-proof-set.md).

### 3. Implement a PDP Arbiter

Create an arbiter contract that adjusts payments based on PDP compliance:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IArbiter.sol";
import "./IPDPService.sol";

contract PDPArbiter is IArbiter {
    IPDPService public pdpService;
    mapping(uint256 => uint256) public railToProofSet;
    
    constructor(address _pdpService) {
        pdpService = IPDPService(_pdpService);
    }
    
    // Register a rail-to-proof-set mapping
    function registerRailProofSet(uint256 railId, uint256 proofSetId) external {
        // Add appropriate access control here
        railToProofSet[railId] = proofSetId;
    }
    
    function arbitratePayment(
        address token,
        address from,
        address to,
        uint256 railId,
        uint256 fromEpoch,
        uint256 toEpoch,
        uint256 amount
    ) external view override returns (ArbitrationResult memory) {
        // Get the proof set ID for this rail
        uint256 proofSetId = railToProofSet[railId];
        
        // If no proof set is registered, return the original amount
        if (proofSetId == 0) {
            return ArbitrationResult({
                modifiedAmount: amount,
                settleUpto: toEpoch,
                note: "No proof set registered"
            });
        }
        
        // Get fault count from PDP service
        uint256 faultCount = pdpService.getFaultCount(proofSetId, fromEpoch, toEpoch);
        
        // Calculate reduction (10% per fault, up to 100%)
        uint256 reductionPercent = faultCount * 10;
        if (reductionPercent > 100) reductionPercent = 100;
        
        uint256 reduction = amount * reductionPercent / 100;
        uint256 modifiedAmount = amount - reduction;
        
        return ArbitrationResult({
            modifiedAmount: modifiedAmount,
            settleUpto: toEpoch,
            note: string(abi.encodePacked("Reduced by ", faultCount, " faults"))
        });
    }
}
```

For more details on implementing a custom arbiter, see [Implementing a Custom Arbiter](../payments/guides/custom-arbiter.md).

### 4. Storage Provider: Add Data to the Proof Set

The storage provider adds data to the proof set:

```javascript
// Prepare the root data
const rootData = [
    {
        root: {
            version: 1,
            codec: 0x71, // dag-cbor
            hash: 0x12, // sha2-256
            size: 32,
            data: rootCidBytes
        },
        rawSize: dataSize
    }
];

// Add roots to the proof set
const tx = await pdpVerifier.addRoots(
    proofSetId,
    rootData,
    "0x" // No extra data needed
);

// Wait for the transaction to be mined
await tx.wait();
```

For more details on adding data to a proof set, see [Adding Data to a Proof Set](../pdp/guides/adding-data.md).

### 5. Storage Provider: Submit Proofs

The storage provider submits proofs regularly:

```javascript
// Get the next challenge epoch
const nextChallengeEpoch = await pdpVerifier.getNextChallengeEpoch(proofSetId);

// Wait until the challenge epoch
// ... (implementation depends on your environment)

// Generate proofs for the challenges
const proofs = await generateProofs(proofSetId);

// Submit proofs
const proofFee = await pdpVerifier.calculateProofFee(proofSetId, estimatedGasFee);
const tx = await pdpVerifier.provePossession(
    proofSetId,
    proofs,
    { value: proofFee }
);

// Wait for the transaction to be mined
await tx.wait();
```

For more details on submitting proofs, see [Submitting Proofs](../pdp/guides/submitting-proofs.md).

### 6. Settle Payments

Payments can be settled by anyone, typically the payee:

```javascript
// Settle payments up to the current epoch
const currentEpoch = await ethers.provider.getBlockNumber();
await payments.settleRail(railId, currentEpoch);
```

For more details on settling payments, see [Settlement Process](../payments/concepts/settlement.md).

## Example: Hot Vault Integration

The [Hot Vault Demo](../examples/hot-vault.md) provides a complete example of integrating PDP with Payments:

1. Client uploads data to the Hot Vault service
2. Hot Vault creates a payment rail from the client to the storage provider
3. Hot Vault creates a proof set in the PDP system, linking it to the payment rail
4. Storage provider stores the data and submits proofs regularly
5. Payments flow continuously, adjusted based on proof compliance
6. Client can verify that their data is being stored correctly

For more details on the Hot Vault demo, see [Hot Vault Demo](../examples/hot-vault.md).

## Best Practices

1. **Secure Extra Data**: Ensure that the extra data containing payment information is properly secured and verified
2. **Regular Settlement**: Settle payments regularly to ensure timely compensation for storage providers
3. **Fault Monitoring**: Monitor fault records to identify and address issues promptly
4. **Arbiter Security**: Implement proper access controls in your arbiter contract
5. **Testing**: Thoroughly test the integration on a testnet before deploying to mainnet

## Troubleshooting

### Payment Not Adjusted Despite Faults

If payments are not being adjusted despite faults:

1. Verify that the arbiter contract is correctly registered in the payment rail
2. Check that the arbiter contract is correctly retrieving fault information from the PDP service
3. Ensure that the rail ID to proof set ID mapping is correct

### Proof Set Not Linked to Payment Rail

If the proof set is not properly linked to the payment rail:

1. Verify that the extra data was correctly encoded when creating the proof set
2. Check that the arbiter contract correctly decodes and uses this information
3. Ensure that the proof set ID is correctly registered in the arbiter contract

## Next Steps

- Explore the [Hot Vault Demo](../examples/hot-vault.md) for a complete implementation
- Learn about [Building on FilOz](building-on-filoz.md) for more integration options
- Understand [FilOz in the Filecoin Ecosystem](filecoin-ecosystem.md)
</file>

<file path="docs/payments/contracts/payments-contract.md">
# Payments Contract API Reference

This document provides a comprehensive reference for the FilOz Payments contract API.

## Core Structures

### Rail

```solidity
struct Rail {
    address token;        // ERC20 token used for payments
    address from;         // Payer address
    address to;           // Payee address
    address operator;     // Entity that can modify the rail
    address arbiter;      // Optional arbiter for SLA enforcement
    
    uint256 paymentRate;  // Rate at which payments flow (per epoch)
    uint256 lockupPeriod; // Number of epochs for which funds are locked
    uint256 lockupFixed;  // Fixed amount of funds locked
    
    uint256 settledUpTo;  // Epoch up to which payments have been settled
    uint256 endEpoch;     // Epoch at which the rail terminates
    uint256 commissionRateBps; // Commission rate in basis points
    
    RateChange[] rateChangeQueue; // Queue of scheduled rate changes
}
```

### Account

```solidity
struct Account {
    uint256 funds;              // Available funds
    uint256 lockupCurrent;      // Currently locked funds
    uint256 lockupRate;         // Rate at which funds are locked
    uint256 lockupLastSettledAt; // Last epoch when lockup was settled
}
```

### RateChange

```solidity
struct RateChange {
    uint256 epoch;       // Epoch at which the rate change takes effect
    uint256 paymentRate; // New payment rate
}
```

### ArbitrationResult

```solidity
struct ArbitrationResult {
    uint256 modifiedAmount; // Adjusted payment amount
    uint256 settleUpto;     // Epoch up to which to settle
    string note;            // Additional information
}
```

## State Variables

| Name | Type | Description |
|------|------|-------------|
| `accounts` | `mapping(address => mapping(address => Account))` | Maps token and user to their account |
| `rails` | `mapping(uint256 => Rail)` | Maps rail ID to rail data |
| `nextRailId` | `uint256` | Counter for generating unique rail IDs |

## Events

### RailCreated

```solidity
event RailCreated(
    uint256 indexed railId,
    address indexed from,
    address indexed to,
    address token,
    uint256 paymentRate,
    uint256 lockupPeriod,
    uint256 lockupFixed,
    uint256 commissionRateBps
);
```

Emitted when a new payment rail is created.

### RailLockupModified

```solidity
event RailLockupModified(
    uint256 indexed railId,
    uint256 lockupPeriod,
    uint256 lockupFixed
);
```

Emitted when a rail's lockup parameters are modified.

### RailPaymentModified

```solidity
event RailPaymentModified(
    uint256 indexed railId,
    uint256 paymentRate,
    uint256 oneTimePayment
);
```

Emitted when a rail's payment parameters are modified.

### RailTerminated

```solidity
event RailTerminated(
    uint256 indexed railId,
    uint256 endEpoch
);
```

Emitted when a rail is terminated.

### RailSettled

```solidity
event RailSettled(
    uint256 indexed railId,
    uint256 fromEpoch,
    uint256 toEpoch,
    uint256 amount,
    uint256 commission
);
```

Emitted when a rail is settled.

### Deposited

```solidity
event Deposited(
    address indexed token,
    address indexed user,
    uint256 amount
);
```

Emitted when a user deposits funds.

### Withdrawn

```solidity
event Withdrawn(
    address indexed token,
    address indexed user,
    uint256 amount
);
```

Emitted when a user withdraws funds.

### RateChangeScheduled

```solidity
event RateChangeScheduled(
    uint256 indexed railId,
    uint256 epoch,
    uint256 paymentRate
);
```

Emitted when a rate change is scheduled.

## Functions

### deposit

```solidity
function deposit(
    address token,
    address user,
    uint256 amount
) external
```

Deposits tokens into a user's account.

**Parameters:**
- `token`: Address of the ERC20 token to deposit
- `user`: Address of the user to deposit for
- `amount`: Amount of tokens to deposit

**Requirements:**
- The caller must have approved the contract to spend their tokens

### withdraw

```solidity
function withdraw(
    address token,
    uint256 amount
) external
```

Withdraws tokens from the caller's account.

**Parameters:**
- `token`: Address of the ERC20 token to withdraw
- `amount`: Amount of tokens to withdraw

**Requirements:**
- The caller must have sufficient available (non-locked) funds

### createRail

```solidity
function createRail(
    address token,
    address from,
    address to,
    address arbiter,
    uint256 paymentRate,
    uint256 lockupPeriod,
    uint256 lockupFixed,
    uint256 commissionRateBps
) external returns (uint256 railId)
```

Creates a new payment rail.

**Parameters:**
- `token`: Address of the ERC20 token to use for payments
- `from`: Address of the payer
- `to`: Address of the payee
- `arbiter`: Address of the arbiter (can be zero address for no arbitration)
- `paymentRate`: Rate at which payments flow (per epoch)
- `lockupPeriod`: Number of epochs for which funds are locked
- `lockupFixed`: Fixed amount of funds locked
- `commissionRateBps`: Commission rate in basis points (1/100 of a percent)

**Returns:**
- `railId`: ID of the created rail

**Requirements:**
- The caller becomes the operator of the rail

### modifyRailLockup

```solidity
function modifyRailLockup(
    uint256 railId,
    uint256 lockupPeriod,
    uint256 lockupFixed
) external
```

Modifies a rail's lockup parameters.

**Parameters:**
- `railId`: ID of the rail to modify
- `lockupPeriod`: New lockup period
- `lockupFixed`: New fixed lockup amount

**Requirements:**
- The caller must be the rail's operator
- The rail must not be terminated

### modifyRailPayment

```solidity
function modifyRailPayment(
    uint256 railId,
    uint256 paymentRate,
    uint256 oneTimePayment
) external
```

Modifies a rail's payment parameters.

**Parameters:**
- `railId`: ID of the rail to modify
- `paymentRate`: New payment rate
- `oneTimePayment`: One-time payment amount (can be zero)

**Requirements:**
- The caller must be the rail's operator
- The rail must not be terminated

### terminateRail

```solidity
function terminateRail(
    uint256 railId
) external
```

Terminates a rail, preventing further payments after the lockup period.

**Parameters:**
- `railId`: ID of the rail to terminate

**Requirements:**
- The caller must be the rail's operator or the payer
- The rail must not already be terminated

### settleRail

```solidity
function settleRail(
    uint256 railId,
    uint256 toEpoch
) external
```

Settles payments for a rail up to the specified epoch.

**Parameters:**
- `railId`: ID of the rail to settle
- `toEpoch`: Epoch up to which to settle payments

**Requirements:**
- The rail must not be terminated, or if terminated, the lockup period must not have passed
- `toEpoch` must be greater than the last settled epoch

### settleTerminatedRailWithoutArbitration

```solidity
function settleTerminatedRailWithoutArbitration(
    uint256 railId
) external
```

Settles payments for a terminated rail without arbitration.

**Parameters:**
- `railId`: ID of the rail to settle

**Requirements:**
- The rail must be terminated
- The lockup period must have passed
- The caller must be the payer

### scheduleRateChange

```solidity
function scheduleRateChange(
    uint256 railId,
    uint256 epoch,
    uint256 paymentRate
) external
```

Schedules a rate change for a future epoch.

**Parameters:**
- `railId`: ID of the rail to modify
- `epoch`: Epoch at which the rate change takes effect
- `paymentRate`: New payment rate

**Requirements:**
- The caller must be the rail's operator
- The rail must not be terminated
- The epoch must be in the future

### getRail

```solidity
function getRail(
    uint256 railId
) external view returns (Rail memory)
```

Gets the details of a rail.

**Parameters:**
- `railId`: ID of the rail to get

**Returns:**
- The rail data

### getAccount

```solidity
function getAccount(
    address token,
    address user
) external view returns (Account memory)
```

Gets the account details for a user and token.

**Parameters:**
- `token`: Address of the ERC20 token
- `user`: Address of the user

**Returns:**
- The account data

### calculateSettlementAmount

```solidity
function calculateSettlementAmount(
    uint256 railId,
    uint256 fromEpoch,
    uint256 toEpoch
) external view returns (uint256)
```

Calculates the settlement amount for a rail between two epochs.

**Parameters:**
- `railId`: ID of the rail
- `fromEpoch`: Starting epoch
- `toEpoch`: Ending epoch

**Returns:**
- The settlement amount

## Interfaces

### IArbiter

```solidity
interface IArbiter {
    struct ArbitrationResult {
        uint256 modifiedAmount;
        uint256 settleUpto;
        string note;
    }
    
    function arbitratePayment(
        address token,
        address from,
        address to,
        uint256 railId,
        uint256 fromEpoch,
        uint256 toEpoch,
        uint256 amount
    ) external view returns (ArbitrationResult memory);
}
```

Interface for arbiter contracts that can adjust payment amounts based on service performance.
</file>

<file path="docs/payments/guides/first-rail.md">
# Setting Up Your First Payment Rail

This guide walks you through the process of creating and managing a payment rail in the FilOz Payments system.

## Prerequisites

- An Ethereum wallet with some ETH for gas
- ERC20 tokens to use for payments (e.g., USDC)
- Basic knowledge of Solidity and Ethereum transactions

## Step 1: Deploy or Connect to the Payments Contract

If you're using the existing FilOz deployment, you can connect to the contract at the official address. Otherwise, you can deploy your own instance.

```javascript
// Using ethers.js to connect to the Payments contract
const paymentsAbi = require('./abis/Payments.json');
const paymentsAddress = '0x805370387fA5Bd8053FD8f7B2da4055B9a4f8019'; // Example address
const payments = new ethers.Contract(paymentsAddress, paymentsAbi, signer);
```

## Step 2: Approve Token Spending

Before creating a rail, the payer needs to approve the Payments contract to spend their tokens:

```javascript
// Using ethers.js to approve token spending
const tokenAbi = require('./abis/ERC20.json');
const tokenAddress = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'; // USDC on Ethereum
const token = new ethers.Contract(tokenAddress, tokenAbi, signer);

// Approve a large amount to cover future payments
const approvalAmount = ethers.utils.parseUnits('1000', 6); // 1000 USDC (6 decimals)
await token.approve(paymentsAddress, approvalAmount);
```

## Step 3: Deposit Funds

The payer needs to deposit funds into the Payments contract:

```javascript
// Deposit funds into the Payments contract
const depositAmount = ethers.utils.parseUnits('100', 6); // 100 USDC
await payments.deposit(tokenAddress, payerAddress, depositAmount);
```

## Step 4: Create a Payment Rail

Now you can create a payment rail between the payer and payee:

```javascript
// Create a payment rail
const paymentRate = ethers.utils.parseUnits('0.01', 6); // 0.01 USDC per epoch
const lockupPeriod = 2880; // 1 day in epochs (assuming 30-second epochs)
const lockupFixed = ethers.utils.parseUnits('5', 6); // 5 USDC fixed lockup
const commissionRate = 250; // 2.5% commission

const tx = await payments.createRail(
    tokenAddress,
    payerAddress,
    payeeAddress,
    arbiterAddress, // Use zero address for no arbiter
    paymentRate,
    lockupPeriod,
    lockupFixed,
    commissionRate
);

// Wait for the transaction to be mined
const receipt = await tx.wait();

// Get the rail ID from the event logs
const railId = receipt.events[0].args.railId;
console.log(`Created rail with ID: ${railId}`);
```

## Step 5: Monitor the Rail Status

You can check the status of your rail:

```javascript
// Get rail details
const rail = await payments.getRail(railId);
console.log('Rail details:', {
    token: rail.token,
    from: rail.from,
    to: rail.to,
    paymentRate: ethers.utils.formatUnits(rail.paymentRate, 6),
    lockupPeriod: rail.lockupPeriod.toString(),
    settledUpTo: rail.settledUpTo.toString(),
    endEpoch: rail.endEpoch.toString()
});

// Check account balances
const payerAccount = await payments.accounts(tokenAddress, payerAddress);
console.log('Payer account:', {
    funds: ethers.utils.formatUnits(payerAccount.funds, 6),
    lockupCurrent: ethers.utils.formatUnits(payerAccount.lockupCurrent, 6),
    lockupRate: ethers.utils.formatUnits(payerAccount.lockupRate, 6)
});
```

## Step 6: Settle Payments

Payments can be settled by anyone, typically the payee:

```javascript
// Settle payments up to the current epoch
const currentEpoch = await ethers.provider.getBlockNumber();
await payments.settleRail(railId, currentEpoch);
```

## Step 7: Modify the Rail (Optional)

If needed, the rail operator can modify the rail parameters:

```javascript
// Modify the lockup parameters
await payments.modifyRailLockup(
    railId,
    3600, // New lockup period
    ethers.utils.parseUnits('6', 6) // New fixed lockup
);

// Modify the payment rate
await payments.modifyRailPayment(
    railId,
    ethers.utils.parseUnits('0.015', 6), // New payment rate
    0 // No one-time payment
);
```

## Step 8: Terminate the Rail (Optional)

When the service is no longer needed, the rail can be terminated:

```javascript
// Terminate the rail
await payments.terminateRail(railId);
```

## Step 9: Withdraw Funds

Users can withdraw their available funds:

```javascript
// Withdraw funds
const withdrawAmount = ethers.utils.parseUnits('50', 6); // 50 USDC
await payments.withdraw(tokenAddress, withdrawAmount);
```

## Integration with PDP

To integrate with the PDP system, you'll need to:

1. Create a proof set in the PDP system
2. Use an arbiter that checks PDP compliance
3. Include the payment rail ID in the PDP extradata

```javascript
// Create a proof set with payment information
const extraData = ethers.utils.defaultAbiCoder.encode(
    ['uint256', 'address'],
    [railId, paymentsAddress]
);

await pdpVerifier.createProofSet(
    pdpServiceAddress,
    extraData,
    { value: sybilFee }
);
```

## Example Arbiter Implementation

Here's a simple arbiter that reduces payments based on PDP faults:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IArbiter.sol";
import "./IPDPService.sol";

contract PDPArbiter is IArbiter {
    IPDPService public pdpService;
    
    constructor(address _pdpService) {
        pdpService = IPDPService(_pdpService);
    }
    
    function arbitratePayment(
        address token,
        address from,
        address to,
        uint256 railId,
        uint256 fromEpoch,
        uint256 toEpoch,
        uint256 amount
    ) external view override returns (ArbitrationResult memory) {
        // Get the proof set ID from the rail ID (implementation depends on your mapping)
        uint256 proofSetId = getProofSetIdForRail(railId);
        
        // Get fault count from PDP service
        uint256 faultCount = pdpService.getFaultCount(proofSetId, fromEpoch, toEpoch);
        
        // Calculate reduction (10% per fault, up to 100%)
        uint256 reductionPercent = faultCount * 10;
        if (reductionPercent > 100) reductionPercent = 100;
        
        uint256 reduction = amount * reductionPercent / 100;
        uint256 modifiedAmount = amount - reduction;
        
        return ArbitrationResult({
            modifiedAmount: modifiedAmount,
            settleUpto: toEpoch,
            note: string(abi.encodePacked("Reduced by ", faultCount, " faults"))
        });
    }
    
    function getProofSetIdForRail(uint256 railId) internal view returns (uint256) {
        // Implementation depends on how you map rails to proof sets
        // This could be stored in a mapping or derived from the rail ID
        return railId; // Simplified example
    }
}
```

## Troubleshooting

### Insufficient Funds

If you encounter "insufficient funds" errors:
- Check that the payer has deposited enough tokens
- Verify that the tokens are approved for the Payments contract
- Ensure the lockup amount isn't too high relative to the deposited funds

### Failed Settlements

If settlements fail:
- Check that the rail hasn't been terminated
- Verify that the settlement epoch is greater than the last settled epoch
- Ensure the arbiter contract (if used) is functioning correctly

## Next Steps

- [Implementing a Custom Arbiter](custom-arbiter.md)
- [Advanced Rail Management](advanced-rails.md)
- [Payments API Reference](../api/payments-contract.md)
</file>

<file path="docs/payments/payment-rails.md">
# Payment Rails

## Table of Contents

- [Overview](#overview)
- [Key Concepts](#key-concepts)
  - [What is a Payment Rail?](#what-is-a-payment-rail)
  - [Epoch Duration](#epoch-duration)
  - [Payment Rate Calculation](#payment-rate-calculation)
  - [Rail Structure](#rail-structure)
- [How Payment Rails Work](#how-payment-rails-work)
  - [1. Rail Creation](#1-rail-creation)
  - [2. Fund Lockup](#2-fund-lockup)
  - [3. Payment Flow](#3-payment-flow)
  - [4. Arbitration](#4-arbitration)
  - [5. Rail Management](#5-rail-management)
  - [6. Rail Updates and Their Impact](#6-rail-updates-and-their-impact)
- [Integration with PDP](#integration-with-pdp)
- [Best Practices](#best-practices)
- [API Reference](#api-reference)
- [Examples](#examples)
- [Next Steps](#next-steps)

## Overview

Payment Rails are a core component of the PDP-Payments (FWS) system that enable continuous, programmable payment flows between clients and storage providers. They function as dedicated payment channels that automate the process of compensating storage providers for their services while enforcing Service Level Agreements (SLAs).

## Key Concepts

### What is a Payment Rail?

A Payment Rail is a smart contract-based payment channel that:

1. **Connects two parties**: A payer (client) and a payee (storage provider)
2. **Enables continuous payments**: Funds flow at a specified rate over time
3. **Enforces SLAs**: Integrates with arbiters to adjust payments based on service quality
4. **Provides security**: Locks funds to ensure payment obligations are met
5. **Offers flexibility**: Allows for rate adjustments and termination conditions

### Epoch Duration

In the Filecoin network, one epoch is approximately **30 seconds** in clock time. This is a fundamental parameter in the system because:

1. The `paymentRate` is specified as tokens per epoch
2. The `lockupPeriod` is measured in epochs (e.g., 2880 epochs = 1 day)
3. Settlement intervals and proof submission windows are measured in epochs

When calculating costs and rates, this epoch duration must be considered:

```javascript
// Converting between time-based rates and epoch-based rates
// Example: $5/month for 100 GB of data
const dollarsPerMonth = 5.0;
const secondsPerMonth = 30 * 24 * 60 * 60; // 30 days in seconds
const secondsPerEpoch = 30; // 30 seconds per epoch
const epochsPerMonth = secondsPerMonth / secondsPerEpoch; // ~86,400 epochs
const dollarsPerEpoch = dollarsPerMonth / epochsPerMonth; // ~$0.0000579 per epoch

console.log(`Monthly rate: $${dollarsPerMonth}`);
console.log(`Per-epoch rate: $${dollarsPerEpoch.toFixed(8)}`);
console.log(`Token units per epoch (6 decimals): ${ethers.utils.parseUnits(dollarsPerEpoch.toFixed(8), 6)}`);
// Output:
// Monthly rate: $5
// Per-epoch rate: $0.00005787
// Token units per epoch (6 decimals): 57870
```

### Payment Rate Calculation

The `paymentRate` parameter represents the rate at which funds flow from the client to the storage provider per epoch. This rate is typically calculated off-chain based on several factors:

```javascript
// Example of calculating payment rate based on data size and market factors
function calculatePaymentRate(dataSize, storagePrice, epochsPerDay) {
    // Convert data size to GB
    const dataSizeGB = dataSize / (1024 * 1024 * 1024);

    // Calculate daily cost based on market price per GB
    const dailyCost = dataSizeGB * storagePrice;

    // Convert to per-epoch rate
    const paymentRate = ethers.utils.parseUnits(
        (dailyCost / epochsPerDay).toFixed(6),
        6
    );

    return paymentRate;
}

// Usage example for $5/month for 100 GB
const dataSize = 100 * 1024 * 1024 * 1024; // 100 GB in bytes
const daysPerMonth = 30;
const dailyRate = 5 / daysPerMonth; // $0.1667 per day for 100 GB
const pricePerGBPerDay = dailyRate / 100; // $0.001667 per GB per day
const epochsPerDay = 2880; // 30-second epochs
const rate = calculatePaymentRate(dataSize, pricePerGBPerDay, epochsPerDay);

console.log(`Payment rate for 100 GB at $5/month: ${rate} token units per epoch`);
// This would result in approximately 57,870 token units per epoch
```

Factors that typically influence the payment rate include:

1. **Data Size**: Larger data requires more storage resources
2. **Storage Duration**: Longer commitments may have different pricing
3. **Market Rates**: Competitive pricing based on current market conditions
4. **Quality of Service**: Premium service levels (such as faster retrieval times, higher redundancy, or better geographic distribution) may command higher rates and are negotiated between the client and storage provider

### Rail Structure

Each Payment Rail is represented by a data structure with the following components:

```solidity
struct Rail {
    address token;        // ERC20 token used for payments
    address from;         // Payer address
    address to;           // Payee address
    address operator;     // Entity that can modify the rail
    address arbiter;      // Optional arbiter for SLA enforcement
    
    uint256 paymentRate;  // Rate at which payments flow (per epoch)
    uint256 lockupPeriod; // Number of epochs for which funds are locked
    uint256 lockupFixed;  // Fixed amount of funds locked
    
    uint256 settledUpTo;  // Epoch up to which payments have been settled
    uint256 endEpoch;     // Epoch at which the rail terminates
    uint256 commissionRateBps; // Commission rate in basis points
    
    RateChange[] rateChangeQueue; // Queue of scheduled rate changes
}
```

## How Payment Rails Work

### 1. Rail Creation

A Payment Rail is created by calling the `createRail` function in the Payments contract:

```solidity
function createRail(
    address token,
    address from,
    address to,
    address arbiter,
    uint256 paymentRate,
    uint256 lockupPeriod,
    uint256 lockupFixed,
    uint256 commissionRateBps
) external returns (uint256 railId)
```

**Example:**
```javascript
// Create a payment rail with USDC
async function createPaymentRail() {
    // Contract instance
    const payments = new ethers.Contract(paymentsAddress, paymentsAbi, wallet);
    
    // Parameters
    const tokenAddress = '0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0'; // USDC on testnet
    const clientAddress = wallet.address;
    const providerAddress = '0x123...'; // Storage provider address
    const arbiterAddress = '0x456...'; // Arbiter address
    const paymentRate = ethers.utils.parseUnits('0.01', 6); // 0.01 USDC per epoch
    const lockupPeriod = 2880; // 1 day in epochs (assuming 30-second epochs)
    const lockupFixed = ethers.utils.parseUnits('5', 6); // 5 USDC fixed lockup
    const commissionRate = 250; // 2.5% commission
    
    // Create the rail
    const tx = await payments.createRail(
        tokenAddress,
        clientAddress,
        providerAddress,
        arbiterAddress,
        paymentRate,
        lockupPeriod,
        lockupFixed,
        commissionRate
    );
    
    const receipt = await tx.wait();
    const railId = receipt.events[0].args.railId;
    
    return railId;
}
```

### 2. Fund Lockup

When a rail is created, funds are locked in the Payments contract to ensure payment obligations:

```javascript
// Before creating a rail, deposit funds
async function depositFunds(tokenAddress, amount) {
    // Approve the Payments contract to spend tokens
    const token = new ethers.Contract(tokenAddress, tokenAbi, wallet);
    await token.approve(paymentsAddress, amount);
    
    // Deposit funds
    const payments = new ethers.Contract(paymentsAddress, paymentsAbi, wallet);
    await payments.deposit(tokenAddress, wallet.address, amount);
}
```

The lockup amount is calculated as:
- Fixed lockup amount (`lockupFixed`)
- Plus the payment rate multiplied by the lockup period (`paymentRate * lockupPeriod`)

### 3. Payment Flow

Payments flow continuously at the specified rate, but are settled discretely:

```javascript
// Settle payments up to the current epoch
async function settlePayments(railId) {
    const payments = new ethers.Contract(paymentsAddress, paymentsAbi, wallet);
    const currentEpoch = await provider.getBlockNumber();
    await payments.settleRail(railId, currentEpoch);
}
```

### 4. Arbitration

If an arbiter is specified, it can adjust payment amounts based on service quality:

```solidity
interface IArbiter {
    struct ArbitrationResult {
        uint256 modifiedAmount; // Adjusted payment amount
        uint256 settleUpto;     // Epoch up to which to settle
        string note;            // Additional information
    }
    
    function arbitratePayment(
        address token,
        address from,
        address to,
        uint256 railId,
        uint256 fromEpoch,
        uint256 toEpoch,
        uint256 amount
    ) external view returns (ArbitrationResult memory);
}
```

**Example Arbiter Implementation:**
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IArbiter.sol";
import "./IPDPService.sol";

contract PDPArbiter is IArbiter {
    IPDPService public pdpService;
    mapping(uint256 => uint256) public railToProofSet;
    
    constructor(address _pdpService) {
        pdpService = IPDPService(_pdpService);
    }
    
    function registerRailProofSet(uint256 railId, uint256 proofSetId) external {
        // Add appropriate access control here
        railToProofSet[railId] = proofSetId;
    }
    
    function arbitratePayment(
        address token,
        address from,
        address to,
        uint256 railId,
        uint256 fromEpoch,
        uint256 toEpoch,
        uint256 amount
    ) external view override returns (ArbitrationResult memory) {
        uint256 proofSetId = railToProofSet[railId];
        
        if (proofSetId == 0) {
            return ArbitrationResult({
                modifiedAmount: amount,
                settleUpto: toEpoch,
                note: "No proof set registered"
            });
        }
        
        uint256 faultCount = pdpService.getFaultCount(proofSetId, fromEpoch, toEpoch);
        uint256 reductionPercent = faultCount * 10;
        if (reductionPercent > 100) reductionPercent = 100;
        
        uint256 reduction = amount * reductionPercent / 100;
        uint256 modifiedAmount = amount - reduction;
        
        return ArbitrationResult({
            modifiedAmount: modifiedAmount,
            settleUpto: toEpoch,
            note: string(abi.encodePacked("Reduced by ", faultCount, " faults"))
        });
    }
}
```

### 5. Rail Management

Rails can be modified and terminated:

```javascript
// Modify the payment rate
async function modifyRailPayment(railId, newRate) {
    const payments = new ethers.Contract(paymentsAddress, paymentsAbi, wallet);
    await payments.modifyRailPayment(
        railId,
        newRate,  // New payment rate
        0         // No one-time payment
    );
}

// Terminate the rail
async function terminateRail(railId) {
    const payments = new ethers.Contract(paymentsAddress, paymentsAbi, wallet);
    await payments.terminateRail(railId);
}
```

### 6. Rail Updates and Their Impact

When a payment rail is modified using `modifyRailPayment`, it's important to understand:

1. **What changes**: Typically the payment rate (`paymentRate`) is updated
2. **What doesn't change**: Proof obligations, verification schedule, and the actual data being stored remain the same
3. **Settlement implications**: Any unsettled payments before the update use the old rate; payments after use the new rate

#### Common Scenarios for Rail Updates

1. **Data expansion**: When a client adds more data to be stored
   ```javascript
   // Example: Updating payment rate when data size increases
   async function updateRailForNewData(railId, originalDataSize, newDataSize, originalRate) {
       // Calculate new rate proportional to data increase
       const dataRatio = newDataSize / originalDataSize;
       const newRate = originalRate.mul(ethers.BigNumber.from(Math.floor(dataRatio * 100))).div(100);

       await payments.modifyRailPayment(railId, newRate, 0);
   }
   ```

2. **Price adjustments**: Responding to market changes
   ```javascript
   // Example: Applying a price increase
   async function applyPriceIncrease(railId, currentRate, percentIncrease) {
       const newRate = currentRate.mul(100 + percentIncrease).div(100);
       await payments.modifyRailPayment(railId, newRate, 0);
   }
   ```

#### Relationship with PDP System

Rail updates do not directly affect the PDP proof requirements:

1. The storage provider must continue to submit proofs for all data
2. The arbiter continues to evaluate proof compliance using the same criteria
3. The payment amount that gets adjusted by the arbiter will be based on the new rate

#### Best Practices for Rail Updates

1. **Communicate changes**: Notify all parties before updating rails
2. **Document justification**: Record the reason for rate changes
3. **Settle before updates**: Consider settling payments before making rate changes
4. **Verify after updates**: Confirm the new rate is correctly applied

## Integration with PDP

Payment Rails integrate with the Provable Data Possession (PDP) system through arbiters:

1. A client creates a payment rail with a PDP arbiter
2. The client creates a proof set in the PDP system
3. The arbiter links the rail to the proof set
4. When settling payments, the arbiter checks for faults in the PDP system
5. The arbiter adjusts payment amounts based on proof compliance

```javascript
// Complete integration example
async function setupPDPPaymentIntegration() {
    // Create a payment rail with a PDP arbiter
    const railId = await createPaymentRail();
    
    // Create a proof set with payment information
    const extraData = ethers.utils.defaultAbiCoder.encode(
        ['uint256', 'address'],
        [railId, paymentsContractAddress]
    );
    
    const proofSetId = await createProofSet(pdpServiceAddress, extraData);
    
    // Register the rail-to-proof-set mapping in the arbiter
    await pdpArbiter.registerRailProofSet(railId, proofSetId);
    
    return { railId, proofSetId };
}
```

## Best Practices

### Security Considerations

1. **Fund Management**: Ensure sufficient funds are deposited before creating rails
2. **Rate Limiting**: Set reasonable payment rates to prevent rapid fund depletion
3. **Arbiter Security**: Implement proper access controls in arbiter contracts
4. **Regular Settlement**: Settle payments regularly to maintain accurate balances

### Implementation Tips

1. **Monitoring**: Implement monitoring for rail status and fund levels
2. **Error Handling**: Add robust error handling for contract interactions
3. **Gas Optimization**: Batch operations when managing multiple rails
4. **Testing**: Thoroughly test on testnets before deploying to mainnet

## API Reference

### Core Functions

#### Creating a Rail

```solidity
function createRail(
    address token,
    address from,
    address to,
    address arbiter,
    uint256 paymentRate,
    uint256 lockupPeriod,
    uint256 lockupFixed,
    uint256 commissionRateBps
) external returns (uint256 railId)
```

#### Settling Payments

```solidity
function settleRail(uint256 railId, uint256 settleUpto) external
```

#### Modifying a Rail

```solidity
function modifyRailPayment(
    uint256 railId,
    uint256 newRate,
    uint256 oneTimePayment
) external
```

#### Terminating a Rail

```solidity
function terminateRail(uint256 railId) external
```

## Examples

### Basic Payment Rail

```javascript
// Create a basic payment rail without an arbiter
async function createBasicPaymentRail() {
    const tokenAddress = '0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0';
    const clientAddress = wallet.address;
    const providerAddress = '0x123...';
    const arbiterAddress = ethers.constants.AddressZero; // No arbiter
    const paymentRate = ethers.utils.parseUnits('0.01', 6);
    const lockupPeriod = 2880;
    const lockupFixed = ethers.utils.parseUnits('5', 6);
    const commissionRate = 0; // No commission
    
    // Deposit funds
    await depositFunds(tokenAddress, ethers.utils.parseUnits('100', 6));
    
    // Create the rail
    const railId = await createRail(
        tokenAddress,
        clientAddress,
        providerAddress,
        arbiterAddress,
        paymentRate,
        lockupPeriod,
        lockupFixed,
        commissionRate
    );
    
    return railId;
}
```

### PDP-Integrated Payment Rail

```javascript
// Create a payment rail integrated with PDP
async function createPDPPaymentRail() {
    // Create a PDP arbiter
    const pdpArbiterFactory = new ethers.ContractFactory(
        pdpArbiterAbi,
        pdpArbiterBytecode,
        wallet
    );
    
    const pdpArbiter = await pdpArbiterFactory.deploy(pdpServiceAddress);
    await pdpArbiter.deployed();
    
    // Create a payment rail with the PDP arbiter
    const railId = await createRail(
        tokenAddress,
        clientAddress,
        providerAddress,
        pdpArbiter.address,
        paymentRate,
        lockupPeriod,
        lockupFixed,
        commissionRate
    );
    
    return { railId, pdpArbiter };
}
```

## Next Steps

- Learn about [PDP Integration](../integration/pdp-payments.md)
- Explore the [Payments System](overview.md)
- Follow the [Quick Start Guide](../quick-start.md)
- See a complete example in the [Hot Vault Demo](../examples/hot-vault.md)
</file>

<file path="docs/pdp/guides/creating-proof-set.md">
# Creating a Proof Set

This guide explains how to create a proof set in the PDP system, which is the first step in verifying data possession.

## Prerequisites

- An Ethereum wallet with some ETH for gas
- The address of the PDPVerifier contract
- The address of the PDPService contract (e.g., SimplePDPService)

## Step 1: Connect to the PDPVerifier Contract

First, connect to the PDPVerifier contract:

```javascript
const ethers = require('ethers');
const pdpVerifierAbi = require('./abis/PDPVerifier.json');

// Connect to the provider
const provider = new ethers.providers.JsonRpcProvider('https://calibration.filfox.info/rpc/v1');
const wallet = new ethers.Wallet(privateKey, provider);

// PDPVerifier contract address on Calibration Testnet
const pdpVerifierAddress = '0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC';

// Create contract instance
const pdpVerifier = new ethers.Contract(pdpVerifierAddress, pdpVerifierAbi, wallet);
```

## Step 2: Prepare Extra Data

The extra data is a crucial component that allows for extending the basic proof set with additional metadata. In this example, we'll include payment information:

```javascript
// Encode payment information in the extra data
const extraData = ethers.utils.defaultAbiCoder.encode(
    ['uint256', 'address'],
    [railId, paymentsContractAddress]
);
```

If you're not using the Payments system, you can provide an empty byte array:

```javascript
const extraData = '0x';
```

## Step 3: Calculate the Sybil Fee

The PDPVerifier requires a sybil fee to prevent spam attacks:

```javascript
// Get the current sybil fee
const sybilFee = await pdpVerifier.sybilFee();
console.log(`Sybil fee: ${ethers.utils.formatEther(sybilFee)} ETH`);
```

## Step 4: Create the Proof Set

Now, create the proof set by calling the `createProofSet` function:

```javascript
// PDPService contract address on Calibration Testnet
const pdpServiceAddress = '0x6170dE2b09b404776197485F3dc6c968Ef948505';

// Create the proof set
const tx = await pdpVerifier.createProofSet(
    pdpServiceAddress, // The SLA contract address
    extraData,         // The extra data
    { value: sybilFee } // Pay the sybil fee
);

// Wait for the transaction to be mined
const receipt = await tx.wait();

// Get the proof set ID from the event logs
const proofSetId = receipt.events[0].args.setId;
console.log(`Created proof set with ID: ${proofSetId}`);
```

## Step 5: Verify the Proof Set Creation

You can verify that the proof set was created successfully:

```javascript
// Check if the proof set is live
const isLive = await pdpVerifier.proofSetLive(proofSetId);
console.log(`Proof set is live: ${isLive}`);

// Get the proof set owner
const [owner, proposedOwner] = await pdpVerifier.getProofSetOwner(proofSetId);
console.log(`Proof set owner: ${owner}`);

// Get the proof set listener (SLA contract)
const listener = await pdpVerifier.getProofSetListener(proofSetId);
console.log(`Proof set listener: ${listener}`);
```

## Complete Example

Here's a complete example of creating a proof set:

```javascript
const ethers = require('ethers');
const pdpVerifierAbi = require('./abis/PDPVerifier.json');

async function createProofSet() {
    // Connect to the provider
    const provider = new ethers.providers.JsonRpcProvider('https://calibration.filfox.info/rpc/v1');
    const wallet = new ethers.Wallet(privateKey, provider);
    
    // PDPVerifier contract address on Calibration Testnet
    const pdpVerifierAddress = '0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC';
    
    // Create contract instance
    const pdpVerifier = new ethers.Contract(pdpVerifierAddress, pdpVerifierAbi, wallet);
    
    // PDPService contract address on Calibration Testnet
    const pdpServiceAddress = '0x6170dE2b09b404776197485F3dc6c968Ef948505';
    
    // Encode payment information in the extra data (if using Payments)
    const extraData = ethers.utils.defaultAbiCoder.encode(
        ['uint256', 'address'],
        [railId, paymentsContractAddress]
    );
    
    // Get the current sybil fee
    const sybilFee = await pdpVerifier.sybilFee();
    console.log(`Sybil fee: ${ethers.utils.formatEther(sybilFee)} ETH`);
    
    // Create the proof set
    const tx = await pdpVerifier.createProofSet(
        pdpServiceAddress,
        extraData,
        { value: sybilFee }
    );
    
    // Wait for the transaction to be mined
    const receipt = await tx.wait();
    
    // Get the proof set ID from the event logs
    const proofSetId = receipt.events[0].args.setId;
    console.log(`Created proof set with ID: ${proofSetId}`);
    
    // Verify the proof set creation
    const isLive = await pdpVerifier.proofSetLive(proofSetId);
    console.log(`Proof set is live: ${isLive}`);
    
    return proofSetId;
}

createProofSet()
    .then(proofSetId => console.log(`Proof set created with ID: ${proofSetId}`))
    .catch(error => console.error(`Error creating proof set: ${error}`));
```

## Next Steps

After creating a proof set, you'll need to:

1. [Add data to the proof set](adding-data.md)
2. [Submit proofs](submitting-proofs.md) to demonstrate data possession
3. [Verify proofs](verifying-proofs.md) to ensure data is being stored correctly

For a complete example of using proof sets in a real application, see the [Hot Vault Demo](../../examples/hot-vault.md).
</file>

<file path="docs/pdp/guides/submitting-proofs.md">
# Submitting Proofs

This guide explains how to submit proofs of data possession to the PDP system, which is a key step in demonstrating that you are still storing the data.

## Prerequisites

- An Ethereum wallet with some ETH for gas
- A proof set ID from [creating a proof set](creating-proof-set.md)
- Data added to the proof set (see [adding data](adding-data.md))
- The PDP Tool for generating proofs

## Step 1: Install the PDP Tool

The PDP Tool is required to generate proofs. You can install it from the [Curio repository](https://github.com/filecoin-project/curio/tree/feat/pdp):

```bash
git clone -b feat/pdp https://github.com/filecoin-project/curio.git
cd curio
make pdp
```

## Step 2: Check When to Submit Proofs

Before submitting proofs, you need to check if it's time to do so:

```javascript
const ethers = require('ethers');
const pdpVerifierAbi = require('./abis/PDPVerifier.json');

// Connect to the provider
const provider = new ethers.providers.JsonRpcProvider('https://calibration.filfox.info/rpc/v1');
const wallet = new ethers.Wallet(privateKey, provider);

// PDPVerifier contract address on Calibration Testnet
const pdpVerifierAddress = '0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC';

// Create contract instance
const pdpVerifier = new ethers.Contract(pdpVerifierAddress, pdpVerifierAbi, wallet);

// Check the next challenge epoch
const nextChallengeEpoch = await pdpVerifier.getNextChallengeEpoch(proofSetId);
const currentEpoch = await provider.getBlockNumber();

console.log(`Next challenge epoch: ${nextChallengeEpoch}`);
console.log(`Current epoch: ${currentEpoch}`);

if (currentEpoch >= nextChallengeEpoch) {
    console.log('It is time to submit proofs!');
} else {
    console.log(`Wait ${nextChallengeEpoch - currentEpoch} more epochs before submitting proofs.`);
}
```

## Step 3: Generate Proofs

To generate proofs, you'll need to use the PDP Tool. Here's a simplified example:

```bash
# Export environment variables
export PROOF_SET_ID=your_proof_set_id
export PDP_VERIFIER_ADDRESS=0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC
export RPC_URL=https://calibration.filfox.info/rpc/v1
export PRIVATE_KEY=your_private_key

# Generate proofs
pdp prove --proof-set-id $PROOF_SET_ID --verifier-address $PDP_VERIFIER_ADDRESS --rpc-url $RPC_URL
```

This will generate a JSON file containing the proofs.

## Step 4: Submit Proofs

Once you have generated the proofs, you can submit them to the PDPVerifier contract:

```javascript
const fs = require('fs');
const ethers = require('ethers');
const pdpVerifierAbi = require('./abis/PDPVerifier.json');

// Connect to the provider
const provider = new ethers.providers.JsonRpcProvider('https://calibration.filfox.info/rpc/v1');
const wallet = new ethers.Wallet(privateKey, provider);

// PDPVerifier contract address on Calibration Testnet
const pdpVerifierAddress = '0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC';

// Create contract instance
const pdpVerifier = new ethers.Contract(pdpVerifierAddress, pdpVerifierAbi, wallet);

// Load the proofs from the JSON file
const proofsJson = fs.readFileSync('./proofs.json', 'utf8');
const proofs = JSON.parse(proofsJson);

// Calculate the proof fee
const estimatedGasFee = 1000000; // Estimate gas fee (adjust as needed)
const proofFee = await pdpVerifier.calculateProofFee(proofSetId, estimatedGasFee);

console.log(`Proof fee: ${ethers.utils.formatEther(proofFee)} ETH`);

// Submit the proofs
const tx = await pdpVerifier.provePossession(
    proofSetId,
    proofs,
    { value: proofFee }
);

// Wait for the transaction to be mined
const receipt = await tx.wait();

console.log(`Proofs submitted in transaction: ${receipt.transactionHash}`);
```

## Step 5: Verify Proof Submission

You can verify that the proofs were submitted successfully:

```javascript
// Get the last proven epoch
const lastProvenEpoch = await pdpVerifier.getProofSetLastProvenEpoch(proofSetId);
console.log(`Last proven epoch: ${lastProvenEpoch}`);

// Check if the next challenge epoch has been updated
const nextChallengeEpoch = await pdpVerifier.getNextChallengeEpoch(proofSetId);
console.log(`Next challenge epoch: ${nextChallengeEpoch}`);
```

## Complete Example

Here's a complete example of checking when to submit proofs and submitting them:

```javascript
const fs = require('fs');
const ethers = require('ethers');
const { exec } = require('child_process');
const pdpVerifierAbi = require('./abis/PDPVerifier.json');

async function submitProofs(proofSetId) {
    // Connect to the provider
    const provider = new ethers.providers.JsonRpcProvider('https://calibration.filfox.info/rpc/v1');
    const wallet = new ethers.Wallet(privateKey, provider);
    
    // PDPVerifier contract address on Calibration Testnet
    const pdpVerifierAddress = '0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC';
    
    // Create contract instance
    const pdpVerifier = new ethers.Contract(pdpVerifierAddress, pdpVerifierAbi, wallet);
    
    // Check the next challenge epoch
    const nextChallengeEpoch = await pdpVerifier.getNextChallengeEpoch(proofSetId);
    const currentEpoch = await provider.getBlockNumber();
    
    console.log(`Next challenge epoch: ${nextChallengeEpoch}`);
    console.log(`Current epoch: ${currentEpoch}`);
    
    if (currentEpoch < nextChallengeEpoch) {
        console.log(`Wait ${nextChallengeEpoch - currentEpoch} more epochs before submitting proofs.`);
        return;
    }
    
    console.log('Generating proofs...');
    
    // Generate proofs using the PDP Tool
    const command = `pdp prove --proof-set-id ${proofSetId} --verifier-address ${pdpVerifierAddress} --rpc-url https://calibration.filfox.info/rpc/v1`;
    
    exec(command, async (error, stdout, stderr) => {
        if (error) {
            console.error(`Error generating proofs: ${error}`);
            return;
        }
        
        console.log('Proofs generated successfully!');
        
        // Load the proofs from the JSON file
        const proofsJson = fs.readFileSync(`./proofs_${proofSetId}.json`, 'utf8');
        const proofs = JSON.parse(proofsJson);
        
        // Calculate the proof fee
        const estimatedGasFee = 1000000; // Estimate gas fee (adjust as needed)
        const proofFee = await pdpVerifier.calculateProofFee(proofSetId, estimatedGasFee);
        
        console.log(`Proof fee: ${ethers.utils.formatEther(proofFee)} ETH`);
        
        // Submit the proofs
        const tx = await pdpVerifier.provePossession(
            proofSetId,
            proofs,
            { value: proofFee }
        );
        
        // Wait for the transaction to be mined
        const receipt = await tx.wait();
        
        console.log(`Proofs submitted in transaction: ${receipt.transactionHash}`);
        
        // Verify proof submission
        const lastProvenEpoch = await pdpVerifier.getProofSetLastProvenEpoch(proofSetId);
        console.log(`Last proven epoch: ${lastProvenEpoch}`);
        
        // Check if the next challenge epoch has been updated
        const nextChallengeEpoch = await pdpVerifier.getNextChallengeEpoch(proofSetId);
        console.log(`Next challenge epoch: ${nextChallengeEpoch}`);
    });
}

// Usage
submitProofs(your_proof_set_id)
    .catch(error => console.error(`Error submitting proofs: ${error}`));
```

## Automating Proof Submission

In a production environment, you'll want to automate proof submission. Here's a simple Node.js script that you can run as a cron job:

```javascript
const fs = require('fs');
const ethers = require('ethers');
const { exec } = require('child_process');
const pdpVerifierAbi = require('./abis/PDPVerifier.json');

// Configuration
const config = {
    rpcUrl: 'https://calibration.filfox.info/rpc/v1',
    privateKey: 'your_private_key',
    pdpVerifierAddress: '0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC',
    proofSetIds: [1, 2, 3], // List of proof set IDs to monitor
    checkIntervalMinutes: 10, // How often to check if proofs need to be submitted
};

// Connect to the provider
const provider = new ethers.providers.JsonRpcProvider(config.rpcUrl);
const wallet = new ethers.Wallet(config.privateKey, provider);
const pdpVerifier = new ethers.Contract(config.pdpVerifierAddress, pdpVerifierAbi, wallet);

// Main function to check and submit proofs
async function checkAndSubmitProofs() {
    const currentEpoch = await provider.getBlockNumber();
    console.log(`Current epoch: ${currentEpoch}`);
    
    for (const proofSetId of config.proofSetIds) {
        try {
            // Check if the proof set is live
            const isLive = await pdpVerifier.proofSetLive(proofSetId);
            if (!isLive) {
                console.log(`Proof set ${proofSetId} is not live. Skipping.`);
                continue;
            }
            
            // Check the next challenge epoch
            const nextChallengeEpoch = await pdpVerifier.getNextChallengeEpoch(proofSetId);
            console.log(`Proof set ${proofSetId} - Next challenge epoch: ${nextChallengeEpoch}`);
            
            // If it's time to submit proofs
            if (currentEpoch >= nextChallengeEpoch) {
                console.log(`Submitting proofs for proof set ${proofSetId}...`);
                submitProofs(proofSetId);
            } else {
                console.log(`Proof set ${proofSetId} - Wait ${nextChallengeEpoch - currentEpoch} more epochs.`);
            }
        } catch (error) {
            console.error(`Error processing proof set ${proofSetId}: ${error}`);
        }
    }
}

// Function to submit proofs
async function submitProofs(proofSetId) {
    // Generate proofs using the PDP Tool
    const command = `pdp prove --proof-set-id ${proofSetId} --verifier-address ${config.pdpVerifierAddress} --rpc-url ${config.rpcUrl}`;
    
    exec(command, async (error, stdout, stderr) => {
        if (error) {
            console.error(`Error generating proofs for proof set ${proofSetId}: ${error}`);
            return;
        }
        
        try {
            // Load the proofs from the JSON file
            const proofsJson = fs.readFileSync(`./proofs_${proofSetId}.json`, 'utf8');
            const proofs = JSON.parse(proofsJson);
            
            // Calculate the proof fee
            const estimatedGasFee = 1000000; // Estimate gas fee (adjust as needed)
            const proofFee = await pdpVerifier.calculateProofFee(proofSetId, estimatedGasFee);
            
            console.log(`Proof set ${proofSetId} - Proof fee: ${ethers.utils.formatEther(proofFee)} ETH`);
            
            // Submit the proofs
            const tx = await pdpVerifier.provePossession(
                proofSetId,
                proofs,
                { value: proofFee }
            );
            
            // Wait for the transaction to be mined
            const receipt = await tx.wait();
            
            console.log(`Proof set ${proofSetId} - Proofs submitted in transaction: ${receipt.transactionHash}`);
        } catch (error) {
            console.error(`Error submitting proofs for proof set ${proofSetId}: ${error}`);
        }
    });
}

// Run the check immediately
checkAndSubmitProofs();

// Then run it periodically
setInterval(checkAndSubmitProofs, config.checkIntervalMinutes * 60 * 1000);
```

## Next Steps

After submitting proofs, you may want to:

1. [Verify the proofs](verifying-proofs.md) to ensure they were accepted
2. [Handle any faults](handling-faults.md) that may have occurred
3. [Settle payments](../../payments/guides/first-rail.md#step-6-settle-payments) if you're using the Payments system

For a complete example of submitting proofs in a real application, see the [Hot Vault Demo](../../examples/hot-vault.md).
</file>

<file path="docs/pdp/guides/verifying-proofs.md">
# Verifying Proofs

This guide explains how to verify proofs in the PDP system, which is essential for confirming that storage providers are maintaining your data correctly.

## Prerequisites

- An Ethereum wallet with some ETH for gas
- A proof set ID from [creating a proof set](creating-proof-set.md)
- Proofs that have been [submitted](submitting-proofs.md) by the storage provider

## Step 1: Connect to the PDPVerifier Contract

First, connect to the PDPVerifier contract:

```javascript
const ethers = require('ethers');
const pdpVerifierAbi = require('./abis/PDPVerifier.json');

// Connect to the provider
const provider = new ethers.providers.JsonRpcProvider('https://calibration.filfox.info/rpc/v1');

// Connect to the PDPVerifier contract
const pdpVerifierAddress = '0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC'; // Calibration testnet
const pdpVerifier = new ethers.Contract(pdpVerifierAddress, pdpVerifierAbi, provider);
```

## Step 2: Check Proof Status

You can check the status of proofs for a specific proof set:

```javascript
async function checkProofStatus(proofSetId) {
    // Check if the proof set is live
    const isLive = await pdpVerifier.proofSetLive(proofSetId);
    console.log(`Proof set ${proofSetId} is live: ${isLive}`);
    
    if (!isLive) {
        console.log('Proof set is not live. No proofs can be verified.');
        return;
    }
    
    // Get the last proven epoch
    const lastProvenEpoch = await pdpVerifier.getProofSetLastProvenEpoch(proofSetId);
    console.log(`Last proven epoch: ${lastProvenEpoch}`);
    
    // Get the next challenge epoch
    const nextChallengeEpoch = await pdpVerifier.getNextChallengeEpoch(proofSetId);
    console.log(`Next challenge epoch: ${nextChallengeEpoch}`);
    
    // Get the current epoch
    const currentEpoch = await provider.getBlockNumber();
    console.log(`Current epoch: ${currentEpoch}`);
    
    // Check if proofs are up to date
    if (lastProvenEpoch >= nextChallengeEpoch - 1) {
        console.log('Proofs are up to date.');
    } else {
        console.log('Proofs are not up to date. The storage provider needs to submit new proofs.');
    }
}
```

## Step 3: Check Fault Count

You can check if there have been any faults (missed or invalid proofs):

```javascript
async function checkFaultCount(proofSetId) {
    // Get the PDP service address for this proof set
    const pdpServiceAddress = await pdpVerifier.getProofSetService(proofSetId);
    console.log(`PDP service address: ${pdpServiceAddress}`);
    
    // Connect to the PDP service contract
    const pdpServiceAbi = require('./abis/SimplePDPService.json');
    const pdpService = new ethers.Contract(pdpServiceAddress, pdpServiceAbi, provider);
    
    // Get the fault count
    const faultCount = await pdpService.getFaultCount(proofSetId);
    console.log(`Fault count: ${faultCount}`);
    
    if (faultCount.toNumber() > 0) {
        console.log('There have been faults in proof submission. This may affect payments.');
    } else {
        console.log('No faults detected. All proofs have been submitted correctly.');
    }
}
```

## Step 4: Verify Proof Details

For more detailed verification, you can check the specific proof details:

```javascript
async function getProofDetails(proofSetId) {
    // Get the proof set details
    const proofSet = await pdpVerifier.getProofSet(proofSetId);
    console.log('Proof set details:');
    console.log(`- Service: ${proofSet.service}`);
    console.log(`- Owner: ${proofSet.owner}`);
    console.log(`- Data root count: ${proofSet.dataRootCount}`);
    console.log(`- Last proven epoch: ${proofSet.lastProvenEpoch}`);
    
    // Get the PDP service address for this proof set
    const pdpServiceAddress = await pdpVerifier.getProofSetService(proofSetId);
    
    // Connect to the PDP service contract
    const pdpServiceAbi = require('./abis/SimplePDPService.json');
    const pdpService = new ethers.Contract(pdpServiceAddress, pdpServiceAbi, provider);
    
    // Get the service parameters
    const maxProvingPeriod = await pdpService.maxProvingPeriod();
    const challengeWindow = await pdpService.challengeWindow();
    const challengesPerProof = await pdpService.challengesPerProof();
    
    console.log('Service parameters:');
    console.log(`- Maximum proving period: ${maxProvingPeriod} epochs`);
    console.log(`- Challenge window: ${challengeWindow} epochs`);
    console.log(`- Challenges per proof: ${challengesPerProof}`);
    
    // Calculate the next deadline
    const nextChallengeEpoch = await pdpVerifier.getNextChallengeEpoch(proofSetId);
    const deadlineEpoch = nextChallengeEpoch + challengeWindow;
    const currentEpoch = await provider.getBlockNumber();
    
    console.log('Proof timing:');
    console.log(`- Current epoch: ${currentEpoch}`);
    console.log(`- Next challenge epoch: ${nextChallengeEpoch}`);
    console.log(`- Deadline epoch: ${deadlineEpoch}`);
    console.log(`- Time until deadline: ${deadlineEpoch - currentEpoch} epochs`);
}
```

## Step 5: Verify Proof Submission Events

You can also check for proof submission events:

```javascript
async function getProofSubmissionEvents(proofSetId) {
    // Define the event filter
    const filter = pdpVerifier.filters.ProofSubmitted(proofSetId);
    
    // Get the events (last 1000 blocks)
    const currentBlock = await provider.getBlockNumber();
    const events = await pdpVerifier.queryFilter(filter, currentBlock - 1000, currentBlock);
    
    console.log(`Found ${events.length} proof submission events for proof set ${proofSetId}:`);
    
    for (const event of events) {
        console.log(`- Block: ${event.blockNumber}`);
        console.log(`  Transaction: ${event.transactionHash}`);
        console.log(`  Submitter: ${event.args.submitter}`);
        console.log(`  Epoch: ${event.args.epoch}`);
    }
}
```

## Complete Example

Here's a complete example of verifying proofs for a proof set:

```javascript
const ethers = require('ethers');
const pdpVerifierAbi = require('./abis/PDPVerifier.json');
const pdpServiceAbi = require('./abis/SimplePDPService.json');

async function verifyProofs(proofSetId) {
    try {
        // Connect to the provider
        const provider = new ethers.providers.JsonRpcProvider('https://calibration.filfox.info/rpc/v1');
        
        // Connect to the PDPVerifier contract
        const pdpVerifierAddress = '0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC'; // Calibration testnet
        const pdpVerifier = new ethers.Contract(pdpVerifierAddress, pdpVerifierAbi, provider);
        
        // Check if the proof set is live
        const isLive = await pdpVerifier.proofSetLive(proofSetId);
        console.log(`Proof set ${proofSetId} is live: ${isLive}`);
        
        if (!isLive) {
            console.log('Proof set is not live. No proofs can be verified.');
            return;
        }
        
        // Get the proof set details
        const proofSet = await pdpVerifier.getProofSet(proofSetId);
        console.log('Proof set details:');
        console.log(`- Service: ${proofSet.service}`);
        console.log(`- Owner: ${proofSet.owner}`);
        console.log(`- Data root count: ${proofSet.dataRootCount}`);
        console.log(`- Last proven epoch: ${proofSet.lastProvenEpoch}`);
        
        // Get the PDP service address for this proof set
        const pdpServiceAddress = await pdpVerifier.getProofSetService(proofSetId);
        
        // Connect to the PDP service contract
        const pdpService = new ethers.Contract(pdpServiceAddress, pdpServiceAbi, provider);
        
        // Get the service parameters
        const maxProvingPeriod = await pdpService.maxProvingPeriod();
        const challengeWindow = await pdpService.challengeWindow();
        const challengesPerProof = await pdpService.challengesPerProof();
        
        console.log('Service parameters:');
        console.log(`- Maximum proving period: ${maxProvingPeriod} epochs`);
        console.log(`- Challenge window: ${challengeWindow} epochs`);
        console.log(`- Challenges per proof: ${challengesPerProof}`);
        
        // Get the fault count
        const faultCount = await pdpService.getFaultCount(proofSetId);
        console.log(`Fault count: ${faultCount}`);
        
        // Get the next challenge epoch
        const nextChallengeEpoch = await pdpVerifier.getNextChallengeEpoch(proofSetId);
        console.log(`Next challenge epoch: ${nextChallengeEpoch}`);
        
        // Get the current epoch
        const currentEpoch = await provider.getBlockNumber();
        console.log(`Current epoch: ${currentEpoch}`);
        
        // Check if proofs are up to date
        if (proofSet.lastProvenEpoch >= nextChallengeEpoch - maxProvingPeriod) {
            console.log('Proofs are up to date.');
        } else {
            console.log('Proofs are not up to date. The storage provider needs to submit new proofs.');
        }
        
        // Get proof submission events
        const filter = pdpVerifier.filters.ProofSubmitted(proofSetId);
        const events = await pdpVerifier.queryFilter(filter, currentEpoch - 1000, currentEpoch);
        
        console.log(`Found ${events.length} recent proof submission events.`);
        
        if (events.length > 0) {
            console.log('Most recent proof submission:');
            const latestEvent = events[events.length - 1];
            console.log(`- Block: ${latestEvent.blockNumber}`);
            console.log(`- Transaction: ${latestEvent.transactionHash}`);
            console.log(`- Submitter: ${latestEvent.args.submitter}`);
            console.log(`- Epoch: ${latestEvent.args.epoch}`);
        }
    } catch (error) {
        console.error(`Error verifying proofs: ${error}`);
    }
}

// Usage
verifyProofs(your_proof_set_id)
    .catch(error => console.error(`Error: ${error}`));
```

## Next Steps

After verifying proofs, you may want to:

1. [Handle any faults](handling-faults.md) that may have occurred
2. [Settle payments](../../payments/guides/first-rail.md#step-6-settle-payments) if you're using the Payments system
3. [Monitor proof submissions](monitoring-proofs.md) over time

For a complete example of verifying proofs in a real application, see the [Hot Vault Demo](../../examples/hot-vault.md).
</file>

<file path="docs/pdp/tools/pdptool-reference.md">
# PDPTool Reference Guide

## Overview

PDPTool is a command-line utility that serves as the primary interface for interacting with Proof of Data Possession (PDP) Storage Providers. It handles file uploads, proof set management, and communication with Storage Provider services.

PDPTool acts as a bridge between client applications and Storage Providers, enabling:
- File preparation and upload to Storage Providers
- Proof set creation and management
- Root management within proof sets
- Proof generation for data possession verification
- Service authentication and configuration

## Installation

### From Curio Repository

PDPTool is part of the Curio project and can be installed from the PDP feature branch:

```bash
git clone -b feat/pdp https://github.com/filecoin-project/curio.git
cd curio
make pdp
```

This will build the `pdptool` executable in the project directory.

### Installation Verification

After installation, verify pdptool is working:

```bash
# Check if pdptool is accessible
./pdptool --help

# Or if installed globally
pdptool --help
```

## Configuration

### Environment Setup

PDPTool requires configuration to connect to Storage Provider services. This is typically done through environment variables or command-line arguments.

### Service Registration

Before using pdptool with a Storage Provider, you need:
1. **Service Name**: Unique identifier registered with the Storage Provider
2. **Service URL**: HTTP endpoint of the Storage Provider's PDP service
3. **Record Keeper**: Ethereum address of the Storage Provider's contract

### Working Directory

PDPTool creates and uses several files in its working directory:
- `pdpservice.json`: Service authentication credentials
- Temporary files during upload process
- Proof generation outputs

## Command Reference

### Authentication Commands

#### `create-service-secret`

Creates authentication credentials for communicating with Storage Provider services.

```bash
pdptool create-service-secret
```

**Purpose**: Generates `pdpservice.json` file containing service authentication credentials.

**When to use**: 
- First-time setup with a Storage Provider
- When authentication credentials need to be regenerated

**Output**: Creates `pdpservice.json` in the current working directory.

### File Management Commands

#### `prepare-piece`

Prepares a file for upload by processing it into the required format.

```bash
pdptool prepare-piece FILE_PATH
```

**Parameters**:
- `FILE_PATH`: Path to the file to be prepared

**Purpose**: Processes the file into a format suitable for PDP storage and generates necessary metadata.

**Example**:
```bash
pdptool prepare-piece /path/to/myfile.txt
```

#### `upload-file`

Uploads a prepared file to the Storage Provider.

```bash
pdptool upload-file --service-url SERVICE_URL --service-name SERVICE_NAME FILE_PATH
```

**Parameters**:
- `--service-url`: HTTP endpoint of the Storage Provider service
- `--service-name`: Registered service name with the Storage Provider
- `FILE_PATH`: Path to the file to upload

**Purpose**: Transfers the file to the Storage Provider and returns content identifiers (CIDs).

**Example**:
```bash
pdptool upload-file --service-url https://yablu.net --service-name pdp-service-name /path/to/myfile.txt
```

### Proof Set Management Commands

#### `create-proof-set`

Creates a new proof set with the Storage Provider.

```bash
pdptool create-proof-set --service-url SERVICE_URL --service-name SERVICE_NAME --recordkeeper RECORD_KEEPER --extra-data EXTRA_DATA
```

**Parameters**:
- `--service-url`: Storage Provider service endpoint
- `--service-name`: Registered service name
- `--recordkeeper`: Ethereum address of the Storage Provider's record keeper contract
- `--extra-data`: Hex-encoded additional data (often payment information)

**Purpose**: Initializes a new proof set that can contain multiple file roots.

**Example**:
```bash
pdptool create-proof-set --service-url https://yablu.net --service-name pdp-service-name --recordkeeper 0xdbE4bEF3F313dAC36257b0621e4a3BC8Dc9679a1 --extra-data 0x1234...
```

#### `get-proof-set-create-status`

Checks the status of proof set creation.

```bash
pdptool get-proof-set-create-status --service-url SERVICE_URL --service-name SERVICE_NAME --tx-hash TX_HASH
```

**Parameters**:
- `--service-url`: Storage Provider service endpoint
- `--service-name`: Registered service name
- `--tx-hash`: Transaction hash from proof set creation

**Purpose**: Polls the Storage Provider to check if proof set creation has completed.

**Example**:
```bash
pdptool get-proof-set-create-status --service-url https://yablu.net --service-name pdp-service-name --tx-hash 0xabc123...
```

#### `get-proof-set`

Retrieves information about an existing proof set.

```bash
pdptool get-proof-set --service-url SERVICE_URL --service-name SERVICE_NAME PROOF_SET_ID
```

**Parameters**:
- `--service-url`: Storage Provider service endpoint
- `--service-name`: Registered service name
- `PROOF_SET_ID`: ID of the proof set to query

**Purpose**: Gets detailed information about a proof set, including contained roots and their IDs.

**Example**:
```bash
pdptool get-proof-set --service-url https://yablu.net --service-name pdp-service-name 123
```

### Root Management Commands

#### `add-roots`

Adds a file root to an existing proof set.

```bash
pdptool add-roots --service-url SERVICE_URL --service-name SERVICE_NAME --proof-set-id PROOF_SET_ID --root ROOT_CID
```

**Parameters**:
- `--service-url`: Storage Provider service endpoint
- `--service-name`: Registered service name
- `--proof-set-id`: ID of the target proof set
- `--root`: Content Identifier (CID) of the file root to add

**Purpose**: Associates an uploaded file with a proof set for PDP verification.

**Example**:
```bash
pdptool add-roots --service-url https://yablu.net --service-name pdp-service-name --proof-set-id 123 --root bafybeigdyrzt5sfp7udm7hu76uh7y26nf3efuylqabf3oclgtqy55fbzdi
```

#### `remove-roots`

Removes a file root from a proof set.

```bash
pdptool remove-roots --service-url SERVICE_URL --service-name SERVICE_NAME --proof-set-id PROOF_SET_ID --root-id ROOT_ID
```

**Parameters**:
- `--service-url`: Storage Provider service endpoint
- `--service-name`: Registered service name
- `--proof-set-id`: ID of the proof set
- `--root-id`: Numeric ID of the root to remove (not the CID)

**Purpose**: Removes a file from PDP verification within a proof set.

**Example**:
```bash
pdptool remove-roots --service-url https://yablu.net --service-name pdp-service-name --proof-set-id 123 --root-id 456
```

### Proof Generation Commands

#### `prove`

Generates proofs of data possession for submission to the blockchain.

```bash
pdptool prove --proof-set-id PROOF_SET_ID --verifier-address VERIFIER_ADDRESS --rpc-url RPC_URL
```

**Parameters**:
- `--proof-set-id`: ID of the proof set to generate proofs for
- `--verifier-address`: Ethereum address of the PDP verifier contract
- `--rpc-url`: RPC endpoint for blockchain interaction

**Purpose**: Creates cryptographic proofs that demonstrate continued possession of stored data.

**Example**:
```bash
pdptool prove --proof-set-id 123 --verifier-address 0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC --rpc-url https://calibration.filfox.info/rpc/v1
```

## Common Workflows

### Complete File Storage Workflow

1. **Setup Authentication**:
   ```bash
   pdptool create-service-secret
   ```

2. **Prepare File**:
   ```bash
   pdptool prepare-piece /path/to/file.txt
   ```

3. **Upload File**:
   ```bash
   pdptool upload-file --service-url https://provider.com --service-name my-service /path/to/file.txt
   ```

4. **Create Proof Set** (if needed):
   ```bash
   pdptool create-proof-set --service-url https://provider.com --service-name my-service --recordkeeper 0x123... --extra-data 0xabc...
   ```

5. **Add File to Proof Set**:
   ```bash
   pdptool add-roots --service-url https://provider.com --service-name my-service --proof-set-id 123 --root bafybeig...
   ```

6. **Generate Proofs** (periodically):
   ```bash
   pdptool prove --proof-set-id 123 --verifier-address 0x456... --rpc-url https://rpc.endpoint.com
   ```

### Proof Set Management Workflow

1. **Check Proof Set Status**:
   ```bash
   pdptool get-proof-set --service-url https://provider.com --service-name my-service 123
   ```

2. **Add More Files**:
   ```bash
   pdptool add-roots --service-url https://provider.com --service-name my-service --proof-set-id 123 --root bafybeig...
   ```

3. **Remove Files**:
   ```bash
   pdptool remove-roots --service-url https://provider.com --service-name my-service --proof-set-id 123 --root-id 456
   ```

## Error Handling and Troubleshooting

### Common Issues

**Service Secret Missing**:
```
Error: pdpservice.json not found
```
**Solution**: Run `pdptool create-service-secret` first.

**Service Not Found**:
```
Error: service not registered
```
**Solution**: Verify SERVICE_NAME and SERVICE_URL with your Storage Provider.

**File Not Found**:
```
Error: pdptool executable not found
```
**Solution**: Check PDPTOOL_PATH configuration and file permissions.

**Connection Issues**:
```
Error: failed to connect to service
```
**Solution**: Verify SERVICE_URL is accessible and Storage Provider service is running.

### Best Practices

1. **Working Directory**: Always run pdptool from a consistent working directory to maintain service credentials.

2. **Error Handling**: Check command exit codes and parse stderr for error messages.

3. **Retry Logic**: Implement retry logic for network-dependent operations like `add-roots` and `get-proof-set-create-status`.

4. **Credential Management**: Protect `pdpservice.json` file and regenerate if compromised.

5. **Monitoring**: Regularly check proof set status and generate proofs as required by your SLA.

## Integration with Applications

PDPTool is designed to be integrated into larger applications. See the [Hot Vault Demo](../../examples/hot-vault.md) for a complete example of pdptool integration in a web application.

For Storage Provider configuration in applications, see the [MVP Configuration Guide](../../MVP.md).

## Next Steps

- [Creating a Proof Set](../guides/creating-proof-set.md)
- [Submitting Proofs](../guides/submitting-proofs.md)
- [Hot Vault Demo](../../examples/hot-vault.md)
- [MVP Configuration](../../MVP.md)
</file>

<file path="docs/sdk/sdk-monitoring.md">
# Step 4: Monitor & Verify Storage

This is the fourth step in your Developer Path - learn how to monitor your stored files, verify proofs, and track payments in real-time.

## Prerequisites

- ‚úÖ **Completed [Step 3: Complete Workflow](sdk-workflow.md)** - You've stored and retrieved files
- ‚úÖ **Understanding of CommP** - Cryptographic file fingerprints

## üéØ What You'll Learn

- üìä **Real-time monitoring** of storage status
- üîç **Proof verification** for data integrity
- üí∞ **Payment tracking** and settlement history
- üö® **Error detection** and recovery strategies

## 1. Storage Monitoring Dashboard

Create `monitoring-dashboard.js`:

```javascript
// monitoring-dashboard.js
import { Synapse } from 'synapse-sdk'
import 'dotenv/config'

class StorageMonitor {
  constructor() {
    this.synapse = new Synapse({
      privateKey: process.env.PRIVATE_KEY,
      withCDN: true,
    })
    this.storage = null
    this.storedFiles = new Map() // Track files by CommP
  }
  
  async initialize() {
    console.log('üîß Initializing Storage Monitor...')
    this.storage = await this.synapse.createStorage()
    console.log(`‚úÖ Connected to storage service: ${this.storage.storageProvider}`)
    return this
  }
  
  async storeAndTrack(data, filename) {
    console.log(`\nüì§ Storing: ${filename}`)
    console.log('‚îÄ'.repeat(50))
    
    const uploadTask = this.storage.upload(data)
    
    // Track progress
    const commp = await uploadTask.commp()
    console.log(`üîê CommP: ${commp}`)
    
    const sp = await uploadTask.store()
    console.log(`üì¶ Stored with: ${sp}`)
    
    const txHash = await uploadTask.done()
    console.log(`‚õìÔ∏è  Transaction: ${txHash}`)
    
    // Add to tracking
    this.storedFiles.set(commp.toString(), {
      filename,
      commp,
      storageProvider: sp,
      txHash,
      uploadTime: new Date(),
      size: data.length,
      verified: false
    })
    
    console.log(`‚úÖ ${filename} stored and tracked`)
    return commp
  }
  
  async verifyFile(commp) {
    console.log(`\nüîç Verifying file: ${commp}`)
    console.log('‚îÄ'.repeat(50))
    
    const fileInfo = this.storedFiles.get(commp.toString())
    if (!fileInfo) {
      console.log('‚ùå File not found in tracking system')
      return false
    }
    
    try {
      // Attempt to download and verify
      console.log('üì• Downloading for verification...')
      const retrievedData = await this.storage.download(commp, {
        noVerify: false, // Enable verification
        withCDN: true
      })
      
      // Check size matches
      const sizeMatch = retrievedData.length === fileInfo.size
      console.log(`üìè Size check: ${sizeMatch ? '‚úÖ' : '‚ùå'} (${retrievedData.length}/${fileInfo.size} bytes)`)
      
      // Update tracking
      fileInfo.verified = sizeMatch
      fileInfo.lastVerified = new Date()
      
      console.log(`‚úÖ Verification complete: ${sizeMatch ? 'PASSED' : 'FAILED'}`)
      return sizeMatch
      
    } catch (error) {
      console.log(`‚ùå Verification failed: ${error.message}`)
      fileInfo.verified = false
      fileInfo.lastError = error.message
      return false
    }
  }
  
  async checkBalance() {
    console.log('\nüí∞ Balance Check')
    console.log('‚îÄ'.repeat(50))
    
    const balance = await this.synapse.balance()
    console.log(`Current balance: ${balance} USDFC`)
    
    if (balance < 5) {
      console.log('‚ö†Ô∏è  Low balance warning! Consider depositing more USDFC')
    }
    
    return balance
  }
  
  async settleAllPayments() {
    console.log('\nüí∏ Payment Settlement')
    console.log('‚îÄ'.repeat(50))
    
    try {
      const settlement = await this.storage.settlePayments()
      console.log(`‚úÖ Settlement successful:`)
      console.log(`   Amount: ${settlement.settledAmount} USDFC`)
      console.log(`   Epoch: ${settlement.epoch}`)
      return settlement
    } catch (error) {
      console.log(`‚ùå Settlement failed: ${error.message}`)
      return null
    }
  }
  
  displayDashboard() {
    console.log('\nüìä Storage Dashboard')
    console.log('‚ïê'.repeat(60))
    
    if (this.storedFiles.size === 0) {
      console.log('No files currently tracked')
      return
    }
    
    console.log(`Total files tracked: ${this.storedFiles.size}`)
    console.log('')
    
    for (const [commp, fileInfo] of this.storedFiles) {
      const status = fileInfo.verified ? '‚úÖ VERIFIED' : '‚ùì UNVERIFIED'
      const age = Math.round((Date.now() - fileInfo.uploadTime) / 1000 / 60) // minutes
      
      console.log(`üìÅ ${fileInfo.filename}`)
      console.log(`   CommP: ${commp.substring(0, 20)}...`)
      console.log(`   Status: ${status}`)
      console.log(`   Size: ${fileInfo.size} bytes`)
      console.log(`   Age: ${age} minutes`)
      console.log(`   Provider: ${fileInfo.storageProvider}`)
      if (fileInfo.lastError) {
        console.log(`   ‚ö†Ô∏è  Last Error: ${fileInfo.lastError}`)
      }
      console.log('')
    }
  }
  
  async runMonitoringCycle() {
    console.log('\nüîÑ Running Monitoring Cycle')
    console.log('‚ïê'.repeat(60))
    
    // Check balance
    await this.checkBalance()
    
    // Verify all tracked files
    for (const [commp, fileInfo] of this.storedFiles) {
      await this.verifyFile(commp)
    }
    
    // Settle payments
    await this.settleAllPayments()
    
    // Display dashboard
    this.displayDashboard()
  }
}

// Demo usage
async function monitoringDemo() {
  console.log('üöÄ Storage Monitoring Demo')
  console.log('‚ïê'.repeat(60))
  
  const monitor = await new StorageMonitor().initialize()
  
  // Store some test files
  const file1 = new TextEncoder().encode('Hello from file 1!')
  const file2 = new TextEncoder().encode('This is file 2 with more content for testing.')
  
  const commp1 = await monitor.storeAndTrack(file1, 'test-file-1.txt')
  const commp2 = await monitor.storeAndTrack(file2, 'test-file-2.txt')
  
  // Run monitoring cycle
  await monitor.runMonitoringCycle()
  
  console.log('\nüéâ Monitoring demo complete!')
  console.log('\nNext steps:')
  console.log('- Run monitoring cycles periodically')
  console.log('- Set up alerts for verification failures')
  console.log('- Monitor balance and auto-deposit if needed')
}

monitoringDemo().catch(console.error)
```

## 2. Run the Monitoring Demo

```bash
node monitoring-dashboard.js
```

**Expected Output:**
```
üöÄ Storage Monitoring Demo
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üîß Initializing Storage Monitor...
‚úÖ Connected to storage service: f01234

üì§ Storing: test-file-1.txt
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üîê CommP: baga6ea4seaqjtovkwk4myyzj56eztkh5pzsk5upksan6f5outesy62bsvl4dsha
üì¶ Stored with: f01234
‚õìÔ∏è  Transaction: 0x1234...abcd
‚úÖ test-file-1.txt stored and tracked

üì§ Storing: test-file-2.txt
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üîê CommP: baga6ea4seaqjtovkwk4myyzj56eztkh5pzsk5upksan6f5outesy62bsvl4dsha
üì¶ Stored with: f01234
‚õìÔ∏è  Transaction: 0x5678...efgh
‚úÖ test-file-2.txt stored and tracked

üîÑ Running Monitoring Cycle
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üí∞ Balance Check
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Current balance: 100 USDFC

üîç Verifying file: baga6ea4seaqjtovkwk4myyzj56eztkh5pzsk5upksan6f5outesy62bsvl4dsha
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üì• Downloading for verification...
üìè Size check: ‚úÖ (18/18 bytes)
‚úÖ Verification complete: PASSED

üîç Verifying file: baga6ea4seaqjtovkwk4myyzj56eztkh5pzsk5upksan6f5outesy62bsvl4dsha
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üì• Downloading for verification...
üìè Size check: ‚úÖ (42/42 bytes)
‚úÖ Verification complete: PASSED

üí∏ Payment Settlement
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚úÖ Settlement successful:
   Amount: 0.05 USDFC
   Epoch: 12345

üìä Storage Dashboard
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Total files tracked: 2

üìÅ test-file-1.txt
   CommP: baga6ea4seaqjtovkwk4...
   Status: ‚úÖ VERIFIED
   Size: 18 bytes
   Age: 1 minutes
   Provider: f01234

üìÅ test-file-2.txt
   CommP: baga6ea4seaqjtovkwk4...
   Status: ‚úÖ VERIFIED
   Size: 42 bytes
   Age: 0 minutes
   Provider: f01234

üéâ Monitoring demo complete!

Next steps:
- Run monitoring cycles periodically
- Set up alerts for verification failures
- Monitor balance and auto-deposit if needed
```

## 3. Production Monitoring Patterns

### üîÑ **Periodic Monitoring**
```javascript
// Run monitoring every 10 minutes
setInterval(async () => {
  await monitor.runMonitoringCycle()
}, 10 * 60 * 1000)
```

### üö® **Alert System**
```javascript
async function checkAndAlert() {
  const balance = await synapse.balance()
  
  if (balance < 5) {
    console.log('üö® ALERT: Low balance!')
    // Send notification, auto-deposit, etc.
  }
  
  // Check for verification failures
  for (const [commp, fileInfo] of storedFiles) {
    if (!fileInfo.verified) {
      console.log(`üö® ALERT: File verification failed: ${fileInfo.filename}`)
      // Handle verification failure
    }
  }
}
```

### üìà **Analytics Tracking**
```javascript
function generateReport() {
  const totalFiles = storedFiles.size
  const verifiedFiles = Array.from(storedFiles.values()).filter(f => f.verified).length
  const totalSize = Array.from(storedFiles.values()).reduce((sum, f) => sum + f.size, 0)
  
  console.log(`üìà Storage Report:`)
  console.log(`   Files: ${verifiedFiles}/${totalFiles} verified`)
  console.log(`   Total size: ${totalSize} bytes`)
  console.log(`   Success rate: ${(verifiedFiles/totalFiles*100).toFixed(1)}%`)
}
```

## 4. Key Monitoring Concepts

### üîê **CommP Verification**
- **What**: Cryptographic proof your file hasn't changed
- **How**: SDK downloads and verifies against original CommP
- **Why**: Ensures data integrity and provider honesty

### üí∞ **Payment Tracking**
- **Escrow**: Funds held during storage period
- **Settlement**: Automatic payment to provider after proof
- **Balance**: Monitor to ensure continuous service

### üìä **Storage Health**
- **Verification Rate**: % of files that pass integrity checks
- **Response Time**: How quickly files can be retrieved
- **Provider Reliability**: Track which providers perform best

## 5. Error Handling Strategies

### ‚ùå **Verification Failures**
```javascript
if (!verified) {
  // 1. Retry verification
  // 2. Try different retrieval method
  // 3. Contact storage provider
  // 4. Consider re-uploading file
}
```

### üí∏ **Payment Issues**
```javascript
if (balance < threshold) {
  // 1. Auto-deposit from external wallet
  // 2. Alert administrators
  // 3. Pause new uploads
}
```

### üîå **Network Issues**
```javascript
try {
  await storage.download(commp)
} catch (error) {
  if (error.message.includes('network')) {
    // Retry with exponential backoff
    await retryWithBackoff(() => storage.download(commp))
  }
}
```

## 6. What's Next?

You've mastered the core PDP-Payments workflow! For production deployment, continue to **[Step 5: Production Deployment](sdk-production.md)** to learn:

- üè≠ **Production configuration** and best practices
- üîí **Security considerations** for private keys and payments
- üìà **Scaling strategies** for high-volume applications
- üîß **Integration patterns** with existing systems

## Troubleshooting

### Verification Always Fails
- Check network connectivity
- Verify storage provider is online
- Try with `noVerify: true` to isolate issue

### Balance Decreases Unexpectedly
- Check settlement history
- Monitor for unauthorized transactions
- Verify private key security

### Files Become Unretrievable
- Check storage provider status
- Verify CommP is correct
- Consider provider redundancy

Ready for production? **[Continue to Step 5 ‚Üí](sdk-production.md)**
</file>

<file path="docs/sdk/sdk-production.md">
# Step 5: Production Deployment

This is the final step in your Developer Path - learn how to deploy PDP-Payments applications to production with security, scalability, and reliability.

## Prerequisites

- ‚úÖ **Completed [Step 4: Monitor & Verify](sdk-monitoring.md)** - You understand monitoring and verification
- ‚úÖ **Production environment** ready for deployment

## üéØ Production Readiness Checklist

### üîí **Security**
- [ ] Private keys stored securely (not in code)
- [ ] Environment variables properly configured
- [ ] Network access restricted appropriately
- [ ] Monitoring and alerting in place

### üìà **Scalability**
- [ ] Connection pooling implemented
- [ ] Rate limiting configured
- [ ] Error handling and retries
- [ ] Load balancing for high availability

### üí∞ **Financial Management**
- [ ] USDFC balance monitoring
- [ ] Automatic top-up strategies
- [ ] Payment settlement tracking
- [ ] Cost optimization

## 1. Secure Configuration

### Environment Variables
Create a production `.env` file:

```bash
# .env.production
# Never commit this file!

# Wallet Configuration
PRIVATE_KEY=your_production_private_key_here
WALLET_ADDRESS=0x1234567890123456789012345678901234567890

# Network Configuration
RPC_URL=https://api.calibration.node.glif.io/rpc/v1
NETWORK_ID=314159

# SDK Configuration
SYNAPSE_WITH_CDN=true
SYNAPSE_SERVICE_CONTRACT=0x...
SYNAPSE_SUBGRAPH_API=https://...

# Monitoring
BALANCE_THRESHOLD=50
ALERT_WEBHOOK_URL=https://your-monitoring-service.com/webhook
LOG_LEVEL=info

# Rate Limiting
MAX_UPLOADS_PER_MINUTE=10
MAX_CONCURRENT_OPERATIONS=5
```

### Secure Key Management
```javascript
// production-config.js
import { readFileSync } from 'fs'

class ProductionConfig {
  constructor() {
    this.validateEnvironment()
  }
  
  validateEnvironment() {
    const required = [
      'PRIVATE_KEY',
      'WALLET_ADDRESS', 
      'RPC_URL',
      'BALANCE_THRESHOLD'
    ]
    
    for (const key of required) {
      if (!process.env[key]) {
        throw new Error(`Missing required environment variable: ${key}`)
      }
    }
  }
  
  getSynapseConfig() {
    return {
      privateKey: process.env.PRIVATE_KEY,
      withCDN: process.env.SYNAPSE_WITH_CDN === 'true',
      rpcAPI: process.env.RPC_URL,
      serviceContract: process.env.SYNAPSE_SERVICE_CONTRACT,
      subgraphAPI: process.env.SYNAPSE_SUBGRAPH_API,
    }
  }
  
  getMonitoringConfig() {
    return {
      balanceThreshold: parseFloat(process.env.BALANCE_THRESHOLD),
      alertWebhook: process.env.ALERT_WEBHOOK_URL,
      logLevel: process.env.LOG_LEVEL || 'info',
    }
  }
  
  getRateLimits() {
    return {
      maxUploadsPerMinute: parseInt(process.env.MAX_UPLOADS_PER_MINUTE) || 10,
      maxConcurrentOps: parseInt(process.env.MAX_CONCURRENT_OPERATIONS) || 5,
    }
  }
}

export default new ProductionConfig()
```

## 2. Production-Ready SDK Wrapper

```javascript
// production-synapse.js
import { Synapse } from 'synapse-sdk'
import config from './production-config.js'

class ProductionSynapse {
  constructor() {
    this.synapse = new Synapse(config.getSynapseConfig())
    this.storage = null
    this.rateLimiter = new Map() // Simple rate limiting
    this.operationQueue = []
    this.activeOperations = 0
    this.maxConcurrent = config.getRateLimits().maxConcurrentOps
  }
  
  async initialize() {
    console.log('üè≠ Initializing Production Synapse...')
    
    // Test connection
    await this.healthCheck()
    
    // Initialize storage service
    this.storage = await this.synapse.createStorage()
    
    // Start monitoring
    this.startMonitoring()
    
    console.log('‚úÖ Production Synapse ready')
    return this
  }
  
  async healthCheck() {
    try {
      const balance = await this.synapse.balance()
      console.log(`üí∞ Current balance: ${balance} USDFC`)
      
      if (balance < config.getMonitoringConfig().balanceThreshold) {
        await this.alertLowBalance(balance)
      }
      
      return { status: 'healthy', balance }
    } catch (error) {
      console.error('‚ùå Health check failed:', error.message)
      throw new Error(`Health check failed: ${error.message}`)
    }
  }
  
  async storeFileWithRetry(data, options = {}) {
    const maxRetries = options.maxRetries || 3
    const retryDelay = options.retryDelay || 1000
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        // Check rate limits
        await this.checkRateLimit()
        
        // Queue operation if at capacity
        await this.queueOperation()
        
        console.log(`üì§ Upload attempt ${attempt}/${maxRetries}`)
        
        const uploadTask = this.storage.upload(data)
        const commp = await uploadTask.commp()
        const sp = await uploadTask.store()
        const txHash = await uploadTask.done()
        
        this.completeOperation()
        
        return { commp, storageProvider: sp, txHash }
        
      } catch (error) {
        console.error(`‚ùå Upload attempt ${attempt} failed:`, error.message)
        
        if (attempt === maxRetries) {
          this.completeOperation()
          throw error
        }
        
        // Exponential backoff
        await new Promise(resolve => setTimeout(resolve, retryDelay * attempt))
      }
    }
  }
  
  async checkRateLimit() {
    const now = Date.now()
    const windowStart = now - 60000 // 1 minute window
    const limits = config.getRateLimits()
    
    // Clean old entries
    for (const [timestamp] of this.rateLimiter) {
      if (timestamp < windowStart) {
        this.rateLimiter.delete(timestamp)
      }
    }
    
    if (this.rateLimiter.size >= limits.maxUploadsPerMinute) {
      throw new Error('Rate limit exceeded. Please try again later.')
    }
    
    this.rateLimiter.set(now, true)
  }
  
  async queueOperation() {
    return new Promise((resolve) => {
      if (this.activeOperations < this.maxConcurrent) {
        this.activeOperations++
        resolve()
      } else {
        this.operationQueue.push(resolve)
      }
    })
  }
  
  completeOperation() {
    this.activeOperations--
    if (this.operationQueue.length > 0) {
      const next = this.operationQueue.shift()
      this.activeOperations++
      next()
    }
  }
  
  startMonitoring() {
    // Monitor balance every 5 minutes
    setInterval(async () => {
      try {
        await this.healthCheck()
      } catch (error) {
        console.error('üö® Monitoring error:', error.message)
        await this.alertSystemError(error)
      }
    }, 5 * 60 * 1000)
    
    // Settle payments every hour
    setInterval(async () => {
      try {
        const settlement = await this.storage.settlePayments()
        console.log(`üí∏ Auto-settlement: ${settlement.settledAmount} USDFC`)
      } catch (error) {
        console.error('‚ùå Settlement error:', error.message)
      }
    }, 60 * 60 * 1000)
  }
  
  async alertLowBalance(balance) {
    const message = `üö® Low balance alert: ${balance} USDFC remaining`
    console.warn(message)
    
    if (config.getMonitoringConfig().alertWebhook) {
      try {
        await fetch(config.getMonitoringConfig().alertWebhook, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            alert: 'low_balance',
            balance,
            threshold: config.getMonitoringConfig().balanceThreshold,
            timestamp: new Date().toISOString()
          })
        })
      } catch (error) {
        console.error('Failed to send alert:', error.message)
      }
    }
  }
  
  async alertSystemError(error) {
    const message = `üö® System error: ${error.message}`
    console.error(message)
    
    if (config.getMonitoringConfig().alertWebhook) {
      try {
        await fetch(config.getMonitoringConfig().alertWebhook, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            alert: 'system_error',
            error: error.message,
            stack: error.stack,
            timestamp: new Date().toISOString()
          })
        })
      } catch (alertError) {
        console.error('Failed to send error alert:', alertError.message)
      }
    }
  }
}

export default ProductionSynapse
```

## 3. React + Next.js Integration

### Create Next.js App with PDP-Payments

```bash
# Create Next.js app (recommended approach)
npx create-next-app@latest my-pdp-app --typescript --tailwind --eslint --app
cd my-pdp-app

# Install Synapse SDK
npm install synapse-sdk

# Install additional dependencies for file handling
npm install react-dropzone
```

### React Hook for Synapse SDK

```typescript
// hooks/useSynapse.ts
import { useState, useEffect } from 'react'
import { Synapse } from 'synapse-sdk'

interface SynapseState {
  synapse: Synapse | null
  storage: any | null
  balance: number
  loading: boolean
  error: string | null
}

export function useSynapse(privateKey: string) {
  const [state, setState] = useState<SynapseState>({
    synapse: null,
    storage: null,
    balance: 0,
    loading: true,
    error: null
  })

  useEffect(() => {
    async function initializeSynapse() {
      try {
        const synapse = new Synapse({
          privateKey,
          withCDN: true,
        })

        const balance = await synapse.balance()
        const storage = await synapse.createStorage()

        setState({
          synapse,
          storage,
          balance,
          loading: false,
          error: null
        })
      } catch (error) {
        setState(prev => ({
          ...prev,
          loading: false,
          error: error instanceof Error ? error.message : 'Unknown error'
        }))
      }
    }

    if (privateKey) {
      initializeSynapse()
    }
  }, [privateKey])

  return state
}
```

### File Upload Component

```typescript
// components/FileUploader.tsx
'use client'

import { useState } from 'react'
import { useDropzone } from 'react-dropzone'
import { useSynapse } from '@/hooks/useSynapse'

interface UploadedFile {
  commp: string
  filename: string
  size: number
  txHash: string
  uploadTime: Date
}

export default function FileUploader() {
  const [privateKey, setPrivateKey] = useState('')
  const [uploadedFiles, setUploadedFiles] = useState<UploadedFile[]>([])
  const [uploading, setUploading] = useState(false)
  const [uploadProgress, setUploadProgress] = useState('')

  const { synapse, storage, balance, loading, error } = useSynapse(privateKey)

  const onDrop = async (acceptedFiles: File[]) => {
    if (!storage) return

    setUploading(true)

    for (const file of acceptedFiles) {
      try {
        setUploadProgress(`Uploading ${file.name}...`)

        // Convert file to Uint8Array
        const arrayBuffer = await file.arrayBuffer()
        const data = new Uint8Array(arrayBuffer)

        // Upload with progress tracking
        const uploadTask = storage.upload(data)

        setUploadProgress(`Generating CommP for ${file.name}...`)
        const commp = await uploadTask.commp()

        setUploadProgress(`Storing ${file.name} with provider...`)
        const sp = await uploadTask.store()

        setUploadProgress(`Committing ${file.name} to blockchain...`)
        const txHash = await uploadTask.done()

        // Add to uploaded files list
        const uploadedFile: UploadedFile = {
          commp: commp.toString(),
          filename: file.name,
          size: file.size,
          txHash,
          uploadTime: new Date()
        }

        setUploadedFiles(prev => [...prev, uploadedFile])

      } catch (error) {
        console.error(`Upload failed for ${file.name}:`, error)
        alert(`Upload failed for ${file.name}: ${error}`)
      }
    }

    setUploading(false)
    setUploadProgress('')
  }

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    disabled: !storage || uploading
  })

  const downloadFile = async (commp: string, filename: string) => {
    if (!storage) return

    try {
      const data = await storage.download(commp, {
        noVerify: false,
        withCDN: true
      })

      // Create download link
      const blob = new Blob([data])
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = filename
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)
      URL.revokeObjectURL(url)

    } catch (error) {
      console.error('Download failed:', error)
      alert(`Download failed: ${error}`)
    }
  }

  if (loading) {
    return <div className="p-8">Loading Synapse SDK...</div>
  }

  if (error) {
    return <div className="p-8 text-red-600">Error: {error}</div>
  }

  return (
    <div className="max-w-4xl mx-auto p-8">
      <h1 className="text-3xl font-bold mb-8">PDP-Payments File Storage</h1>

      {/* Private Key Input */}
      {!synapse && (
        <div className="mb-8">
          <label className="block text-sm font-medium mb-2">
            Private Key (without 0x prefix):
          </label>
          <input
            type="password"
            value={privateKey}
            onChange={(e) => setPrivateKey(e.target.value)}
            className="w-full p-3 border rounded-lg"
            placeholder="Enter your private key..."
          />
        </div>
      )}

      {synapse && (
        <>
          {/* Balance Display */}
          <div className="mb-8 p-4 bg-blue-50 rounded-lg">
            <h2 className="text-lg font-semibold">Account Status</h2>
            <p>Balance: {balance} USDFC</p>
            {balance < 10 && (
              <p className="text-orange-600">‚ö†Ô∏è Low balance - consider depositing more USDFC</p>
            )}
          </div>

          {/* File Upload Area */}
          <div
            {...getRootProps()}
            className={`border-2 border-dashed rounded-lg p-8 text-center cursor-pointer transition-colors ${
              isDragActive ? 'border-blue-500 bg-blue-50' : 'border-gray-300'
            } ${uploading ? 'opacity-50 cursor-not-allowed' : ''}`}
          >
            <input {...getInputProps()} />
            {uploading ? (
              <div>
                <p className="text-lg">Uploading...</p>
                <p className="text-sm text-gray-600">{uploadProgress}</p>
              </div>
            ) : isDragActive ? (
              <p className="text-lg">Drop files here...</p>
            ) : (
              <div>
                <p className="text-lg">Drag & drop files here, or click to select</p>
                <p className="text-sm text-gray-600">Files will be stored with PDP verification and automatic payments</p>
              </div>
            )}
          </div>

          {/* Uploaded Files List */}
          {uploadedFiles.length > 0 && (
            <div className="mt-8">
              <h2 className="text-xl font-semibold mb-4">Uploaded Files</h2>
              <div className="space-y-4">
                {uploadedFiles.map((file, index) => (
                  <div key={index} className="border rounded-lg p-4">
                    <div className="flex justify-between items-start">
                      <div>
                        <h3 className="font-medium">{file.filename}</h3>
                        <p className="text-sm text-gray-600">Size: {file.size} bytes</p>
                        <p className="text-sm text-gray-600">
                          CommP: {file.commp.substring(0, 20)}...
                        </p>
                        <p className="text-sm text-gray-600">
                          Uploaded: {file.uploadTime.toLocaleString()}
                        </p>
                      </div>
                      <button
                        onClick={() => downloadFile(file.commp, file.filename)}
                        className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                      >
                        Download
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}
        </>
      )}
    </div>
  )
}
```

## 4. Vercel Deployment (Recommended)

### Main App Page

```typescript
// app/page.tsx
import FileUploader from '@/components/FileUploader'

export default function Home() {
  return (
    <main className="min-h-screen bg-gray-50">
      <FileUploader />
    </main>
  )
}
```

### Environment Variables Setup

```bash
# .env.local (for development)
NEXT_PUBLIC_PRIVATE_KEY=your_private_key_here

# For production, set in Vercel dashboard:
# Settings > Environment Variables
```

### Optional: API Route for Server-Side Operations

```typescript
// app/api/balance/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { Synapse } from 'synapse-sdk'

export async function GET(request: NextRequest) {
  try {
    const privateKey = process.env.PRIVATE_KEY
    if (!privateKey) {
      return NextResponse.json({ error: 'Private key not configured' }, { status: 500 })
    }

    const synapse = new Synapse({ privateKey, withCDN: true })
    const balance = await synapse.balance()

    return NextResponse.json({ balance })
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch balance' },
      { status: 500 }
    )
  }
}
```

### Deploy to Vercel

```bash
# Install Vercel CLI
npm i -g vercel

# Deploy (first time)
vercel

# Follow prompts:
# - Link to existing project? No
# - Project name: my-pdp-app
# - Directory: ./
# - Override settings? No

# Set environment variables
vercel env add PRIVATE_KEY

# Deploy to production
vercel --prod
```

### Vercel Configuration

```json
// vercel.json (optional)
{
  "framework": "nextjs",
  "buildCommand": "npm run build",
  "devCommand": "npm run dev",
  "installCommand": "npm install",
  "env": {
    "NEXT_PUBLIC_APP_NAME": "PDP-Payments Storage"
  }
}
```

### Automatic Deployments

```bash
# Connect to GitHub for automatic deployments
vercel --prod

# Every push to main branch will auto-deploy
# Pull requests get preview deployments
```

### Quick Deployment Summary

```bash
# üöÄ Deploy PDP-Payments app in 2 minutes:

# 1. Create Next.js app
npx create-next-app@latest my-pdp-app --typescript --tailwind --app
cd my-pdp-app

# 2. Install dependencies
npm install synapse-sdk react-dropzone

# 3. Add components (copy from examples above)
# 4. Set environment variables
# 5. Deploy to Vercel
vercel --prod

# ‚úÖ Your PDP-Payments app is live!
```

## 5. Monitoring & Observability

### Logging
```javascript
import winston from 'winston'

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' }),
    new winston.transports.Console({
      format: winston.format.simple()
    })
  ]
})

// Usage
logger.info('File uploaded', { commp, size, storageProvider })
logger.error('Upload failed', { error: error.message, stack: error.stack })
```

### Metrics Collection
```javascript
// Simple metrics
class Metrics {
  constructor() {
    this.counters = new Map()
    this.gauges = new Map()
  }
  
  increment(name, value = 1) {
    this.counters.set(name, (this.counters.get(name) || 0) + value)
  }
  
  gauge(name, value) {
    this.gauges.set(name, value)
  }
  
  getMetrics() {
    return {
      counters: Object.fromEntries(this.counters),
      gauges: Object.fromEntries(this.gauges),
      timestamp: new Date().toISOString()
    }
  }
}

const metrics = new Metrics()

// Track uploads
metrics.increment('uploads.total')
metrics.increment('uploads.success')
metrics.gauge('balance.current', balance)
```

## 6. Best Practices Summary

### üîí **Security**
- ‚úÖ Never hardcode private keys in client code
- ‚úÖ Use Vercel environment variables for sensitive data
- ‚úÖ Implement proper error handling in React components
- ‚úÖ Consider server-side operations for sensitive actions

### üìà **Performance**
- ‚úÖ Use React hooks for state management
- ‚úÖ Implement loading states and progress indicators
- ‚úÖ Add retry logic with user feedback
- ‚úÖ Optimize bundle size with Next.js

### üîß **Reliability**
- ‚úÖ Graceful error handling with user-friendly messages
- ‚úÖ Automatic balance monitoring in UI
- ‚úÖ File upload progress tracking
- ‚úÖ Vercel's built-in reliability and CDN

### üí∞ **Cost Management**
- ‚úÖ Display balance warnings to users
- ‚úÖ Track upload costs in UI
- ‚úÖ Implement usage quotas per user
- ‚úÖ Monitor Vercel usage and costs

### üöÄ **Modern Development**
- ‚úÖ TypeScript for type safety
- ‚úÖ Tailwind CSS for rapid styling
- ‚úÖ React hooks for clean state management
- ‚úÖ Next.js App Router for modern patterns
- ‚úÖ Vercel for zero-config deployment

## üéâ Congratulations!

You've completed the **Developer Path** for PDP-Payments! You now know how to:

- ‚úÖ **Set up** wallets and tokens
- ‚úÖ **Use the SDK** for rapid development
- ‚úÖ **Implement** complete storage + payment workflows
- ‚úÖ **Monitor** storage and verify proofs
- ‚úÖ **Deploy** to production securely

## What's Next?

### üöÄ **Build Your Application**
- Integrate PDP-Payments into your existing systems
- Customize the workflow for your specific needs
- Scale to handle your user base

### ü§ñ **Advanced Usage**
- Explore the [AI Agent Path](setup-detailed.md) for direct contract control
- Implement custom storage provider selection
- Build advanced monitoring and analytics

### üåü **Join the Community**
- Share your implementation experiences
- Contribute to SDK improvements
- Help other developers get started

**Happy building with PDP-Payments!** üéØ
</file>

<file path="docs/sdk/sdk-quickstart.md">
# Step 2: Quick SDK Setup

This is the second step in your Developer Path to success with PDP-Payments. You'll install and initialize the Synapse SDK for rapid development.

## Prerequisites

- ‚úÖ **Completed [Step 1: Setup Wallet & USDFC](setup.md)** - You have MetaMask with testnet tokens
- ‚úÖ **Node.js** (v16 or later) installed
- ‚úÖ **Basic JavaScript/TypeScript** knowledge

## 1. Create Your Project

Start with a fresh project directory:

```bash
mkdir my-pdp-app
cd my-pdp-app
npm init -y
```

## 2. Install Synapse SDK

```bash
npm install synapse-sdk
```

**What you get:**
- üéØ **Simple API**: Store files in ~5 lines of code
- üí∞ **Integrated Payments**: Automatic USDFC handling
- üîç **PDP Verification**: Built-in storage proofs
- üì¶ **TypeScript Support**: Full type safety

## 3. Environment Setup

Create a `.env` file with your private key:

```bash
# .env
PRIVATE_KEY=your_private_key_here_without_0x_prefix
```

**üîê Get Your Private Key:**
1. Open MetaMask ‚Üí Account Details ‚Üí Export Private Key
2. Enter password ‚Üí Copy key (remove `0x` prefix)
3. **Never commit `.env` to version control!**

## 4. Your First SDK Script

Create `test-sdk.js`:

```javascript
// test-sdk.js
import { Synapse } from 'synapse-sdk'
import 'dotenv/config'

async function testSDK() {
  console.log('üöÄ Testing Synapse SDK...')
  
  // Initialize SDK
  const synapse = new Synapse({
    privateKey: process.env.PRIVATE_KEY,
    withCDN: true, // Enable faster retrievals
    // SDK automatically uses Calibration testnet
  })
  
  // Check balance
  console.log('üí∞ Checking balance...')
  const balance = await synapse.balance()
  console.log(`Current balance: ${balance} USDFC`)
  
  // Create storage service
  console.log('üì¶ Creating storage service...')
  const storage = await synapse.createStorage()
  console.log(`Storage service ready!`)
  console.log(`- Proof Set ID: ${storage.proofSetId}`)
  console.log(`- Storage Provider: ${storage.storageProvider}`)
  
  console.log('‚úÖ SDK setup successful!')
}

testSDK().catch(console.error)
```

## 5. Test Your Setup

```bash
node test-sdk.js
```

**Expected Output:**
```
üöÄ Testing Synapse SDK...
üí∞ Checking balance...
[Mock] Checking balance...
Current balance: 100 USDFC
üì¶ Creating storage service...
[Mock] Creating storage service...
[Mock] Storage service created with proofSetId: ps_abc123, SP: f01234
Storage service ready!
- Proof Set ID: ps_abc123
- Storage Provider: f01234
‚úÖ SDK setup successful!
```

> **üìù Note**: You're seeing `[Mock]` messages because the SDK is currently in mock mode for development. The API patterns are real and will work with the production implementation.

## 6. SDK vs Raw Contracts

**With Synapse SDK (What you just did):**
```javascript
// 5 lines to get started
const synapse = new Synapse({ privateKey })
const balance = await synapse.balance()
const storage = await synapse.createStorage()
```

**Without SDK (Raw contracts):**
```javascript
// 50+ lines for the same functionality
const provider = new ethers.JsonRpcProvider(rpcUrl)
const wallet = new ethers.Wallet(privateKey, provider)
const pdpContract = new ethers.Contract(pdpAddress, pdpAbi, wallet)
const paymentsContract = new ethers.Contract(paymentsAddress, paymentsAbi, wallet)
// ... 40+ more lines of setup and coordination
```

**üí° The SDK abstracts away:**
- ‚ùå Contract address management
- ‚ùå ABI handling
- ‚ùå Network configuration
- ‚ùå Payment coordination complexity
- ‚ùå Error handling boilerplate

## 7. What's Next?

You're ready for **[Step 3: Complete Workflow](sdk-workflow.md)** where you'll:
- üí∞ Manage USDFC deposits and withdrawals
- üìÅ Store your first file with automatic payment escrow
- üîç Monitor storage proofs
- üí∏ Settle payments with storage providers
- üì• Retrieve your stored files

## Troubleshooting

### SDK Import Issues
```bash
# If you get import errors, try:
npm install --save-dev @types/node

# Or use CommonJS:
const { Synapse } = require('synapse-sdk')
```

### Private Key Issues
- ‚úÖ Remove `0x` prefix from private key
- ‚úÖ Ensure `.env` file is in project root
- ‚úÖ Check `.env` is not committed to git

### Balance Shows 0
- The mock SDK starts with 100 USDFC balance
- If you see 0, check your private key setup
- Real implementation will check actual on-chain balance

## Next Steps

Continue to **[Step 3: Complete Workflow](sdk-workflow.md)** to see the full power of integrated PDP + Payments! üöÄ
</file>

<file path="docs/sdk/sdk-workflow.md">
# Step 3: Complete Storage + Payment Workflow

This is the third step in your Developer Path - the **core value demonstration** of PDP-Payments. You'll see how the Synapse SDK integrates storage and payments into a seamless workflow.

## Prerequisites

- ‚úÖ **Completed [Step 2: Quick SDK Setup](sdk-quickstart.md)** - SDK is installed and tested
- ‚úÖ **USDFC tokens** from [Step 1](setup.md) for real payments

## üéØ What You'll Learn

The **killer feature** of PDP-Payments: **automatic payment coordination** with storage operations.

**Traditional Storage**: Store file ‚Üí manually handle payments ‚Üí hope provider keeps file
**PDP-Payments**: Store file ‚Üí automatic payment escrow ‚Üí cryptographic proof ‚Üí automatic settlement

## 1. Complete Workflow Script

Create `complete-workflow.js`:

```javascript
// complete-workflow.js
import { Synapse } from 'synapse-sdk'
import { readFileSync } from 'fs'
import 'dotenv/config'

async function completeWorkflow() {
  console.log('üöÄ Starting Complete PDP + Payments Workflow\n')
  
  // Initialize SDK
  const synapse = new Synapse({
    privateKey: process.env.PRIVATE_KEY,
    withCDN: true,
  })
  
  // === STEP 1: PAYMENT SETUP ===
  console.log('üí∞ Step 1: Payment Setup')
  console.log('‚îÄ'.repeat(40))
  
  let balance = await synapse.balance()
  console.log(`Current balance: ${balance} USDFC`)
  
  // Ensure sufficient balance for storage
  const requiredBalance = 10
  if (balance < requiredBalance) {
    console.log(`üí∏ Depositing ${requiredBalance - balance} USDFC...`)
    balance = await synapse.deposit(requiredBalance - balance)
    console.log(`‚úÖ Deposit successful! New balance: ${balance} USDFC`)
  }
  
  // === STEP 2: STORAGE WITH AUTOMATIC PAYMENT ESCROW ===
  console.log('\nüìÅ Step 2: Storage with Payment Escrow')
  console.log('‚îÄ'.repeat(40))
  
  // Create storage service
  const storage = await synapse.createStorage({
    // Optional: specify preferred storage provider
    // storageProvider: 'f01234'
  })
  
  console.log(`Storage service created:`)
  console.log(`- Proof Set ID: ${storage.proofSetId}`)
  console.log(`- Storage Provider: ${storage.storageProvider}`)
  
  // Prepare file data (example: small text file)
  const fileData = new TextEncoder().encode('Hello PDP-Payments! This is my first stored file.')
  console.log(`File size: ${fileData.length} bytes`)
  
  // Upload with automatic payment escrow
  console.log('\nüì§ Starting upload with payment escrow...')
  const uploadTask = storage.upload(fileData)
  
  // Track upload progress
  console.log('üîÑ Generating CommP (Piece Commitment)...')
  const commp = await uploadTask.commp()
  console.log(`‚úÖ CommP generated: ${commp}`)
  
  console.log('üîÑ Storing with provider (payment escrowed)...')
  const sp = await uploadTask.store()
  console.log(`‚úÖ Stored with provider: ${sp}`)
  
  console.log('üîÑ Committing to blockchain...')
  const txHash = await uploadTask.done()
  console.log(`‚úÖ Upload complete! Transaction: ${txHash}`)
  
  // === STEP 3: MONITOR AND VERIFY ===
  console.log('\nüîç Step 3: Monitor Storage & Payments')
  console.log('‚îÄ'.repeat(40))
  
  // Check updated balance (should be reduced by storage cost)
  const balanceAfterStorage = await synapse.balance()
  console.log(`Balance after storage: ${balanceAfterStorage} USDFC`)
  console.log(`Storage cost: ${balance - balanceAfterStorage} USDFC`)
  
  // === STEP 4: PAYMENT SETTLEMENT ===
  console.log('\nüí∏ Step 4: Payment Settlement')
  console.log('‚îÄ'.repeat(40))
  
  console.log('Settling payments with storage provider...')
  const settlement = await storage.settlePayments()
  console.log(`‚úÖ Settlement complete:`)
  console.log(`- Amount settled: ${settlement.settledAmount} USDFC`)
  console.log(`- Settlement epoch: ${settlement.epoch}`)
  
  // === STEP 5: FILE RETRIEVAL ===
  console.log('\nüì• Step 5: File Retrieval')
  console.log('‚îÄ'.repeat(40))
  
  console.log('Downloading file with verification...')
  const retrievedData = await storage.download(commp, {
    noVerify: false, // Verify data integrity
    withCDN: true    // Use CDN if available
  })
  
  const retrievedText = new TextDecoder().decode(retrievedData)
  console.log(`‚úÖ File retrieved successfully!`)
  console.log(`Retrieved content: "${retrievedText}"`)
  console.log(`Data integrity: ${retrievedText === 'Hello PDP-Payments! This is my first stored file.' ? '‚úÖ VERIFIED' : '‚ùå CORRUPTED'}`)
  
  // === STEP 6: CLEANUP (OPTIONAL) ===
  console.log('\nüßπ Step 6: Cleanup (Optional)')
  console.log('‚îÄ'.repeat(40))
  
  // Delete file from storage
  console.log('Deleting file from storage...')
  await storage.delete(commp)
  console.log('‚úÖ File deleted from storage')
  
  // Withdraw remaining balance
  const finalBalance = await synapse.balance()
  if (finalBalance > 0) {
    console.log(`Withdrawing remaining ${finalBalance} USDFC...`)
    await synapse.withdraw(finalBalance)
    console.log('‚úÖ Withdrawal complete')
  }
  
  console.log('\nüéâ Complete workflow finished successfully!')
  console.log('\nWhat happened:')
  console.log('1. ‚úÖ Automatic payment escrow during upload')
  console.log('2. ‚úÖ Cryptographic proof generation (CommP)')
  console.log('3. ‚úÖ Blockchain commitment for verifiability')
  console.log('4. ‚úÖ Automatic payment settlement with provider')
  console.log('5. ‚úÖ Verified file retrieval with integrity check')
}

completeWorkflow().catch(console.error)
```

## 2. Run the Complete Workflow

```bash
node complete-workflow.js
```

**Expected Output:**
```
üöÄ Starting Complete PDP + Payments Workflow

üí∞ Step 1: Payment Setup
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Current balance: 100 USDFC

üìÅ Step 2: Storage with Payment Escrow
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Storage service created:
- Proof Set ID: ps_abc123
- Storage Provider: f01234

File size: 52 bytes

üì§ Starting upload with payment escrow...
üîÑ Generating CommP (Piece Commitment)...
‚úÖ CommP generated: baga6ea4seaqjtovkwk4myyzj56eztkh5pzsk5upksan6f5outesy62bsvl4dsha

üîÑ Storing with provider (payment escrowed)...
‚úÖ Stored with provider: f01234

üîÑ Committing to blockchain...
‚úÖ Upload complete! Transaction: 0x1234...abcd

üîç Step 3: Monitor Storage & Payments
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Balance after storage: 100 USDFC
Storage cost: 0 USDFC

üí∏ Step 4: Payment Settlement
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Settling payments with storage provider...
‚úÖ Settlement complete:
- Amount settled: 0.05 USDFC
- Settlement epoch: 12345

üì• Step 5: File Retrieval
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Downloading file with verification...
‚úÖ File retrieved successfully!
Retrieved content: "Hello PDP-Payments! This is my first stored file."
Data integrity: ‚úÖ VERIFIED

üßπ Step 6: Cleanup (Optional)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Deleting file from storage...
‚úÖ File deleted from storage
Withdrawing remaining 100 USDFC...
‚úÖ Withdrawal complete

üéâ Complete workflow finished successfully!

What happened:
1. ‚úÖ Automatic payment escrow during upload
2. ‚úÖ Cryptographic proof generation (CommP)
3. ‚úÖ Blockchain commitment for verifiability
4. ‚úÖ Automatic payment settlement with provider
5. ‚úÖ Verified file retrieval with integrity check
```

## 3. Key Concepts Explained

### üîê **CommP (Piece Commitment)**
- Cryptographic fingerprint of your file
- Used for verification and retrieval
- Generated automatically by SDK

### üí∞ **Payment Escrow**
- USDFC automatically held during storage
- Released to provider after proof verification
- No manual payment coordination needed

### üîç **PDP (Proof of Data Possession)**
- Cryptographic proof your file is stored
- Verified on-chain for transparency
- Automatic monitoring by SDK

### üí∏ **Settlement**
- Automatic payment to storage provider
- Based on actual storage duration
- Transparent on-chain settlement

## 4. SDK vs Raw Contracts Comparison

**This workflow with SDK: ~30 lines**
```javascript
const synapse = new Synapse({ privateKey })
const storage = await synapse.createStorage()
const uploadTask = storage.upload(data)
const commp = await uploadTask.commp()
await uploadTask.done()
await storage.settlePayments()
```

**Same workflow with raw contracts: ~200+ lines**
- Manual contract instantiation
- Complex payment coordination
- Manual proof submission
- Error-prone state management
- No automatic settlement

## 5. What's Next?

Continue to **[Step 4: Monitor & Verify](sdk-monitoring.md)** to learn:
- üìä Real-time storage monitoring
- üîç Proof verification details
- üìà Payment tracking and analytics
- üö® Error handling and recovery

## Troubleshooting

### File Upload Fails
- Check your balance has sufficient USDFC
- Ensure file size is within limits
- Verify network connectivity

### Payment Issues
- Confirm USDFC tokens in wallet
- Check private key is correct
- Verify you're on Calibration testnet

### Retrieval Fails
- Ensure CommP is correct
- Check storage provider is online
- Try with `noVerify: true` for debugging

Ready for monitoring and verification? **[Continue to Step 4 ‚Üí](sdk-monitoring.md)**
</file>

<file path="docs/contracts-details.md">
# Contract Address Details

This document provides human-readable definitions and explanations for the key contract addresses used in the PDP-Payments system.

## Overview

The PDP-Payments system uses several smart contracts deployed on the Filecoin network. These addresses are **system-defined** and **not user-configurable**. They represent core infrastructure components that all users interact with.

## Key Contract Addresses

### USDFC Token Address

**What it is:** The address of the USDFC (USD Filecoin) stablecoin contract - a USD-pegged token used for payments in the system.

**Purpose:** 
- Serves as the primary payment token for storage services
- Provides price stability for storage payments (pegged to USD)
- Enables programmable payments through smart contracts

**Who sets it up:** 
- Deployed and maintained by the USDFC token issuer
- **Not user-defined** - this is a system-wide token contract

**Current addresses:**
- **Calibration Testnet:** `0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0`
- **Mainnet:** (Contact system administrators for mainnet address)

**How it's used:**
- Clients deposit USDFC tokens to fund storage payments
- Storage providers receive USDFC tokens as payment for services
- All payment calculations and settlements are denominated in USDFC

### Payment Proxy Address (Payments Contract)

**What it is:** The main Payments contract that manages payment rails, fund deposits, and settlement between clients and storage providers.

**Purpose:**
- Manages user account balances and fund deposits
- Creates and manages payment rails between clients and providers
- Handles payment settlement and arbitration
- Enforces payment lockup periods and commission rates

**Who sets it up:**
- Deployed by the PDP-Payments system administrators
- **Not user-defined** - this is core system infrastructure

**Current addresses:**
- **Calibration Testnet:** `0x0E690D3e60B0576D01352AB03b258115eb84A047`
- **Mainnet:** `0x8BA1f109551bD432803012645Ac136ddd64DBA72`

**How it's used:**
- Clients deposit USDFC tokens into this contract
- Clients create payment rails through this contract
- Storage providers receive payments from this contract
- Arbiters interact with this contract to adjust payments based on service quality

### PDP Service Address

**What it is:** The SimplePDPService contract address that implements the Service Level Agreement (SLA) terms for the PDP (Provable Data Possession) system.

**Purpose:**
- Defines proof frequency requirements (how often storage providers must submit proofs)
- Specifies challenge windows (time periods for proof submission)
- Records faults when storage providers fail to submit valid proofs
- Integrates with the payment system to adjust payments based on proof compliance

**Who sets it up:**
- Deployed by the PDP system administrators
- **Not user-defined** - this is core system infrastructure

**Current addresses:**
- **Calibration Testnet:** `0xdbE4bEF3F313dAC36257b0621e4a3BC8Dc9679a1`
- **Mainnet:** `0x805370387fA5Bd8053FD8f7B2da4055B9a4f8019`

**How it's used:**
- Referenced when creating proof sets in the PDP Verifier contract
- Monitors storage provider proof submissions
- Records faults for missed or invalid proofs
- Provides fault data to arbiters for payment adjustments

## Additional System Contracts

### PDP Verifier Address

**What it is:** The PDPVerifier contract that manages proof sets and verifies storage proofs.

**Current addresses:**
- **Calibration Testnet:** `0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC`
- **Mainnet:** `0x9C65E8E57C98cCc040A3d825556832EA1e9f4Df6`

## Important Notes

### User vs System Configuration

**System-Defined (Not User Configurable):**
- All contract addresses listed above
- Token contract specifications
- Network-specific deployments
- Core protocol parameters

**User-Defined:**
- Storage provider addresses (who you pay)
- Payment rates (how much you pay)
- Lockup periods (how long funds are locked)
- Arbiter selection (which arbiter monitors service quality)

### Network Compatibility

All addresses are network-specific:
- **Calibration Testnet:** Use for development and testing
- **Mainnet:** Use for production deployments
- **Never mix addresses** between networks

### Security Considerations

- These addresses are part of the core protocol infrastructure
- Always verify addresses against official documentation
- Use environment variables to manage network-specific addresses
- Never hardcode addresses directly in production code

## Integration Examples

### Environment Configuration

```bash
# Calibration Testnet
USDFC_TOKEN_ADDRESS=0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0
PAYMENT_PROXY_ADDRESS=0x0E690D3e60B0576D01352AB03b258115eb84A047
PDP_SERVICE_ADDRESS=0xdbE4bEF3F313dAC36257b0621e4a3BC8Dc9679a1
PDP_VERIFIER_ADDRESS=0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC
```

### Code Usage

```javascript
// These addresses are system infrastructure - not user-defined
const SYSTEM_CONTRACTS = {
  USDFC_TOKEN: process.env.USDFC_TOKEN_ADDRESS,
  PAYMENTS: process.env.PAYMENT_PROXY_ADDRESS,
  PDP_SERVICE: process.env.PDP_SERVICE_ADDRESS,
  PDP_VERIFIER: process.env.PDP_VERIFIER_ADDRESS
};

// User-defined parameters
const USER_CONFIG = {
  storageProvider: '0x...', // Your chosen storage provider
  paymentRate: '0.01',      // Your payment rate
  lockupPeriod: 2880        // Your lockup period
};
```

## Related Documentation

- [MVP Configuration Guide](MVP.md) - Complete setup instructions
- [Payments Overview](payments-overview.md) - How the payment system works
- [PDP Overview](pdp-overview.md) - How the proof system works
- [Integration Guide](integration/pdp-payments.md) - Connecting PDP with Payments
</file>

<file path="docs/contracts-guide.md">
# Contracts Integration Guide

This guide provides comprehensive information for developers who want to interact directly with the PDP and Payments smart contracts.

## Overview

The FilOz system consists of two main contract systems:

1. **PDP (Provable Data Possession) Contracts** - Handle storage verification and proof submission
2. **Payments Contracts** - Manage payment rails and settlement between clients and storage providers

## Contract Addresses

### Filecoin Calibration Testnet

| Contract | Address | Purpose |
|----------|---------|---------|
| **PDPVerifier** | `0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC` | Main PDP verification contract |
| **SimplePDPService** | `0x6170dE2b09b404776197485F3dc6c968Ef948505` | PDP service implementation |
| **Payments** | `0xc5e1333D3cD8a3F1f8A9f9A116f166cBD0bA307A` | Payment rails management |
| **USDFC Token** | `0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0` | Stablecoin for payments |

### Filecoin Mainnet

| Contract | Address | Purpose |
|----------|---------|---------|
| **Payments** | `0x8BA1f109551bD432803012645Ac136ddd64DBA72` | Payment rails management |

## Quick Start: Contract Interaction

### 1. Setup Web3 Connection

```javascript
const ethers = require('ethers');

// Connect to Filecoin Calibration testnet
const provider = new ethers.providers.JsonRpcProvider(
  'https://api.calibration.node.glif.io/rpc/v1'
);

// Create wallet instance
const wallet = new ethers.Wallet(privateKey, provider);
```

### 2. Contract Instances

```javascript
// PDP Verifier Contract
const pdpVerifierAbi = require('./abis/PDPVerifier.json');
const pdpVerifier = new ethers.Contract(
  '0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC',
  pdpVerifierAbi,
  wallet
);

// Payments Contract
const paymentsAbi = require('./abis/Payments.json');
const payments = new ethers.Contract(
  '0xc5e1333D3cD8a3F1f8A9f9A116f166cBD0bA307A',
  paymentsAbi,
  wallet
);

// USDFC Token Contract
const erc20Abi = [
  "function balanceOf(address owner) view returns (uint256)",
  "function approve(address spender, uint256 value) returns (bool)",
  "function transfer(address to, uint256 value) returns (bool)"
];
const usdfc = new ethers.Contract(
  '0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0',
  erc20Abi,
  wallet
);
```

## PDP Contract Integration

### Creating a Proof Set

```javascript
async function createProofSet(railId, paymentsAddress) {
  try {
    // Encode payment information in extra data
    const extraData = ethers.utils.defaultAbiCoder.encode(
      ['uint256', 'address'],
      [railId, paymentsAddress]
    );
    
    // Get sybil fee (typically 0.1 tFIL)
    const sybilFee = await pdpVerifier.sybilFee();
    
    // Create proof set
    const tx = await pdpVerifier.createProofSet(
      '0x6170dE2b09b404776197485F3dc6c968Ef948505', // SimplePDPService address
      extraData,
      { value: sybilFee }
    );
    
    const receipt = await tx.wait();
    const proofSetId = receipt.events[0].args.setId;
    
    console.log(`Created proof set with ID: ${proofSetId}`);
    return proofSetId;
    
  } catch (error) {
    console.error('Error creating proof set:', error);
    throw error;
  }
}
```

### Submitting Proofs

```javascript
async function submitProofs(proofSetId, proofs) {
  try {
    // Check if it's time to submit proofs
    const nextChallengeEpoch = await pdpVerifier.getNextChallengeEpoch(proofSetId);
    const currentEpoch = await provider.getBlockNumber();
    
    if (currentEpoch < nextChallengeEpoch) {
      console.log('Not yet time to submit proofs');
      return;
    }
    
    // Submit proofs
    const tx = await pdpVerifier.submitProofs(proofSetId, proofs);
    const receipt = await tx.wait();
    
    console.log(`Proofs submitted successfully: ${tx.hash}`);
    return receipt;
    
  } catch (error) {
    console.error('Error submitting proofs:', error);
    throw error;
  }
}
```

### Checking Proof Set Status

```javascript
async function getProofSetInfo(proofSetId) {
  try {
    const proofSet = await pdpVerifier.getProofSet(proofSetId);
    
    return {
      service: proofSet.service,
      owner: proofSet.owner,
      dataRootCount: proofSet.dataRootCount.toString(),
      lastProvenEpoch: proofSet.lastProvenEpoch.toString(),
      isActive: proofSet.isActive
    };
    
  } catch (error) {
    console.error('Error getting proof set info:', error);
    throw error;
  }
}
```

## Payments Contract Integration

### Creating a Payment Rail

```javascript
async function createPaymentRail(params) {
  try {
    const {
      tokenAddress,
      fromAddress,
      toAddress,
      arbiterAddress,
      paymentRate,
      lockupPeriod,
      lockupFixed,
      commissionRate
    } = params;
    
    // Create the payment rail
    const tx = await payments.createRail(
      tokenAddress,
      fromAddress,
      toAddress,
      arbiterAddress,
      paymentRate,
      lockupPeriod,
      lockupFixed,
      commissionRate
    );
    
    const receipt = await tx.wait();
    const railId = receipt.events[0].args.railId;
    
    console.log(`Created payment rail with ID: ${railId}`);
    return railId;
    
  } catch (error) {
    console.error('Error creating payment rail:', error);
    throw error;
  }
}
```

### Depositing Funds

```javascript
async function depositFunds(tokenAddress, amount) {
  try {
    const walletAddress = await wallet.getAddress();
    
    // First approve the payments contract to spend tokens
    const approveTx = await usdfc.approve(
      payments.address,
      ethers.utils.parseUnits(amount, 6) // USDFC has 6 decimals
    );
    await approveTx.wait();
    
    // Then deposit the funds
    const depositTx = await payments.deposit(
      tokenAddress,
      walletAddress,
      ethers.utils.parseUnits(amount, 6)
    );
    
    const receipt = await depositTx.wait();
    console.log(`Deposited ${amount} USDFC: ${depositTx.hash}`);
    return receipt;
    
  } catch (error) {
    console.error('Error depositing funds:', error);
    throw error;
  }
}
```

### Checking Account Balance

```javascript
async function getAccountBalance(tokenAddress, ownerAddress) {
  try {
    const account = await payments.accounts(tokenAddress, ownerAddress);
    
    return {
      funds: ethers.utils.formatUnits(account.funds, 6),
      lockupCurrent: ethers.utils.formatUnits(account.lockupCurrent, 6),
      lockupRate: ethers.utils.formatUnits(account.lockupRate, 6),
      lockupLastSettledAt: account.lockupLastSettledAt.toString()
    };
    
  } catch (error) {
    console.error('Error getting account balance:', error);
    throw error;
  }
}
```

## Error Handling Best Practices

### Common Error Scenarios

```javascript
async function safeContractCall(contractFunction, ...args) {
  try {
    const tx = await contractFunction(...args);
    const receipt = await tx.wait();
    
    if (receipt.status === 0) {
      throw new Error('Transaction failed');
    }
    
    return receipt;
    
  } catch (error) {
    // Handle specific error types
    if (error.code === 'INSUFFICIENT_FUNDS') {
      throw new Error('Insufficient funds for transaction');
    } else if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
      throw new Error('Transaction would fail - check contract state');
    } else if (error.message.includes('revert')) {
      throw new Error(`Contract reverted: ${error.message}`);
    }
    
    throw error;
  }
}
```

### Gas Estimation

```javascript
async function estimateGasAndExecute(contract, methodName, args, overrides = {}) {
  try {
    // Estimate gas
    const gasEstimate = await contract.estimateGas[methodName](...args, overrides);
    
    // Add 20% buffer
    const gasLimit = gasEstimate.mul(120).div(100);
    
    // Execute with estimated gas
    const tx = await contract[methodName](...args, {
      ...overrides,
      gasLimit
    });
    
    return await tx.wait();
    
  } catch (error) {
    console.error('Gas estimation failed:', error);
    throw error;
  }
}
```

## Integration Examples

### Complete Storage + Payment Flow

```javascript
async function completeStorageFlow(fileSize, storageProvider) {
  try {
    // 1. Calculate payment parameters
    const sizeInMB = fileSize / (1024 * 1024);
    const paymentRate = ethers.utils.parseUnits((sizeInMB * 0.01).toString(), 6); // 0.01 USDFC per MB per epoch
    
    // 2. Create payment rail
    const railId = await createPaymentRail({
      tokenAddress: '0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0',
      fromAddress: await wallet.getAddress(),
      toAddress: storageProvider,
      arbiterAddress: '0x6170dE2b09b404776197485F3dc6c968Ef948505',
      paymentRate,
      lockupPeriod: 60, // 60 epochs
      lockupFixed: ethers.utils.parseUnits('1', 6), // 1 USDFC
      commissionRate: 0
    });
    
    // 3. Create proof set
    const proofSetId = await createProofSet(railId, payments.address);
    
    // 4. Return both IDs for tracking
    return { railId, proofSetId };
    
  } catch (error) {
    console.error('Complete storage flow failed:', error);
    throw error;
  }
}
```

## Next Steps

- **For SDK Integration**: See [Synapse SDK Documentation](sdk/sdk-quickstart.md)
- **For Hot Vault Demo**: See [Hot Vault Example](examples/hot-vault.md)
- **For Modern Web3 Apps**: See [Wagmi-Vercel Hot Vault](examples/wagmi-vercel-hotvault.md)
- **For Payment Details**: See [Payments Overview](payments-overview.md)
- **For PDP Details**: See [PDP Overview](pdp-overview.md)

## Support

For technical support and questions:
- **GitHub Issues**: [pdp-payment repository](https://github.com/timfong888/pdp-payment/issues)
- **Documentation**: [Complete documentation index](navigation.md)
</file>

<file path="docs/contracts-reference.md">
# Smart Contracts Reference

This page provides comprehensive information about all deployed smart contracts in the FilOz ecosystem, including addresses, ABIs, and usage examples.

## Contract Addresses

### Filecoin Mainnet

| Contract | Address | Purpose | Status |
|----------|---------|---------|---------|
| **PDP Verifier** | `0x9C65E8E57C98cCc040A3d825556832EA1e9f4Df6` | Proof verification and management | ‚úÖ Active |
| **PDP Service** | `0x805370387fA5Bd8053FD8f7B2da4055B9a4f8019` | Storage service implementation | ‚úÖ Active |
| **Payments** | `0x8BA1f109551bD432803012645Ac136ddd64DBA72` | Payment rails and settlement | ‚úÖ Active |

### Filecoin Calibration Testnet

| Contract | Address | Purpose | Status |
|----------|---------|---------|---------|
| **PDP Verifier** | `0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC` | Proof verification and management | ‚úÖ Active |
| **PDP Service** | `0x6170dE2b09b404776197485F3dc6c968Ef948505` | Storage service implementation | ‚úÖ Active |
| **Payments** | `0xc5e1333D3cD8a3F1f8A9f9A116f166cBD0bA307A` | Payment rails and settlement | ‚úÖ Active |
| **USDFC Token** | `0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0` | Stablecoin for payments | ‚úÖ Active |

## Network Configuration

### Filecoin Mainnet
- **Chain ID**: `314`
- **RPC URL**: `https://api.node.glif.io/rpc/v1`
- **Block Explorer**: `https://filfox.info/`
- **Currency**: FIL

### Filecoin Calibration Testnet
- **Chain ID**: `314159`
- **RPC URL**: `https://api.calibration.node.glif.io/rpc/v1`
- **Block Explorer**: `https://calibration.filfox.info/`
- **Currency**: tFIL (testnet FIL)

## Contract ABIs

### PDP Verifier Contract

**Key Functions:**
```solidity
// Create a new proof set
function createProofSet(address service, bytes calldata extraData) external payable returns (uint256 setId)

// Submit proofs for a proof set
function submitProofs(uint256 setId, bytes[] calldata proofs) external

// Get proof set information
function getProofSet(uint256 setId) external view returns (ProofSet memory)

// Get next challenge epoch
function getNextChallengeEpoch(uint256 setId) external view returns (uint256)

// Check if proofs are required
function isProofRequired(uint256 setId) external view returns (bool)
```

**Events:**
```solidity
event ProofSetCreated(uint256 indexed setId, address indexed owner, address indexed service)
event ProofsSubmitted(uint256 indexed setId, uint256 indexed epoch, bytes32 indexed root)
event ProofSetFaulted(uint256 indexed setId, uint256 indexed epoch)
```

### Payments Contract

**Key Functions:**
```solidity
// Create a payment rail
function createRail(
    address token,
    address from,
    address to,
    address arbiter,
    uint256 rate,
    uint256 lockupPeriod,
    uint256 lockupFixed,
    uint256 commissionRate
) external returns (uint256 railId)

// Deposit funds
function deposit(address token, address to, uint256 amount) external

// Settle payments
function settleRail(uint256 railId, uint256 epoch) external

// Get account information
function accounts(address token, address owner) external view returns (Account memory)

// Get rail information
function rails(uint256 railId) external view returns (Rail memory)
```

**Events:**
```solidity
event RailCreated(uint256 indexed railId, address indexed from, address indexed to)
event Deposit(address indexed token, address indexed to, uint256 amount)
event Settlement(uint256 indexed railId, uint256 indexed epoch, uint256 amount)
event RailModified(uint256 indexed railId, uint256 newRate, uint256 newLockup)
```

### USDFC Token Contract (ERC20)

**Standard ERC20 Functions:**
```solidity
function balanceOf(address owner) external view returns (uint256)
function transfer(address to, uint256 value) external returns (bool)
function approve(address spender, uint256 value) external returns (bool)
function allowance(address owner, address spender) external view returns (uint256)
```

## Usage Examples

### JavaScript/TypeScript Integration

```javascript
// Contract configuration
const CONTRACTS = {
  // Calibration Testnet
  PDP_VERIFIER: '0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC',
  PDP_SERVICE: '0x6170dE2b09b404776197485F3dc6c968Ef948505',
  PAYMENTS: '0xc5e1333D3cD8a3F1f8A9f9A116f166cBD0bA307A',
  USDFC_TOKEN: '0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0',
}

// Network configuration
const NETWORKS = {
  calibration: {
    chainId: 314159,
    rpcUrl: 'https://api.calibration.node.glif.io/rpc/v1',
    blockExplorer: 'https://calibration.filfox.info/',
  },
  mainnet: {
    chainId: 314,
    rpcUrl: 'https://api.node.glif.io/rpc/v1',
    blockExplorer: 'https://filfox.info/',
  }
}
```

### Wagmi Configuration

```typescript
import { createConfig, http } from 'wagmi'
import { filecoin, filecoinCalibration } from 'wagmi/chains'

export const config = createConfig({
  chains: [filecoinCalibration, filecoin],
  transports: {
    [filecoinCalibration.id]: http('https://api.calibration.node.glif.io/rpc/v1'),
    [filecoin.id]: http('https://api.node.glif.io/rpc/v1'),
  },
})
```

### Viem Configuration

```typescript
import { createPublicClient, createWalletClient, http } from 'viem'
import { filecoinCalibration } from 'viem/chains'

const publicClient = createPublicClient({
  chain: filecoinCalibration,
  transport: http('https://api.calibration.node.glif.io/rpc/v1')
})

const walletClient = createWalletClient({
  chain: filecoinCalibration,
  transport: http('https://api.calibration.node.glif.io/rpc/v1')
})
```

## Gas and Fees

### Typical Gas Costs (Calibration Testnet)

| Operation | Estimated Gas | Cost (tFIL) |
|-----------|---------------|-------------|
| Create Proof Set | ~200,000 | ~0.002 tFIL |
| Submit Proofs | ~150,000 | ~0.0015 tFIL |
| Create Payment Rail | ~180,000 | ~0.0018 tFIL |
| Deposit Funds | ~80,000 | ~0.0008 tFIL |
| Settle Payments | ~120,000 | ~0.0012 tFIL |

### Additional Fees

- **Sybil Fee (Proof Sets)**: 0.1 tFIL (paid to PDP Verifier)
- **USDFC Transactions**: Standard ERC20 gas costs
- **Network Fees**: Variable based on network congestion

## Security Considerations

### Contract Verification
- All contracts are verified on the respective block explorers
- Source code is available for audit
- Contracts follow standard security practices

### Best Practices
1. **Always verify contract addresses** before interacting
2. **Use appropriate gas limits** to avoid failed transactions
3. **Check allowances** before token transfers
4. **Monitor transaction status** for confirmation
5. **Use testnet first** for development and testing

### Known Limitations
- Proof submission has time windows (challenge epochs)
- Payment settlements require sufficient account balance
- Some operations require specific contract states

## Development Tools

### Block Explorers
- **Mainnet**: [https://filfox.info/](https://filfox.info/)
- **Calibration**: [https://calibration.filfox.info/](https://calibration.filfox.info/)

### RPC Endpoints
- **Mainnet**: `https://api.node.glif.io/rpc/v1`
- **Calibration**: `https://api.calibration.node.glif.io/rpc/v1`

### Faucets
- **Calibration tFIL**: [https://faucet.calibration.fildev.network/](https://faucet.calibration.fildev.network/)
- **USDFC Tokens**: Available through the setup guide

## Integration Guides

For detailed integration examples, see:
- **[Contracts Integration Guide](contracts-guide.md)** - Direct contract interaction patterns
- **[SDK Documentation](sdk/sdk-quickstart.md)** - High-level SDK integration
- **[Hot Vault Examples](examples/hot-vault.md)** - Complete application examples

## Support

For technical support:
- **Documentation**: [Navigation Guide](navigation.md)
- **GitHub Issues**: [pdp-payment repository](https://github.com/timfong888/pdp-payment/issues)
- **Example Code**: [Hot Vault Demo](https://github.com/FilOzone/hotvault-demo)
</file>

<file path="docs/contributing.md">
# Contributing to FilOz Documentation

Thank you for your interest in contributing to the FilOz documentation! This guide will help you get started with contributing to this repository.

## Table of Contents

- [Code of Conduct](#code-of-conduct)
- [Getting Started](#getting-started)
- [How to Contribute](#how-to-contribute)
- [Style Guide](#style-guide)
- [Review Process](#review-process)

## Code of Conduct

By participating in this project, you agree to abide by our Code of Conduct. Please be respectful and considerate of others when contributing.

## Getting Started

1. **Fork the Repository**: Start by forking the repository to your own GitHub account.

2. **Clone the Repository**: Clone your fork to your local machine.
   ```bash
   git clone https://github.com/your-username/filoz-docs.git
   cd filoz-docs
   ```

3. **Create a Branch**: Create a new branch for your changes.
   ```bash
   git checkout -b feature/your-feature-name
   ```

## How to Contribute

### Documentation Improvements

1. **Fix Typos or Grammar**: Even small fixes to typos or grammar are welcome.

2. **Clarify Existing Content**: If you find a section that's unclear, feel free to improve it.

3. **Add New Content**: If you have expertise in a particular area, consider adding new documentation.

### Process

1. **Make Your Changes**: Edit or add files as needed.

2. **Commit Your Changes**: Use clear, descriptive commit messages.
   ```bash
   git commit -m "Add documentation for XYZ feature"
   ```

3. **Push to Your Fork**: Push your changes to your fork on GitHub.
   ```bash
   git push origin feature/your-feature-name
   ```

4. **Create a Pull Request**: Go to the original repository and create a pull request from your branch.

## Style Guide

To maintain consistency across the documentation:

### Markdown Formatting

- Use ATX-style headers (`#` for h1, `##` for h2, etc.)
- Use backticks for inline code: `` `code` ``
- Use triple backticks for code blocks:
  ```
  ```javascript
  // Your code here
  ```
  ```

### Content Guidelines

- **Be Clear and Concise**: Avoid jargon and overly complex sentences.
- **Use Examples**: Provide examples to illustrate concepts.
- **Link Related Content**: Cross-reference related documentation.
- **Keep It Updated**: Ensure your content reflects the current state of the project.

## Review Process

After you submit a pull request:

1. **Initial Review**: Maintainers will review your changes for technical accuracy and style.

2. **Feedback**: You may receive feedback requesting changes.

3. **Approval and Merge**: Once approved, your changes will be merged into the main branch.

Thank you for contributing to making the FilOz documentation better for everyone!
</file>

<file path="docs/diagrams.md">
# PDP-Payments (FWS) System Diagrams

This page contains various diagrams that illustrate the architecture and workflows of the PDP-Payments (FWS) system.

## System Architecture

```mermaid
graph TD
    subgraph "PDP System"
        PV[PDPVerifier Contract]
        PS[SimplePDPService Contract]
        PL[PDPListener Interface]
    end
    
    subgraph "Payments System"
        PC[Payments Contract]
        AI[Arbiter Interface]
        AM[Account Management]
    end
    
    subgraph "Integration Layer"
        IL[Integration Components]
    end
    
    subgraph "Clients"
        C[Client Applications]
    end
    
    subgraph "Storage Providers"
        SP[Storage Provider Systems]
    end
    
    PV <--> PS
    PS <--> PL
    PC <--> AI
    PC <--> AM
    
    PV <--> IL
    PC <--> IL
    
    IL <--> C
    IL <--> SP
    
    C <--> SP
```

The diagram above shows the overall architecture of the PDP-Payments (FWS) system, including the relationships between the PDP components, Payment components, and their integration.

## PDP Workflow

```mermaid
sequenceDiagram
    participant C as Client
    participant PV as PDPVerifier
    participant PS as PDPService
    participant SP as Storage Provider
    
    C->>PV: Create Proof Set
    PV->>PS: Register with Service
    PS->>PV: Set SLA Parameters
    
    SP->>PV: Add Data Roots
    
    loop For each proving period
        PS->>PV: Generate Challenges
        PV->>SP: Request Proofs
        SP->>PV: Submit Proofs
        PV->>PS: Verify Proofs
        
        alt Proofs Valid
            PS->>SP: Record Compliance
        else Proofs Invalid/Missing
            PS->>SP: Record Fault
        end
    end
```

This diagram illustrates the workflow of the Provable Data Possession (PDP) system, from proof set creation to verification.

## Payment Rails

```mermaid
graph LR
    subgraph "Payment Rail"
        P[Payer/Client] -->|Deposits Funds| PC[Payments Contract]
        PC -->|Continuous Payments| PY[Payee/Provider]
        
        A[Arbiter] -->|Adjusts Payments| PC
        O[Operator] -->|Manages Rail| PC
        
        PC -->|Lockup Period| L[Lockup]
        PC -->|Payment Rate| PR[Rate]
    end
    
    subgraph "Settlement"
        PC -->|Settle| S[Settlement Process]
        S -->|Adjusted Amount| PY
    end
```

This diagram shows how payment rails connect payers and payees, with arbitration for SLA enforcement.

## Integration Workflow

```mermaid
sequenceDiagram
    participant C as Client
    participant PV as PDPVerifier
    participant PS as PDPService
    participant PC as Payments Contract
    participant A as Arbiter
    participant SP as Storage Provider
    
    C->>PC: Create Payment Rail
    C->>PC: Deposit Funds
    C->>PV: Create Proof Set
    C->>PV: Link to Payment Rail
    
    SP->>PV: Add Data Roots
    
    loop For each settlement period
        PS->>PV: Generate Challenges
        SP->>PV: Submit Proofs
        PV->>PS: Verify Proofs
        PS->>A: Report Compliance/Faults
        
        PC->>A: Request Arbitration
        A->>PC: Adjust Payment Amount
        
        PC->>SP: Settle Payments
    end
```

This diagram demonstrates how the PDP and Payments systems integrate to provide verifiable storage with automatic payment adjustments.

## Hot Vault Example

```mermaid
graph TD
    subgraph "Client"
        C[Client Application]
        D[Data]
    end
    
    subgraph "Hot Vault"
        HV[Hot Vault Service]
        S[Storage]
    end
    
    subgraph "PDP-Payments"
        PV[PDPVerifier]
        PS[PDPService]
        PC[Payments Contract]
        A[Arbiter]
    end
    
    C -->|Store Data| HV
    D -->|Data Roots| PV
    
    HV -->|Store| S
    HV -->|Submit Proofs| PV
    
    C -->|Create Rail| PC
    C -->|Create Proof Set| PV
    
    PV -->|Verify Proofs| PS
    PS -->|Report Compliance| A
    A -->|Adjust Payments| PC
    PC -->|Continuous Payments| HV
```

This diagram shows the Hot Vault example implementation, which demonstrates how PDP-Payments (FWS) can be used for hot storage with continuous payments.

## Component Relationships

```mermaid
classDiagram
    class PDPVerifier {
        +createProofSet()
        +addDataRoot()
        +submitProof()
        +verifyProof()
    }
    
    class SimplePDPService {
        +setParameters()
        +recordFault()
        +getFaultCount()
    }
    
    class PDPListener {
        <<interface>>
        +onProofSubmitted()
        +onFaultRecorded()
    }
    
    class PaymentsContract {
        +createRail()
        +depositFunds()
        +modifyRail()
        +settlePayments()
    }
    
    class Arbiter {
        <<interface>>
        +arbitratePayment()
    }
    
    class PDPArbiter {
        +arbitratePayment()
    }
    
    PDPVerifier --> SimplePDPService
    SimplePDPService --> PDPListener
    
    PaymentsContract --> Arbiter
    PDPArbiter --|> Arbiter
    PDPArbiter --> SimplePDPService
```

This diagram shows the relationships between the various components of the PDP-Payments (FWS) system, including contracts, interfaces, and services.

## Note on Diagrams

These diagrams are provided for illustrative purposes. The actual implementation may vary slightly. For the most accurate and up-to-date information, please refer to the corresponding documentation pages and the source code.

The diagrams are created using [Mermaid](https://mermaid-js.github.io/mermaid/), a JavaScript-based diagramming and charting tool that renders Markdown-inspired text definitions to create diagrams dynamically.
</file>

<file path="docs/first-deal.md">
# Creating Your First Storage Deal

This guide walks you through the process of creating your first storage deal using the FilOz ecosystem.

## Prerequisites

Before you begin, make sure you have:
- Completed the [Setting Up Your Environment](setup.md) guide
- Some test tokens on Filecoin Calibration Testnet
- A file you want to store

## Step 1: Prepare Your Data

First, you need to prepare your data for storage:

```javascript
const fs = require('fs');
const { CarWriter } = require('@ipld/car');
const { importer } = require('ipfs-unixfs-importer');
const { CID } = require('multiformats/cid');
const { sha256 } = require('multiformats/hashes/sha2');
const { encode } = require('multiformats/block');
const { code } = require('@ipld/dag-cbor');

async function prepareData(filePath) {
  // Read the file
  const fileData = fs.readFileSync(filePath);
  
  // Import the file to create a DAG
  const options = {
    cidVersion: 1,
    hashAlg: sha256.code,
    rawLeaves: true,
    wrapWithDirectory: false
  };
  
  const chunks = [];
  for await (const chunk of importer([{ path: filePath, content: fileData }], options)) {
    chunks.push(chunk);
  }
  
  // Get the root CID
  const rootCid = chunks[chunks.length - 1].cid;
  
  // Create a CAR file
  const { writer, out } = await CarWriter.create([rootCid]);
  const carParts = [];
  
  for await (const chunk of out) {
    carParts.push(chunk);
  }
  
  // Write all chunks to the CAR file
  for (const chunk of chunks) {
    const block = await encode({
      value: chunk.node,
      codec: code,
      hasher: sha256
    });
    await writer.put(block);
  }
  
  await writer.close();
  
  // Combine all parts into a single buffer
  const carFile = Buffer.concat(carParts);
  
  // Write the CAR file to disk
  fs.writeFileSync(`${filePath}.car`, carFile);
  
  return {
    cid: rootCid.toString(),
    carFile,
    carSize: carFile.length
  };
}
```

## Step 2: Create a Payment Rail

Next, create a payment rail to fund the storage:

```javascript
async function createPaymentRail(tokenAddress, payeeAddress) {
  // First, approve the Payments contract to spend your tokens
  const tokenAbi = ['function approve(address spender, uint256 amount) returns (bool)'];
  const token = new ethers.Contract(tokenAddress, tokenAbi, wallet);
  
  const approvalAmount = ethers.utils.parseUnits('100', 6); // 100 USDC
  const approveTx = await token.approve(paymentsAddress, approvalAmount);
  await approveTx.wait();
  console.log('Token approval confirmed');
  
  // Deposit funds into the Payments contract
  const depositAmount = ethers.utils.parseUnits('10', 6); // 10 USDC
  const depositTx = await payments.deposit(tokenAddress, wallet.address, depositAmount);
  await depositTx.wait();
  console.log('Deposit confirmed');
  
  // Create the payment rail
  const paymentRate = ethers.utils.parseUnits('0.01', 6); // 0.01 USDC per epoch
  const lockupPeriod = 2880; // 1 day in epochs
  const lockupFixed = ethers.utils.parseUnits('1', 6); // 1 USDC fixed lockup
  const commissionRate = 0; // No commission
  
  const tx = await payments.createRail(
    tokenAddress,
    wallet.address, // Your address as payer
    payeeAddress,   // Storage provider address as payee
    ethers.constants.AddressZero, // No arbiter for now
    paymentRate,
    lockupPeriod,
    lockupFixed,
    commissionRate
  );
  
  const receipt = await tx.wait();
  const railId = receipt.events[0].args.railId;
  console.log(`Created payment rail with ID: ${railId}`);
  
  return railId;
}
```

## Step 3: Create a Proof Set

Create a proof set in the PDP system:

```javascript
async function createProofSet(railId) {
  // Encode the payment rail ID in the extra data
  const extraData = ethers.utils.defaultAbiCoder.encode(
    ['uint256', 'address'],
    [railId, paymentsAddress]
  );
  
  // Calculate the sybil fee
  const sybilFee = await pdpVerifier.sybilFee();
  
  // Create the proof set
  const tx = await pdpVerifier.createProofSet(
    pdpServiceAddress,
    extraData,
    { value: sybilFee }
  );
  
  const receipt = await tx.wait();
  const proofSetId = receipt.events[0].args.setId;
  console.log(`Created proof set with ID: ${proofSetId}`);
  
  return proofSetId;
}
```

## Step 4: Make a Deal Proposal

Now, create a deal proposal using the Client Contract:

```javascript
async function makeDealProposal(cid, carSize, locationRef) {
  // Client Contract address
  const clientContractAddress = '0x...'; // Replace with actual address
  const clientContractAbi = require('./abis/DealClient.json');
  const clientContract = new ethers.Contract(clientContractAddress, clientContractAbi, wallet);
  
  // Create a deal request
  const dealRequest = {
    piece_cid: cid,
    piece_size: carSize,
    verified_deal: false,
    label: 'My first deal',
    start_epoch: (await provider.getBlockNumber()) + 100, // Start 100 epochs from now
    end_epoch: (await provider.getBlockNumber()) + 525600, // Store for approximately 1 year
    storage_price_per_epoch: ethers.utils.parseEther('0.0000001'),
    provider_collateral: ethers.utils.parseEther('0.1'),
    client_collateral: ethers.utils.parseEther('0.05'),
    extra_params_version: 1,
    extra_params: {
      location_ref: locationRef, // URL where the storage provider can retrieve the data
      car_size: carSize,
      skip_ipni_announce: false,
      remove_unsealed_copy: false
    }
  };
  
  // Make the deal proposal
  const tx = await clientContract.makeDealProposal(dealRequest);
  const receipt = await tx.wait();
  
  // Get the deal ID from the event logs
  const dealId = receipt.events[0].args.id;
  console.log(`Created deal proposal with ID: ${dealId}`);
  
  return dealId;
}
```

## Step 5: Upload Your Data

Upload your CAR file to a location accessible by the storage provider:

```javascript
async function uploadData(carFilePath) {
  // This is a simplified example - in a real application, you would:
  // 1. Upload the CAR file to a web server, IPFS, or other storage
  // 2. Return the URL or reference to the file
  
  // For this example, we'll assume you're uploading to a web server
  console.log(`Upload your CAR file (${carFilePath}) to a web server`);
  console.log('Then provide the URL to the storage provider');
  
  // In a real application, you would use a library like axios to upload the file
  const uploadUrl = 'https://example.com/uploads/myfile.car';
  
  return uploadUrl;
}
```

## Step 6: Putting It All Together

Here's how to put all the steps together:

```javascript
async function createStorageDeal(filePath, storageProviderAddress) {
  try {
    // Prepare the data
    console.log(`Preparing data from ${filePath}...`);
    const { cid, carFile, carSize } = await prepareData(filePath);
    console.log(`Data prepared with CID: ${cid}`);
    
    // Upload the data
    console.log('Uploading data...');
    const locationRef = await uploadData(`${filePath}.car`);
    console.log(`Data uploaded to: ${locationRef}`);
    
    // Create a payment rail
    console.log('Creating payment rail...');
    const railId = await createPaymentRail('0xUSDCAddress', storageProviderAddress);
    
    // Create a proof set
    console.log('Creating proof set...');
    const proofSetId = await createProofSet(railId);
    
    // Make a deal proposal
    console.log('Making deal proposal...');
    const dealId = await makeDealProposal(cid, carSize, locationRef);
    
    console.log('\nStorage deal created successfully!');
    console.log('-----------------------------------');
    console.log(`File: ${filePath}`);
    console.log(`CID: ${cid}`);
    console.log(`Payment Rail ID: ${railId}`);
    console.log(`Proof Set ID: ${proofSetId}`);
    console.log(`Deal ID: ${dealId}`);
    
    return { cid, railId, proofSetId, dealId };
  } catch (error) {
    console.error('Error creating storage deal:', error);
    throw error;
  }
}

// Usage
createStorageDeal('myfile.txt', '0xStorageProviderAddress')
  .then(result => console.log('Done!'))
  .catch(error => console.error('Failed:', error));
```

## Next Steps

After creating your first storage deal:

1. Learn how to [Monitor Your Storage Deal](pdp/guides/verifying-proofs.md)
2. Understand how to [Implement a Custom Arbiter](payments/guides/custom-arbiter.md)
3. Explore the [Hot Vault Demo](examples/hot-vault.md) for a complete implementation

For more information on the components used in this guide:
- [Understanding PDP](pdp-overview.md)
- [Payment Mechanisms](payments.md)
- [Client Contract Documentation](https://github.com/FilOzone/client-contract)
</file>

<file path="docs/integration-guide.md">
# Integrating PDP with Payments

This guide explains how to integrate the [Provable Data Possession (PDP)](pdp-overview.md) system with the [Payments](payments-overview.md) system to create a complete solution for verifiable storage with automatic payment adjustments based on service level compliance.

## Overview

The integration between PDP and Payments enables:

1. **Verifiable Storage**: Clients can verify that storage providers are actually storing their data
2. **Automatic Payment Adjustments**: Payments are automatically adjusted based on proof compliance
3. **SLA Enforcement**: Service Level Agreements are enforced through the arbitration mechanism
4. **Continuous Payment Flow**: Payments flow continuously as long as the service is provided correctly

## Integration Architecture

The integration works through these key components:

1. **Payment Rails**: Created in the Payments contract to facilitate ongoing payments
2. **Proof Sets**: Created in the PDP system to verify data possession
3. **Arbiter Contract**: Connects the two systems by adjusting payments based on proof compliance
4. **Extra Data**: Links the proof set to the payment rail

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Client    ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  Payments   ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ   Arbiter   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚ñ≤                                         ‚ñ≤
       ‚îÇ                                         ‚îÇ
       ‚ñº                                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Storage     ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ     PDP     ‚îÇ
‚îÇ Provider    ‚îÇ                          ‚îÇ   System    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Step-by-Step Integration Guide

### 1. Create a Payment Rail

First, create a payment rail in the Payments contract:

```javascript
// Using ethers.js to create a payment rail
async function createPaymentRail() {
    const paymentRate = ethers.utils.parseUnits('0.01', 6); // 0.01 USDC per epoch
    const lockupPeriod = 2880; // 1 day in epochs (assuming 30-second epochs)
    const lockupFixed = ethers.utils.parseUnits('5', 6); // 5 USDC fixed lockup
    const commissionRate = 250; // 2.5% commission
    
    const tx = await payments.createRail(
        tokenAddress,
        clientAddress,
        providerAddress,
        arbiterAddress, // Address of your PDP arbiter contract
        paymentRate,
        lockupPeriod,
        lockupFixed,
        commissionRate
    );
    
    // Wait for the transaction to be mined
    const receipt = await tx.wait();
    
    // Get the rail ID from the event logs
    const railId = receipt.events[0].args.railId;
    console.log(`Created rail with ID: ${railId}`);
    
    return railId;
}
```

### 2. Create a Proof Set with Payment Information

Next, create a proof set in the PDP system, including the payment rail information in the extra data:

```javascript
// Create a proof set with payment information
async function createProofSet(railId) {
    // Encode the payment information in the extra data
    const extraData = ethers.utils.defaultAbiCoder.encode(
        ['uint256', 'address'],
        [railId, paymentsContractAddress]
    );
    
    // Calculate the sybil fee
    const sybilFee = await pdpVerifier.sybilFee();
    
    // Create a proof set
    const tx = await pdpVerifier.createProofSet(
        pdpServiceAddress, // Address of the SimplePDPService contract
        extraData,
        { value: sybilFee }
    );
    
    // Wait for the transaction to be mined
    const receipt = await tx.wait();
    
    // Get the proof set ID from the event logs
    const proofSetId = receipt.events[0].args.setId;
    console.log(`Created proof set with ID: ${proofSetId}`);
    
    return proofSetId;
}
```

### 3. Implement a PDP Arbiter

Create an arbiter contract that adjusts payments based on PDP compliance:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IArbiter.sol";
import "./IPDPService.sol";

contract PDPArbiter is IArbiter {
    IPDPService public pdpService;
    mapping(uint256 => uint256) public railToProofSet;
    
    constructor(address _pdpService) {
        pdpService = IPDPService(_pdpService);
    }
    
    // Register a rail-to-proof-set mapping
    function registerRailProofSet(uint256 railId, uint256 proofSetId) external {
        // Add appropriate access control here
        railToProofSet[railId] = proofSetId;
    }
    
    function arbitratePayment(
        address token,
        address from,
        address to,
        uint256 railId,
        uint256 fromEpoch,
        uint256 toEpoch,
        uint256 amount
    ) external view override returns (ArbitrationResult memory) {
        // Get the proof set ID for this rail
        uint256 proofSetId = railToProofSet[railId];
        
        // If no proof set is registered, return the original amount
        if (proofSetId == 0) {
            return ArbitrationResult({
                modifiedAmount: amount,
                settleUpto: toEpoch,
                note: "No proof set registered"
            });
        }
        
        // Get fault count from PDP service
        uint256 faultCount = pdpService.getFaultCount(proofSetId, fromEpoch, toEpoch);
        
        // Calculate reduction (10% per fault, up to 100%)
        uint256 reductionPercent = faultCount * 10;
        if (reductionPercent > 100) reductionPercent = 100;
        
        uint256 reduction = amount * reductionPercent / 100;
        uint256 modifiedAmount = amount - reduction;
        
        return ArbitrationResult({
            modifiedAmount: modifiedAmount,
            settleUpto: toEpoch,
            note: string(abi.encodePacked("Reduced by ", faultCount, " faults"))
        });
    }
}
```

### 4. Storage Provider: Add Data to the Proof Set

The storage provider adds data to the proof set:

```javascript
// Add data to the proof set
async function addRoots(proofSetId, cid, dataSize) {
    // Prepare the root data
    const rootData = [
        {
            root: {
                version: 1,
                codec: 0x71, // dag-cbor
                hash: 0x12, // sha2-256
                size: 32,
                data: rootCidBytes
            },
            rawSize: dataSize
        }
    ];
    
    // Add roots to the proof set
    const tx = await pdpVerifier.addRoots(
        proofSetId,
        rootData,
        "0x" // No extra data needed
    );
    
    // Wait for the transaction to be mined
    await tx.wait();
}
```

### 5. Storage Provider: Submit Proofs

The storage provider submits proofs regularly:

```javascript
// Submit proofs to the PDP system
async function submitProofs(proofSetId) {
    // Get the next challenge epoch
    const nextChallengeEpoch = await pdpVerifier.getNextChallengeEpoch(proofSetId);
    
    // Wait until the challenge epoch
    // ... (implementation depends on your environment)
    
    // Generate proofs for the challenges
    const proofs = await generateProofs(proofSetId);
    
    // Submit proofs
    const proofFee = await pdpVerifier.calculateProofFee(proofSetId, estimatedGasFee);
    const tx = await pdpVerifier.provePossession(
        proofSetId,
        proofs,
        { value: proofFee }
    );
    
    // Wait for the transaction to be mined
    await tx.wait();
}
```

### 6. Settle Payments

Payments can be settled by anyone, typically the payee:

```javascript
// Settle payments
async function settlePayments(railId) {
    // Settle payments up to the current epoch
    const currentEpoch = await provider.getBlockNumber();
    await payments.settleRail(railId, currentEpoch);
}
```

## Complete Integration Example

Here's a complete example that ties all the steps together:

```javascript
async function setupPDPPaymentIntegration() {
    // Step 1: Create a payment rail
    const railId = await createPaymentRail();
    
    // Step 2: Create a proof set with payment information
    const proofSetId = await createProofSet(railId);
    
    // Step 3: Register the rail-to-proof-set mapping in the arbiter
    await pdpArbiter.registerRailProofSet(railId, proofSetId);
    
    // Step 4: Storage provider adds data to the proof set
    await addRoots(proofSetId, cid, dataSize);
    
    // Step 5: Set up a recurring task to submit proofs
    // This would typically be implemented as a cron job or similar
    setInterval(async () => {
        try {
            await submitProofs(proofSetId);
            console.log("Proofs submitted successfully");
        } catch (error) {
            console.error("Error submitting proofs:", error);
        }
    }, 86400000); // Check daily
    
    // Step 6: Set up a recurring task to settle payments
    // This would typically be implemented as a cron job or similar
    setInterval(async () => {
        try {
            await settlePayments(railId);
            console.log("Payments settled successfully");
        } catch (error) {
            console.error("Error settling payments:", error);
        }
    }, 86400000); // Settle daily
    
    return { railId, proofSetId };
}
```

## Best Practices

1. **Secure Extra Data**: Ensure that the extra data containing payment information is properly secured and verified
2. **Regular Settlement**: Settle payments regularly to ensure timely compensation for storage providers
3. **Fault Monitoring**: Monitor fault records to identify and address issues promptly
4. **Arbiter Security**: Implement proper access controls in your arbiter contract
5. **Testing**: Thoroughly test the integration on a testnet before deploying to mainnet

## Next Steps

- Follow the [Quick Start Guide](quick-start.md) to get started with implementation
- Explore the [Hot Vault Example](examples/hot-vault.md) for a complete implementation
- Learn about the [PDP System](pdp-overview.md) and [Payments System](payments-overview.md) in more detail
</file>

<file path="docs/introduction.md">
# Introduction to FilOz

## What is FilOz?

FilOz is a comprehensive ecosystem of tools and smart contracts designed to enhance the Filecoin storage network. It focuses on providing provable data possession (PDP), payment mechanisms, and tools for both storage providers and clients.

## Core Components

### PDP (Provable Data Possession)

The PDP system allows storage providers to prove they are still storing client data without having to retrieve the entire dataset. This is accomplished through:

- **PDPVerifier Contract**: Handles the verification of proofs submitted by storage providers
- **SimplePDPService**: Implements the SLA (Service Level Agreement) terms for proof frequency and requirements
- **Proof Sets**: Data structures that track the data being proven, the owner, and proof history

### Payments System

The payments system provides flexible payment channels between clients and storage providers:

- **Payment Rails**: Channels that connect payers and payees with configurable payment rates
- **Arbitration**: Third-party arbiters that can modify payment amounts based on service delivery
- **Settlement**: Process for ensuring payments are made according to agreed terms

### Client Contract

The client contract facilitates the creation of storage deals on Filecoin:

- **Deal Proposals**: Creation of storage deal proposals with specific parameters
- **Deal Management**: Tracking and management of deal status
- **Integration with Filecoin**: Interaction with the Filecoin storage market

### Explorer and Tools

- **PDP Explorer**: Web interface for monitoring PDP proofs and storage provider performance
- **FilForwarder**: Tool for forwarding deals to storage providers
- **DAGParts**: Library for working with content-addressable data

## How It All Works Together

1. **Client Initiates Storage**: A client creates a deal proposal through the Client Contract, specifying parameters like price, duration, and data location.

2. **PDP Integration**: The client creates a proof set in the PDPVerifier contract, specifying which SLA contract to use and providing signed payment information.

3. **Storage Provider Stores Data**: The storage provider retrieves the data from the specified location and begins storing it.

4. **Ongoing Verification**: The PDP system periodically challenges the storage provider to prove they still have the data.

5. **Payment Processing**: The payment rails, connected via the arbiter, adjust payments based on the provider's performance against the SLA.

## Benefits of FilOz

- **Trustless Verification**: Cryptographic proofs ensure data is being stored without requiring trust
- **Flexible Payments**: Configurable payment channels with arbitration for SLA enforcement
- **Transparency**: Explorer tools provide visibility into storage provider performance
- **Integration**: Seamless integration with the Filecoin network

## Next Steps

To start using FilOz, proceed to the [Setting Up Your Environment](setup.md) guide.
</file>

<file path="docs/MVP.md">
# MVP - Proof of Concept Configuration

## Overview

The current implementation is a **Minimum Viable Product (MVP)** designed as a proof of concept. This document outlines the manual configuration requirements and limitations of the current system, particularly regarding storage provider selection.

## Current Limitations

### Manual Storage Provider Configuration

**‚ö†Ô∏è Important:** The current MVP does NOT support dynamic storage provider selection. Storage providers must be manually configured using hardcoded values in environment variables.

### No Storage Provider Marketplace

The system currently lacks:
- Dynamic storage provider discovery
- Automatic provider selection based on criteria (price, reputation, availability)
- Provider registration and marketplace functionality
- Bidding or auction mechanisms for storage deals

## Required Manual Configuration

To use the current FW PDP-Payments system, you must manually configure the following values based on your chosen storage provider:

### Server Configuration (Hot Vault Demo)

The following environment variables must be set in your `.env` file:

```env
# PDP Tool & Service Configuration
PDPTOOL_PATH=/absolute/path/to/pdptool
SERVICE_NAME=your-service-name
SERVICE_URL=https://your-service-url.com
RECORD_KEEPER=0xYourRecordKeeperAddress
```

> **üìñ What is PDPTool?** PDPTool is a command-line client tool bundled with [Curio](https://github.com/filecoin-project/curio) that enables interaction with Filecoin Storage Providers running the Proof of Data Possession (PDP) service. It allows clients to create proof sets, upload files, add file roots, and verify storage integrity. For detailed setup and usage instructions, see:
> - [Curio PDP Setup Documentation](https://docs.curiostorage.org/experimental-features/enable-pdp#pdp-client)
> - [Official Filecoin PDP Documentation](https://docs.filecoin.io/storage-providers/pdp/use-pdp)
> - [Curio Repository](https://github.com/filecoin-project/curio)

### Calibnet Test Configuration

For testing on Calibration Testnet, use these specific values:

```env
# Calibnet-specific PDP Service Provider values
SERVICE_NAME=pdp-service-name
SERVICE_URL=https://yablu.net
RECORD_KEEPER=0xdbE4bEF3F313dAC36257b0621e4a3BC8Dc9679a1
```

### Client Configuration

The client application also requires hardcoded contract addresses:

```typescript
// Client constants (from constants.ts)
export const USDFC_TOKEN_ADDRESS = "0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0";
export const PAYMENT_PROXY_ADDRESS = "0x0E690D3e60B0576D01352AB03b258115eb84A047";
export const PDP_SERVICE_ADDRESS = "0xdbE4bEF3F313dAC36257b0621e4a3BC8Dc9679a1";
```

> **üìñ Need help understanding these addresses?** See [Contract Address Details](contracts-details.md) for human-readable explanations of what each address represents, who sets them up, and how they're used in the system.

## Server Configuration Requirements

### 1. Service Registration

Before using a storage provider, ensure:
- The service is registered in the PDP Tool with the provider
- The `SERVICE_NAME` matches the registered service name
- The `SERVICE_URL` points to the correct service endpoint

### 2. Record Keeper Address

The `RECORD_KEEPER` address must be:
- A valid Ethereum address
- The address of the PDP service provider on the target network
- Properly funded and authorized to submit proofs

### 3. Network Compatibility

Ensure all addresses and configurations match your target network:
- **Calibration Testnet**: Use the provided Calibnet values
- **Mainnet**: Obtain mainnet-specific addresses from your storage provider
- **Local Development**: Configure local test addresses

## Implications for Users

### For Developers

- You cannot dynamically select storage providers
- All provider information must be known at deployment time
- Switching providers requires code changes and redeployment
- No built-in provider comparison or selection logic

### For Storage Providers

- Must provide configuration values to clients manually
- No automatic registration or discovery mechanism
- Clients must hardcode your service details
- No marketplace presence or competitive bidding

### For End Users

- Limited to the storage provider chosen by the application developer
- No ability to select preferred providers based on price or performance
- No transparency into provider selection criteria

## Future Development

The following features are planned for future releases but not available in the current MVP:

### Dynamic Provider Selection
- Storage provider registry and discovery
- Automatic matching based on requirements
- Real-time provider availability checking

### Marketplace Features
- Provider reputation systems
- Competitive pricing mechanisms
- Service level agreement templates
- Automated provider onboarding

### Enhanced Client Experience
- Provider selection UI components
- Performance and cost comparison tools
- Multi-provider redundancy options

## Migration Path

When dynamic provider selection becomes available:

1. **Configuration Migration**: Environment-based configuration will be supplemented with runtime provider selection
2. **API Changes**: New APIs will be introduced for provider discovery and selection
3. **Backward Compatibility**: Existing hardcoded configurations will continue to work
4. **Gradual Adoption**: Applications can migrate to dynamic selection incrementally

## Getting Started with MVP

To use the current MVP:

1. **Choose a Storage Provider**: Contact a FilOz-compatible storage provider (note: how do we enable developers to do this?)
2. **Obtain Configuration Values**: Get the required SERVICE_NAME, SERVICE_URL, and RECORD_KEEPER values
3. **Configure Your Application**: Set the environment variables as shown above
4. **Deploy and Test**: Deploy your application with the hardcoded provider configuration

## Support

For assistance with MVP configuration:
- Review the [Hot Vault Demo](examples/hot-vault.md) for a complete example
- Check the [Quick Start Guide](quick-start.md) for setup instructions
- Consult the [Troubleshooting Guide](reference/troubleshooting.md) for common issues

---

**Note:** This MVP approach is intentional to validate the core PDP and Payments functionality before building the more complex marketplace and provider selection features. The manual configuration ensures reliable testing and development of the foundational components.
</file>

<file path="docs/navigation.md">
# Documentation Navigation Guide

This comprehensive index helps you find the right documentation for your needs, organized by user type and common tasks.

## üöÄ Quick Start Paths

### For Beginners
**Goal: Get started with minimal setup**
1. [Setup Wallet & USDFC](setup.md) - Get testnet tokens
2. [Quick Start with SDK](quick-start.md) - Use the Synapse SDK
3. [Hot Vault Example](examples/hot-vault.md) - See it in action

### For Developers
**Goal: Build production applications**
1. [Setup Wallet & USDFC](setup.md) - Get testnet tokens
2. [Blockchain Configuration](setup-detailed.md) - JSON-RPC, Viem patterns
3. [Contract Integration](contracts-guide.md) - Direct contract calls
4. [Advanced Examples](examples/wagmi-vercel-hotvault.md) - Modern Web3 patterns

### For Advanced Users
**Goal: Deep customization and integration**
1. [Contracts Guide](contracts-guide.md) - Direct contract interaction
2. [PDP Overview](pdp-overview.md) - Understand the proof system
3. [Payments Overview](payments-overview.md) - Payment rail mechanics
4. [Integration Guide](integration/pdp-payments.md) - Custom implementations

## üìö Documentation by Category

### üîß Setup & Configuration
- **[Setup Wallet & USDFC](setup.md)** - Initial wallet setup and testnet tokens
- **[Blockchain Configuration](setup-detailed.md)** - JSON-RPC, Viem patterns, environment setup
- **[Quick Start](quick-start.md)** - Get started with the Synapse SDK

### üèóÔ∏è Core Systems
- **[PDP Overview](pdp-overview.md)** - Provable Data Possession system
- **[Payments Overview](payments-overview.md)** - Payment rails and settlement
- **[Payment Rails](payments/payment-rails.md)** - Detailed payment rail documentation
- **[Contracts Guide](contracts-guide.md)** - Direct smart contract integration

### üõ†Ô∏è Development Tools
- **[Synapse SDK](sdk/sdk-quickstart.md)** - High-level SDK for rapid development
- **[SDK Workflow](sdk/sdk-workflow.md)** - SDK development patterns
- **[SDK Production](sdk/sdk-production.md)** - Production deployment with SDK
- **[SDK Monitoring](sdk/sdk-monitoring.md)** - Monitoring and debugging

### üí° Examples & Tutorials
- **[Hot Vault (Traditional)](examples/hot-vault.md)** - Docker-based reference implementation
- **[Wagmi-Vercel Hot Vault](examples/wagmi-vercel-hotvault.md)** - Modern serverless Web3 app
- **[Integration Examples](integration/pdp-payments.md)** - PDP + Payments integration patterns

### üîó Integration Guides
- **[PDP-Payments Integration](integration/pdp-payments.md)** - Combine storage proofs with payments
- **[Building on FilOz](integration/building-on-filoz.md)** - Platform integration guide
- **[Filecoin Ecosystem](integration/filecoin-ecosystem.md)** - Broader ecosystem context

## üéØ Common Tasks

### Setting Up Storage
1. **Choose your approach:**
   - **SDK (Recommended)**: [Synapse SDK Quickstart](sdk/sdk-quickstart.md)
   - **Direct Contracts**: [Contracts Guide](contracts-guide.md)
2. **Setup environment**: [Blockchain Configuration](setup-detailed.md)
3. **Follow examples**: [Hot Vault Demo](examples/hot-vault.md)

### Creating Payment Rails
1. **Understand concepts**: [Payments Overview](payments-overview.md)
2. **Learn payment rails**: [Payment Rails Guide](payments/payment-rails.md)
3. **See examples**: [Contract Integration](contracts-guide.md#payments-contract-integration)

### Implementing Proofs
1. **Understand PDP**: [PDP Overview](pdp-overview.md)
2. **Contract integration**: [Contracts Guide](contracts-guide.md#pdp-contract-integration)
3. **Production patterns**: [SDK Production Guide](sdk/sdk-production.md)

### Deploying Applications
1. **Traditional approach**: [Hot Vault Example](examples/hot-vault.md)
2. **Modern serverless**: [Wagmi-Vercel Hot Vault](examples/wagmi-vercel-hotvault.md)
3. **Production considerations**: [SDK Production](sdk/sdk-production.md)

## üîç Search by Keywords

### Storage & Files
- [PDP Overview](pdp-overview.md) - proof verification, data possession
- [Hot Vault Examples](examples/hot-vault.md) - file upload, storage dashboard
- [Contracts Guide](contracts-guide.md) - proof sets, verification

### Payments & Economics
- [Payments Overview](payments-overview.md) - payment rails, settlement, arbitration
- [Payment Rails](payments/payment-rails.md) - lockup, rates, commission
- [Integration Guide](integration/pdp-payments.md) - payment + storage integration

### Web3 & Blockchain
- [Setup Detailed](setup-detailed.md) - JSON-RPC, Viem, wallet connection
- [Wagmi-Vercel Hot Vault](examples/wagmi-vercel-hotvault.md) - modern Web3 patterns
- [Contracts Guide](contracts-guide.md) - smart contracts, transactions

### Development & Deployment
- [SDK Documentation](sdk/sdk-quickstart.md) - rapid development, TypeScript
- [Wagmi-Vercel Hot Vault](examples/wagmi-vercel-hotvault.md) - serverless, Vercel
- [SDK Production](sdk/sdk-production.md) - production deployment

## üìä Documentation Status

### ‚úÖ Complete & Current
- Setup guides (wallet, blockchain configuration)
- Core system overviews (PDP, Payments)
- SDK documentation
- Example implementations
- Contract integration guides

### üîÑ Recently Updated
- Hot Vault examples with cross-references
- Wagmi-Vercel modern implementation
- Contract addresses and ABIs
- Navigation and organization

### üìã Reference Materials
- [Contracts Reference](contracts-reference.md) - Contract addresses, ABIs, deployment info
- [System Diagrams](diagrams.md) - Visual system architecture
- [Deployed Contracts](../README.md#deployed-contracts) - Live contract addresses

## üÜò Getting Help

### Documentation Issues
- **Missing information?** Check if it's covered in related sections
- **Outdated content?** Contract addresses and examples are regularly updated
- **Need clarification?** Look for cross-references to related topics

### Technical Support
- **SDK Issues**: Start with [SDK Quickstart](sdk/sdk-quickstart.md)
- **Contract Problems**: See [Contracts Guide](contracts-guide.md) error handling
- **Integration Questions**: Check [Integration Guide](integration/pdp-payments.md)

### Community Resources
- **GitHub Repository**: [pdp-payment](https://github.com/timfong888/pdp-payment)
- **Example Code**: [Hot Vault Demo](https://github.com/FilOzone/hotvault-demo)
- **SDK Repository**: [Synapse SDK](https://github.com/FilOzone/synapse-sdk)

## üó∫Ô∏è Documentation Map

```
docs/
‚îú‚îÄ‚îÄ üöÄ Getting Started
‚îÇ   ‚îú‚îÄ‚îÄ setup.md (wallet & tokens)
‚îÇ   ‚îú‚îÄ‚îÄ setup-detailed.md (blockchain config)
‚îÇ   ‚îî‚îÄ‚îÄ quick-start.md (SDK quickstart)
‚îú‚îÄ‚îÄ üèóÔ∏è Core Systems
‚îÇ   ‚îú‚îÄ‚îÄ pdp-overview.md (proof system)
‚îÇ   ‚îú‚îÄ‚îÄ payments-overview.md (payment rails)
‚îÇ   ‚îî‚îÄ‚îÄ contracts-guide.md (direct integration)
‚îú‚îÄ‚îÄ üõ†Ô∏è SDK Documentation
‚îÇ   ‚îú‚îÄ‚îÄ sdk/sdk-quickstart.md
‚îÇ   ‚îú‚îÄ‚îÄ sdk/sdk-workflow.md
‚îÇ   ‚îú‚îÄ‚îÄ sdk/sdk-production.md
‚îÇ   ‚îî‚îÄ‚îÄ sdk/sdk-monitoring.md
‚îú‚îÄ‚îÄ üí° Examples
‚îÇ   ‚îú‚îÄ‚îÄ examples/hot-vault.md (traditional)
‚îÇ   ‚îî‚îÄ‚îÄ examples/wagmi-vercel-hotvault.md (modern)
‚îú‚îÄ‚îÄ üîó Integration
‚îÇ   ‚îú‚îÄ‚îÄ integration/pdp-payments.md
‚îÇ   ‚îú‚îÄ‚îÄ integration/building-on-filoz.md
‚îÇ   ‚îî‚îÄ‚îÄ integration/filecoin-ecosystem.md
‚îú‚îÄ‚îÄ üìã Reference
‚îÇ   ‚îú‚îÄ‚îÄ contracts-reference.md
‚îÇ   ‚îú‚îÄ‚îÄ payments/payment-rails.md
‚îÇ   ‚îî‚îÄ‚îÄ diagrams.md
‚îî‚îÄ‚îÄ üó∫Ô∏è Navigation
    ‚îî‚îÄ‚îÄ navigation.md (this file)
```

---

**üí° Tip**: Bookmark this page for quick access to all documentation. Use Ctrl+F (Cmd+F) to search for specific topics.
</file>

<file path="docs/payments-overview.md">
# Payments System Overview

## Introduction

The Payments system is a flexible payment channel solution designed specifically for Filecoin storage deals. It enables ongoing payments between clients and storage providers with built-in arbitration capabilities to enforce Service Level Agreements (SLAs).

## Key Features

- **Payment Channels**: Create dedicated payment channels (rails) between payers and payees
- **Continuous Payments**: Enable ongoing payments at configurable rates
- **SLA Enforcement**: Integrate with arbiters to adjust payments based on service performance
- **Flexible Settlement**: Settle payments on-demand or at scheduled intervals
- **Token Agnostic**: Support any ERC20 token for payments
- **Commission Support**: Enable commission payments to operators

## Core Components

### Payment Rails

A payment rail is a payment channel between a payer (client) and a payee (storage provider) that allows for:

- Continuous payments at a specified rate
- Adjustable payment rates over time
- Optional arbitration for SLA enforcement
- Secure fund lockup and settlement

```solidity
struct Rail {
    address token;        // ERC20 token used for payments
    address from;         // Payer address
    address to;           // Payee address
    address operator;     // Entity that can modify the rail
    address arbiter;      // Optional arbiter for SLA enforcement
    
    uint256 paymentRate;  // Rate at which payments flow (per epoch)
    uint256 lockupPeriod; // Number of epochs for which funds are locked
    uint256 lockupFixed;  // Fixed amount of funds locked
    
    uint256 settledUpTo;  // Epoch up to which payments have been settled
    uint256 endEpoch;     // Epoch at which the rail terminates
    uint256 commissionRateBps; // Commission rate in basis points
    
    RateChange[] rateChangeQueue; // Queue of scheduled rate changes
}
```

### Accounts

The system tracks funds and lockups for each user:

```solidity
struct Account {
    uint256 funds;              // Available funds
    uint256 lockupCurrent;      // Currently locked funds
    uint256 lockupRate;         // Rate at which funds are locked
    uint256 lockupLastSettledAt; // Last epoch when lockup was settled
}
```

### Arbitration

Arbiters can adjust payment amounts based on service performance:

```solidity
interface IArbiter {
    struct ArbitrationResult {
        uint256 modifiedAmount; // Adjusted payment amount
        uint256 settleUpto;     // Epoch up to which to settle
        string note;            // Additional information
    }
    
    function arbitratePayment(
        address token,
        address from,
        address to,
        uint256 railId,
        uint256 fromEpoch,
        uint256 toEpoch,
        uint256 amount
    ) external view returns (ArbitrationResult memory);
}
```

## Core Functionality

### Creating a Rail

Payment rails are created using the `createRail` function:

```solidity
function createRail(
    address token,
    address from,
    address to,
    address arbiter,
    uint256 paymentRate,
    uint256 lockupPeriod,
    uint256 lockupFixed,
    uint256 commissionRateBps
) external returns (uint256 railId)
```

**Parameters:**
- `token`: Address of the ERC20 token to be used for payments
- `from`: Address of the payer (client)
- `to`: Address of the payee (storage provider)
- `arbiter`: Address of the arbiter contract for SLA enforcement (can be zero address)
- `paymentRate`: Rate at which payments flow (tokens per epoch)
- `lockupPeriod`: Number of epochs for which funds are locked
- `lockupFixed`: Fixed amount of funds locked
- `commissionRateBps`: Commission rate in basis points (e.g., 250 for 2.5%)

**Returns:**
- `railId`: The ID of the newly created payment rail

**Example: Creating a Storage Payment Rail**

Let's create a payment rail for a typical storage deal scenario:

**Scenario**: A client wants to store 1GB of data for 6 months with a storage provider.

**Real-World Costs & Timing:**
- **Storage Duration**: 6 months (approximately 180 days)
- **Total Cost**: $18 USD for 6 months of storage
- **Monthly Cost**: $3 USD per month
- **Daily Cost**: $0.10 USD per day
- **Hourly Cost**: ~$0.004 USD per hour

**How This Translates to Payment Rail Attributes:**

```javascript
// Create a payment rail with USDFC (Filecoin's USD stablecoin)
async function createPaymentRail() {
    const tokenAddress = '0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0'; // USDFC on testnet
    const clientAddress = wallet.address;
    const providerAddress = '0x...'; // Storage provider address
    const arbiterAddress = '0x...'; // PDP arbiter for proof verification

    // Payment Rate Calculation:
    // - Filecoin epoch = 30 seconds
    // - Daily cost: $0.10 USD = 0.10 USDFC
    // - Epochs per day: 24 hours √ó 60 minutes √ó 2 epochs/minute = 2,880 epochs
    // - Payment rate: 0.10 USDFC √∑ 2,880 epochs = ~0.0000347 USDFC per epoch
    const paymentRate = ethers.utils.parseUnits('0.0000347', 6); // ~$0.10 per day

    // Lockup Period:
    // - 1 day buffer for proof verification = 2,880 epochs
    const lockupPeriod = 2880; // 1 day in epochs (safety buffer)

    // Fixed Lockup:
    // - Security deposit equivalent to 1 week of payments = $0.70
    const lockupFixed = ethers.utils.parseUnits('0.70', 6); // 1 week security deposit

    const commissionRate = 250; // 2.5% commission to platform operator
    
    // First, approve the Payments contract to spend your tokens
    const token = new ethers.Contract(tokenAddress, tokenAbi, wallet);
    await token.approve(paymentsAddress, ethers.utils.parseUnits('100', 6));
    
    // Deposit funds into the Payments contract
    await payments.deposit(tokenAddress, clientAddress, ethers.utils.parseUnits('10', 6));
    
    // Create the payment rail
    const tx = await payments.createRail(
        tokenAddress,
        clientAddress,
        providerAddress,
        arbiterAddress,
        paymentRate,
        lockupPeriod,
        lockupFixed,
        commissionRate
    );
    
    const receipt = await tx.wait();
    const railId = receipt.events[0].args.railId;
    
    return railId;
}
```

### Settlement Process

Payments are settled using the `settleRail` function:

```solidity
function settleRail(uint256 railId, uint256 settleUpto) external
```

**Parameters:**
- `railId`: The ID of the rail to settle
- `settleUpto`: The epoch up to which to settle payments

**Example:**
```javascript
// Settle payments up to the current epoch
async function settlePayments(railId) {
    const currentEpoch = await provider.getBlockNumber();
    await payments.settleRail(railId, currentEpoch);
}
```

If an arbiter is specified, it will be called to potentially adjust the payment amount based on service performance.

## What is Settlement and How It Occurs

**Settlement** is the process of calculating and transferring the actual payments from the client to the storage provider based on the agreed payment rate and any adjustments made by arbiters.

### How Settlement Works

1. **Continuous Accrual**: Payments accrue continuously at the specified rate (e.g., $0.10 per day)
2. **Periodic Settlement**: Actual token transfers happen when `settleRail()` is called
3. **Arbiter Adjustments**: If a PDP arbiter is configured, it can reduce payments based on proof compliance
4. **Final Transfer**: Tokens are transferred from the client's locked funds to the storage provider

### Settlement Timing

Settlement can occur:
- **On-Demand**: Anyone can call `settleRail()` to trigger settlement up to the current epoch
- **Automatically**: Through scheduled calls or when specific events occur (e.g., proof submission)
- **At Termination**: When a rail is terminated, all outstanding payments are settled

### Settlement Example

```javascript
// Example: Settlement with PDP compliance checking
async function settleWithCompliance(railId) {
    const currentEpoch = await provider.getBlockNumber();

    // When settlement is called, the system:
    // 1. Calculates total payment owed (rate √ó time elapsed)
    // 2. Calls the PDP arbiter to check proof compliance
    // 3. Arbiter may reduce payment if proofs were missed
    // 4. Transfers the final amount to storage provider

    await payments.settleRail(railId, currentEpoch);

    console.log('Settlement completed with PDP compliance verification');
}
```

### Settlement Scenarios

**Scenario 1: Perfect Compliance**
- Client owes $3.00 for 30 days of storage
- Storage provider submitted all required proofs
- **Result**: Full $3.00 is transferred to storage provider

**Scenario 2: Missed Proofs**
- Client owes $3.00 for 30 days of storage
- Storage provider missed proofs for 3 days (10% downtime)
- PDP arbiter reduces payment by 10%
- **Result**: $2.70 is transferred to storage provider, $0.30 remains with client

**Scenario 3: Early Termination**
- Client terminates storage after 15 days
- Only $1.50 in payments have accrued
- **Result**: $1.50 is transferred to storage provider, remaining funds returned to client

### Managing Rails

Rails can be modified and terminated:

```javascript
// Modify the payment rate
async function modifyRailPayment(railId, newRate) {
    await payments.modifyRailPayment(
        railId,
        newRate,  // New payment rate
        0         // No one-time payment
    );
}

// Terminate the rail
async function terminateRail(railId) {
    await payments.terminateRail(railId);
}
```

## Advanced Features

### Scheduled Rate Changes

Payment rates can be scheduled to change at future epochs, allowing for dynamic pricing models:

```javascript
// Schedule a rate change for 3 days from now
async function scheduleRateChange(railId, newRate) {
    const futureEpoch = await provider.getBlockNumber() + 8640; // 3 days = 8640 epochs

    await payments.scheduleRateChange(
        railId,
        futureEpoch,
        ethers.utils.parseUnits(newRate, 6) // New rate in USDFC
    );

    console.log(`Rate change scheduled for epoch ${futureEpoch}`);
}
```

### Commission Payments

The system supports commission payments to platform operators:

```javascript
// Create a rail with 5% commission to platform
async function createRailWithCommission() {
    const railId = await payments.createRail(
        tokenAddress,
        clientAddress,
        providerAddress,
        arbiterAddress,
        paymentRate,
        lockupPeriod,
        lockupFixed,
        500 // 5% commission (500 basis points)
    );

    return railId;
}
```

## Integration with PDP

The Payments system integrates with the [PDP (Provable Data Possession)](pdp-overview.md) system through the arbiter mechanism:

1. A client creates a payment rail with an arbiter that monitors PDP compliance
2. The PDP system records proof submissions and faults
3. When settling payments, the arbiter checks PDP compliance records
4. The arbiter adjusts payment amounts based on the storage provider's performance

For a detailed guide on integrating Payments with PDP, see [Integrating PDP with Payments](integration-guide.md).

## Deployed Contracts

The Payments contract is deployed on Filecoin Mainnet and Calibration Testnet.

**Mainnet**
- **Payments Contract**: `0x8BA1f109551bD432803012645Ac136ddd64DBA72`

**Calibration Testnet**
- **Payments Contract**: `0xc5e1333D3cD8a3F1f8A9f9A116f166cBD0bA307A`

## Security Considerations

1. **Fund Safety**: Funds are locked in the contract and can only be withdrawn by the rightful owner
2. **Rate Limiting**: Changes to payment rates have time delays to prevent sudden draining of funds
3. **Arbitration Constraints**: Arbiters can only reduce payments, not increase them
4. **Termination Safeguards**: Terminated rails still honor the lockup period

## Next Steps

- Learn about the [PDP System](pdp-overview.md)
- Understand how to [Integrate PDP with Payments](integration-guide.md)
- Follow the [Quick Start Guide](quick-start.md)
- Explore the [Hot Vault Example](examples/hot-vault.md)
</file>

<file path="docs/pdp-overview.md">
# Provable Data Possession (PDP) System

## Overview

Provable Data Possession (PDP) is a cryptographic protocol that allows a client to verify that a storage provider still possesses the data they claim to be storing, without having to download the entire dataset. This is particularly important in decentralized storage networks like Filecoin, where clients need assurance that their data is being stored correctly over time.

The PDP system provides a robust implementation of this protocol on the Filecoin network, enabling verifiable storage with customizable Service Level Agreements (SLAs).

## Key Features

- **Efficient Verification**: Verify data possession without retrieving the entire dataset
- **Customizable SLAs**: Define specific proof frequency and requirements
- **Fault Detection**: Automatically detect when storage providers fail to prove possession
- **Integration with Payments**: Connect proof compliance with payment adjustments
- **Scalable Architecture**: Handle multiple proof sets and storage providers

## Core Components

### PDPVerifier Contract

The central contract that manages proof sets and verifies proofs. It:
- Creates and manages proof sets
- Generates challenges for storage providers
- Verifies submitted proofs
- Tracks compliance with SLA terms

```solidity
function createProofSet(address listenerAddr, bytes calldata extraData) public payable returns (uint256)
```

**Parameters:**
- `listenerAddr`: Address of the PDP service contract (e.g., SimplePDPService)
- `extraData`: Additional data to be passed to the listener (often contains payment information)

**Returns:**
- `uint256`: The ID of the newly created proof set

**Example:**
```javascript
// Encode payment information in extra data
const extraData = ethers.utils.defaultAbiCoder.encode(
    ['uint256', 'address'],
    [railId, paymentsContractAddress]
);

// Calculate the sybil fee
const sybilFee = await pdpVerifier.sybilFee();

// Create a proof set
const tx = await pdpVerifier.createProofSet(
    pdpServiceAddress,
    extraData,
    { value: sybilFee }
);

// Get the proof set ID from the event logs
const receipt = await tx.wait();
const proofSetId = receipt.events[0].args.setId;
```

### SimplePDPService Contract

Implements the SLA terms for the PDP system:
- Defines proof frequency (maximum proving period)
- Specifies the challenge window during which proofs must be submitted
- Determines the number of challenges required per proof
- Records faults when proofs are missed or invalid

```solidity
function getMaxProvingPeriod() public pure returns (uint64)
```

**Returns:**
- `uint64`: The maximum number of epochs between proofs (typically 2880, approximately 1 day)

```solidity
function getChallengeWindow() public pure returns (uint64)
```

**Returns:**
- `uint64`: The number of epochs at the end of a proving period during which proofs must be submitted

```solidity
function getFaultCount(uint256 proofSetId, uint256 fromEpoch, uint256 toEpoch) external view returns (uint256)
```

**Parameters:**
- `proofSetId`: The ID of the proof set
- `fromEpoch`: The starting epoch for the fault count
- `toEpoch`: The ending epoch for the fault count

**Returns:**
- `uint256`: The number of faults recorded for the proof set in the specified epoch range

### PDPListener Interface

An interface that allows for extensible applications to use the PDP verification contract:
- Notifies when proof sets are created or deleted
- Reports when roots are added or scheduled for removal
- Informs when possession is proven
- Signals the start of a new proving period

```solidity
interface PDPListener {
    function proofSetCreated(uint256 proofSetId, address creator, bytes calldata extraData) external;
    function possessionProven(uint256 proofSetId, uint256 challengedLeafCount, uint256 seed, uint256 challengeCount) external;
    // Additional functions...
}
```

## System Flow Diagram

The following sequence diagram illustrates the complete flow of data and payments through the PDP system, from initial setup through settlement:

```mermaid
sequenceDiagram
    participant Client
    participant PDPVerifier
    participant SimplePDPService
    participant PaymentsContract
    participant StorageProvider

    Note over Client, StorageProvider: Setup Phase
    Client->>PaymentsContract: Create payment rail with USDFC deposit
    PaymentsContract-->>Client: Return railId

    Client->>PDPVerifier: createProofSet(pdpService, extraData[railId, paymentsAddr])
    PDPVerifier->>SimplePDPService: proofSetCreated(proofSetId, client, extraData)
    SimplePDPService->>PaymentsContract: Initialize payment escrow for proofSetId
    PDPVerifier-->>Client: Return proofSetId

    Note over Client, StorageProvider: Data Storage Phase
    Client->>StorageProvider: Store data (off-chain)
    StorageProvider->>PDPVerifier: addRoots(proofSetId, dataRoots)
    PDPVerifier-->>StorageProvider: Confirm roots added

    Note over Client, StorageProvider: Proving Phase (Recurring)
    loop Every Proving Period (24 hours)
        PDPVerifier->>PDPVerifier: Generate challenges for proofSetId
        StorageProvider->>PDPVerifier: provePossession(proofSetId, proofs)

        alt Valid Proof Submitted
            PDPVerifier->>SimplePDPService: possessionProven(proofSetId, ...)
            SimplePDPService->>PaymentsContract: Release payment to StorageProvider
            PaymentsContract-->>StorageProvider: Transfer USDFC payment
        else Invalid/Missing Proof
            PDPVerifier->>SimplePDPService: Record fault for proofSetId
            SimplePDPService->>PaymentsContract: Adjust payment (reduce/withhold)
        end
    end

    Note over Client, StorageProvider: Settlement Phase
    Client->>PaymentsContract: settleRail(railId)
    PaymentsContract->>PaymentsContract: Calculate final balances
    PaymentsContract-->>Client: Return remaining USDFC
    PaymentsContract-->>StorageProvider: Final payment settlement
```

## How It Works

### 1. Creating a Proof Set

A client creates a proof set in the PDPVerifier contract, specifying which SLA contract to use and providing signed payment information.

```javascript
// Create a proof set with payment information
async function createProofSet(pdpServiceAddress, railId, paymentsAddress) {
    // Encode payment information
    const extraData = ethers.utils.defaultAbiCoder.encode(
        ['uint256', 'address'],
        [railId, paymentsAddress]
    );
    
    // Get the sybil fee
    const sybilFee = await pdpVerifier.sybilFee();
    
    // Create the proof set
    const tx = await pdpVerifier.createProofSet(
        pdpServiceAddress,
        extraData,
        { value: sybilFee }
    );
    
    const receipt = await tx.wait();
    return receipt.events[0].args.setId;
}
```

### 2. Adding Data

The storage provider adds data roots to the proof set, which represent the data they're storing.

```javascript
// Add data roots to a proof set
async function addRoots(proofSetId, cid, dataSize) {
    // Prepare the root data
    const rootData = [{
        root: {
            version: 1,
            codec: 0x71, // dag-cbor
            hash: 0x12, // sha2-256
            size: 32,
            data: cidBytes // Bytes representation of the CID
        },
        rawSize: dataSize
    }];
    
    // Add the roots to the proof set
    const tx = await pdpVerifier.addRoots(
        proofSetId,
        rootData,
        "0x" // No extra data
    );
    
    await tx.wait();
}
```

### 3. Challenge Generation

The system generates random challenges based on the data in the proof set.

### 4. Submitting Proofs

The storage provider must submit valid proofs within specific time windows.

```javascript
// Submit proofs for a proof set
async function submitProofs(proofSetId) {
    // Get the next challenge epoch
    const nextChallengeEpoch = await pdpVerifier.getNextChallengeEpoch(proofSetId);
    
    // Wait until the challenge epoch
    // ... (implementation depends on your environment)
    
    // Generate proofs for the challenges
    const proofs = await generateProofs(proofSetId);
    
    // Calculate the proof fee
    const proofFee = await pdpVerifier.calculateProofFee(proofSetId, estimatedGasFee);
    
    // Submit the proofs
    const tx = await pdpVerifier.provePossession(
        proofSetId,
        proofs,
        { value: proofFee }
    );
    
    await tx.wait();
}
```

### 5. Verification

The PDPVerifier contract verifies the submitted proofs.

### 6. Fault Recording

If a storage provider fails to submit valid proofs on time, the system records a fault.

## Deployed Contracts

The PDP service contract and the PDP verifier contracts are deployed on Filecoin Mainnet and Calibration Testnet.

**Mainnet**
- **PDP Verifier**: `0x9C65E8E57C98cCc040A3d825556832EA1e9f4Df6`
- **PDP Service**: `0x805370387fA5Bd8053FD8f7B2da4055B9a4f8019`

**Calibration Testnet**
- **PDP Verifier**: `0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC`
- **PDP Service**: `0x6170dE2b09b404776197485F3dc6c968Ef948505`

## Integration with Payments

The PDP system integrates with the [Payments system](payments-overview.md) through:

1. **Arbiter Contracts**: These contracts use fault records from the PDP system to determine payment adjustments.

2. **Payment Rails**: Payments flow from clients to storage providers through these rails, with adjustments based on PDP compliance.

3. **Settlement**: When a rail is settled, the arbiter can reduce payments for providers who have failed to meet their PDP obligations.

For a detailed guide on integrating PDP with Payments, see [Integrating PDP with Payments](integration/pdp-payments.md).

## Security Considerations

The PDP system includes several security features:

- **Challenge Finality Delay**: Prevents randomness manipulation by storage providers
- **Sybil Fees**: Prevents spam attacks on the system
- **Proof Fees**: Compensates for verification costs
- **Cryptographic Verification**: Ensures proofs are valid and correspond to the correct data

## Next Steps

- Learn about the [Payments System](payments-overview.md)
- Understand how to [Integrate PDP with Payments](integration-guide.md)
- Follow the [Quick Start Guide](quick-start.md)
- Explore the [Hot Vault Example](examples/hot-vault.md)
</file>

<file path="docs/quick-start.md">
# Step 3: Install Synapse SDK

This is the third step in your Golden Path. You'll create a local application using the Synapse SDK to interact with Filecoin storage providers and the PDP-Payments system.

## Prerequisites

- ‚úÖ Completed [Step 1: Setup Wallet & USDFC](setup.md)
- ‚úÖ Completed [Step 2: Configure JSON-RPC](setup-detailed.md)
- **Node.js** (v18 or later) installed
- **npm** (v9 or later) installed

## 1. Understanding the Synapse SDK

The Synapse SDK provides a simple JavaScript/TypeScript interface for:
- **Binary Storage**: Store and retrieve files up to specified size limits
- **PDP Verification**: Cryptographic proofs ensure your data remains available
- **Payment Management**: Deposit, withdraw, and settle payments in USDFC
- **Optional CDN**: Pay extra for CDN-accelerated retrievals

### Key Features
- Simple API for file upload/download
- Automatic payment handling
- Progress tracking for uploads
- Built-in proof verification

## 2. Create Your Local App

### Initialize a New Project

```bash
# Create a new directory for your app
mkdir my-storage-app
cd my-storage-app

# Initialize npm project
npm init -y

# Install the Synapse SDK (currently using mock implementation)
npm install synapse-sdk

# Install additional dependencies
npm install dotenv fs-extra
```

### Project Structure

Your project should look like this:
```
my-storage-app/
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ upload-file.js
‚îî‚îÄ‚îÄ files/
    ‚îî‚îÄ‚îÄ (your test files)
```

## 3. Configure Your Environment

### Create Environment File

```bash
touch .env
```

### Add Configuration

```bash
# Wallet Configuration (from Step 2)
PRIVATE_KEY=your_private_key_here_without_0x_prefix

# Synapse SDK Configuration
SYNAPSE_PRIVATE_KEY=your_private_key_here_without_0x_prefix
SYNAPSE_WITH_CDN=true
SYNAPSE_RPC_API=https://api.calibration.node.glif.io/rpc/v1
SYNAPSE_SERVICE_CONTRACT=0x6170dE2b09b404776197485F3dc6c968Ef948505
```

## 4. Create Your First Synapse App

### Basic Setup Script

Create `index.js`:

```javascript
// index.js
require('dotenv').config();
const { Synapse } = require('synapse-sdk');
const fs = require('fs-extra');
const path = require('path');

async function main() {
  console.log('üöÄ Starting Synapse SDK Demo...');

  // Initialize Synapse
  const synapse = new Synapse({
    privateKey: process.env.SYNAPSE_PRIVATE_KEY,
    withCDN: process.env.SYNAPSE_WITH_CDN === 'true',
    rpcAPI: process.env.SYNAPSE_RPC_API,
    serviceContract: process.env.SYNAPSE_SERVICE_CONTRACT
  });

  console.log('‚úÖ Synapse SDK initialized');

  // Check and manage balance
  console.log('üí∞ Checking balance...');
  let balance = await synapse.balance();
  console.log(`Current balance: ${balance} USDFC`);

  if (balance < 50) {
    console.log('üí≥ Depositing funds...');
    await synapse.deposit(50 - balance);
    balance = await synapse.balance();
    console.log(`New balance: ${balance} USDFC`);
  }

  // Create a storage service instance
  console.log('üóÑÔ∏è Creating storage service...');
  const storage = await synapse.createStorage();
  console.log('‚úÖ Storage service created');

  console.log('\nüéâ Setup complete! Ready to store files.');
  console.log('\nNext steps:');
  console.log('1. Run: node upload-file.js');
  console.log('2. Follow the prompts to upload a file');
}

main()
  .then(() => process.exit(0))
  .catch(error => {
    console.error('‚ùå Error:', error.message);
    process.exit(1);
  });
```

## 5. Create File Upload Script

### File Upload Implementation

Create `upload-file.js`:

```javascript
// upload-file.js
require('dotenv').config();
const { Synapse } = require('synapse-sdk');
const fs = require('fs-extra');
const path = require('path');

async function uploadFile() {
  try {
    console.log('üìÅ File Upload Demo');

    // Initialize Synapse
    const synapse = new Synapse({
      privateKey: process.env.SYNAPSE_PRIVATE_KEY,
      withCDN: process.env.SYNAPSE_WITH_CDN === 'true'
    });

    // Create storage service
    const storage = await synapse.createStorage();

    // Create test file if it doesn't exist
    const filesDir = path.join(__dirname, 'files');
    await fs.ensureDir(filesDir);

    const testFilePath = path.join(filesDir, 'test-image.txt');
    if (!await fs.pathExists(testFilePath)) {
      const testContent = `Hello from Synapse SDK!
This is a test file uploaded on ${new Date().toISOString()}
File size: ${Math.random() * 1000} bytes
Random data: ${Math.random().toString(36).substring(7)}`;

      await fs.writeFile(testFilePath, testContent);
      console.log(`üìù Created test file: ${testFilePath}`);
    }

    // Read file as binary data
    const fileBuffer = await fs.readFile(testFilePath);
    const data = new Uint8Array(fileBuffer);

    console.log(`üì§ Uploading file: ${path.basename(testFilePath)} (${data.length} bytes)`);

    // Upload binary data
    const uploadTask = storage.upload(data);

    // Track upload progress
    console.log('üîÑ Generating CommP...');
    const commp = await uploadTask.commp();
    console.log(`‚úÖ Generated CommP: ${commp}`);

    console.log('üè™ Finding storage provider...');
    const sp = await uploadTask.store();
    console.log(`‚úÖ Stored with provider: ${sp}`);

    console.log('‚è≥ Finalizing upload...');
    const txHash = await uploadTask.done();
    console.log(`‚úÖ Upload complete! Transaction: ${txHash}`);

    // Store the CommP for later retrieval
    const metadataPath = path.join(filesDir, 'uploaded-files.json');
    let metadata = {};

    if (await fs.pathExists(metadataPath)) {
      metadata = await fs.readJson(metadataPath);
    }

    metadata[path.basename(testFilePath)] = {
      commp: commp,
      uploadDate: new Date().toISOString(),
      txHash: txHash,
      size: data.length
    };

    await fs.writeJson(metadataPath, metadata, { spaces: 2 });
    console.log(`üìã Metadata saved to: ${metadataPath}`);

    return { commp, txHash };

  } catch (error) {
    console.error('‚ùå Upload failed:', error.message);
    throw error;
  }
}

// Run if called directly
if (require.main === module) {
  uploadFile()
    .then(({ commp, txHash }) => {
      console.log('\nüéâ Upload successful!');
      console.log(`CommP: ${commp}`);
      console.log(`Transaction: ${txHash}`);
      console.log('\nNext: Try downloading with node download-file.js');
    })
    .catch(error => {
      console.error('‚ùå Error:', error.message);
      process.exit(1);
    });
}

module.exports = { uploadFile };
```

## 6. Test Your Setup

### Run the Basic Setup

```bash
node index.js
```

**Expected Output:**
```
üöÄ Starting Synapse SDK Demo...
[Mock] Synapse initialized with options: { withCDN: true, rpcAPI: 'https://api.calibration.node.glif.io/rpc/v1', serviceContract: '0x6170dE2b09b404776197485F3dc6c968Ef948505' }
‚úÖ Synapse SDK initialized
üí∞ Checking balance...
[Mock] Checking balance...
Current balance: 100 USDFC
üóÑÔ∏è Creating storage service...
[Mock] Creating storage service...
[Mock] Storage service created with proofSetId: ps_abc123, SP: f01234
‚úÖ Storage service created

üéâ Setup complete! Ready to store files.

Next steps:
1. Run: node upload-file.js
2. Follow the prompts to upload a file
```

### Run the File Upload

```bash
node upload-file.js
```

**Expected Output:**
```
üìÅ File Upload Demo
üìù Created test file: /path/to/files/test-image.txt
üì§ Uploading file: test-image.txt (123 bytes)
üîÑ Generating CommP...
[Mock] Generating CommP for 123 bytes...
‚úÖ Generated CommP: baga6ea4seaqao7s73y24kcutaosvacpdjgfe5pw2zvogkbo6kqj375dposbngqq
üè™ Finding storage provider...
[Mock] Finding storage provider...
‚úÖ Stored with provider: f01234
‚è≥ Finalizing upload...
[Mock] Finalizing upload...
‚úÖ Upload complete! Transaction: 0x1234567890abcdef...
üìã Metadata saved to: /path/to/files/uploaded-files.json

üéâ Upload successful!
CommP: baga6ea4seaqao7s73y24kcutaosvacpdjgfe5pw2zvogkbo6kqj375dposbngqq
Transaction: 0x1234567890abcdef...

Next: Try downloading with node download-file.js
```

## 7. Understanding the SDK Flow

### What Just Happened?

1. **Initialization**: The SDK connected to the Filecoin network using your configuration
2. **Balance Check**: Verified you have sufficient USDFC for storage payments
3. **Storage Service**: Created a storage service instance linked to a storage provider
4. **File Upload**:
   - Generated a CommP (Commitment of Piece) - a cryptographic proof of your data
   - Found an available storage provider
   - Initiated the storage deal
   - Returned a transaction hash for verification

### Key Concepts

- **CommP**: A unique identifier for your data that enables proof verification
- **Storage Provider (SP)**: The entity that will store your data
- **Proof Set**: A collection of data that will be proven together
- **Payment Rail**: The mechanism for paying the storage provider

## Troubleshooting

### Common Issues

**SDK Import Error**
```bash
npm install synapse-sdk --save
```

**Environment Variables Not Found**
- Ensure your `.env` file is in the project root
- Check that variable names match exactly

**Balance Issues**
- Verify you have USDFC tokens from Step 1
- Check your wallet connection

**File Upload Fails**
- Ensure the `files/` directory exists
- Check file permissions

## Next Steps

üéâ **Congratulations!** You've completed Step 3 of the Golden Path.

**Next**: [Step 4: Hot Vault Demo Reference](examples/hot-vault.md) - Explore a complete implementation with code snippets

## Additional Resources

- [Synapse SDK Documentation](https://github.com/FilOzone/synapse-sdk)
- [Understanding CommP](https://docs.filecoin.io/basics/the-blockchain/proofs/)
- [Storage Provider Guide](https://docs.filecoin.io/storage-providers/basics/)
</file>

<file path="docs/setup-detailed.md">
# Step 2: Configure JSON-RPC for Filecoin

This is the second step in your Golden Path. You'll set up Filecoin JSON-RPC connections to interact with the blockchain and prepare your development environment.

## Prerequisites

- ‚úÖ Completed [Step 1: Setup Wallet & USDFC](setup.md)
- **Node.js** (v18 or later) installed
- **npm** (v9 or later) installed
- **Git** installed
- **Code editor** (VS Code recommended)

## 1. Understanding Filecoin JSON-RPC

Filecoin provides JSON-RPC APIs for interacting with the blockchain. There are two main types:

### Filecoin JSON-RPC API
- **Purpose**: Native Filecoin operations (storage deals, mining, etc.)
- **Endpoint**: `https://api.calibration.node.glif.io/rpc/v1`
- **Use cases**: Storage provider interactions, deal making

### Ethereum-compatible JSON-RPC API
- **Purpose**: Smart contract interactions (what we'll use for PDP-Payments)
- **Endpoint**: `https://api.calibration.node.glif.io/rpc/v1` (same endpoint, different methods)
- **Use cases**: Contract deployment, token transfers, PDP operations

## 2. Available RPC Endpoints

### Why Multiple Endpoints?

Different RPC providers offer various features and reliability levels. We recommend **Glif** as the primary choice, with others as backups if you experience issues.

### Recommended Endpoints for Calibration Testnet

**Glif (Primary Choice)**
- HTTPS: `https://api.calibration.node.glif.io/rpc/v1`
- WebSocket: `wss://wss.calibration.node.glif.io/apigw/lotus/rpc/v1`
- **Why recommended**: Guarantees 2000 latest blocks, most reliable for development
- **Use this for**: All Golden Path steps

**Ankr (Backup)**
- HTTPS: `https://rpc.ankr.com/filecoin_testnet`
- **Use if**: Glif is experiencing issues

**ChainupCloud (Backup)**
- HTTPS: `https://filecoin-calibration.chainup.net/rpc/v1`
- **Use if**: Both Glif and Ankr are unavailable

## 3. Set Up Your Development Environment

### Create Your Project Directory

For the Golden Path, you can start with a fresh project or use our examples:

**Option A: Fresh Project (Recommended)**
```bash
mkdir my-pdp-app
cd my-pdp-app
npm init -y
```

**Option B: Clone Examples Repository**
```bash
git clone https://github.com/timfong888/pdp-payment.git
cd pdp-payment
```
*Note: This repo contains documentation and examples, but you'll likely want your own project structure for production apps.*

### Install Node.js Dependencies

**For Node.js scripts (like our connection test):**
```bash
npm install viem dotenv
```

**For React/Next.js apps (like Hot Vault demo):**
```bash
npm install wagmi @tanstack/react-query viem dotenv
```

**Library explanation:**
- **viem**: Low-level Ethereum library - use this for Node.js scripts and backend
- **wagmi**: React hooks for Ethereum - use this for frontend React/Next.js apps
- **@tanstack/react-query**: Required by Wagmi for data fetching
- **dotenv**: Environment variable management

> **Our preference**: We use **viem** for backend/scripts and **wagmi** (which is built on viem) for React frontends. You can use whatever library you prefer, but this documentation focuses on the viem/wagmi ecosystem.

## 4. Configure Environment Variables

### Create Environment File

```bash
touch .env
```

### Add Configuration

Add the following to your `.env` file:

```bash
# Wallet Configuration
PRIVATE_KEY=your_private_key_here_without_0x_prefix

# Filecoin Calibration Testnet RPC
RPC_URL=https://api.calibration.node.glif.io/rpc/v1

# Contract Addresses (Calibration Testnet)
PDP_VERIFIER_ADDRESS=0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC
PDP_SERVICE_ADDRESS=0x6170dE2b09b404776197485F3dc6c968Ef948505
PAYMENTS_ADDRESS=0xc5e1333D3cD8a3F1f8A9f9A116f166cBD0bA307A

# Token Addresses
USDFC_TOKEN_ADDRESS=0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0

# Network Configuration
CHAIN_ID=314159
NETWORK_NAME=calibration
```

### Get Your Private Key

1. Open MetaMask
2. Click the three dots menu ‚Üí Account details
3. Click "Export Private Key"
4. Enter your password
5. Copy the private key (remove the `0x` prefix)
6. Paste into your `.env` file

**üìö Official Guide**: [MetaMask: How to export an account's private key](https://support.metamask.io/hc/en-us/articles/360015289632-How-to-export-an-account-s-private-key)

**‚ö†Ô∏è Security Warning**: Never commit your `.env` file to version control!

## 5. Test Your JSON-RPC Connection

### Create a Connection Test Script

Create `test-connection.js`:

```javascript
// test-connection.js
require('dotenv').config();
const { createPublicClient, createWalletClient, http, formatEther, formatUnits } = require('viem');
const { privateKeyToAccount } = require('viem/accounts');

// Filecoin Calibration chain config
const filecoinCalibration = {
  id: 314159,
  name: 'Filecoin Calibration',
  network: 'filecoin-calibration',
  nativeCurrency: {
    decimals: 18,
    name: 'testnet FIL',
    symbol: 'tFIL',
  },
  rpcUrls: {
    default: {
      http: [process.env.RPC_URL],
    },
  },
  blockExplorers: {
    default: { name: 'FilFox', url: 'https://calibration.filfox.info' },
  },
};

async function testConnection() {
  try {
    // Create public client for reading
    const publicClient = createPublicClient({
      chain: filecoinCalibration,
      transport: http(),
    });

    console.log('üîó Testing Filecoin JSON-RPC connection...');

    // Get current block
    const blockNumber = await publicClient.getBlockNumber();
    console.log(`üì¶ Current block number: ${blockNumber}`);
    console.log(`‚úÖ Connected to network: ${filecoinCalibration.name} (Chain ID: ${filecoinCalibration.id})`);

    // Create wallet client
    const account = privateKeyToAccount(`0x${process.env.PRIVATE_KEY}`);
    console.log(`üëõ Wallet address: ${account.address}`);

    // Check tFIL balance
    const filBalance = await publicClient.getBalance({ address: account.address });
    console.log(`üí∞ tFIL balance: ${formatEther(filBalance)} tFIL`);

    // Test USDFC token balance
    const usdcBalance = await publicClient.readContract({
      address: process.env.USDFC_TOKEN_ADDRESS,
      abi: [
        {
          name: 'balanceOf',
          type: 'function',
          stateMutability: 'view',
          inputs: [{ name: 'owner', type: 'address' }],
          outputs: [{ name: '', type: 'uint256' }],
        },
        {
          name: 'symbol',
          type: 'function',
          stateMutability: 'view',
          inputs: [],
          outputs: [{ name: '', type: 'string' }],
        },
        {
          name: 'decimals',
          type: 'function',
          stateMutability: 'view',
          inputs: [],
          outputs: [{ name: '', type: 'uint8' }],
        },
      ],
      functionName: 'balanceOf',
      args: [account.address],
    });

    const usdcSymbol = await publicClient.readContract({
      address: process.env.USDFC_TOKEN_ADDRESS,
      abi: [{ name: 'symbol', type: 'function', stateMutability: 'view', inputs: [], outputs: [{ name: '', type: 'string' }] }],
      functionName: 'symbol',
    });

    console.log(`üíµ ${usdcSymbol} balance: ${formatUnits(usdcBalance, 6)} ${usdcSymbol}`);

    console.log('\nüéâ JSON-RPC connection test successful!');

  } catch (error) {
    console.error('‚ùå Connection test failed:', error.message);
    process.exit(1);
  }
}

testConnection();
```

### Run the Test

```bash
node test-connection.js
```

**Expected Output:**
```
üîó Testing Filecoin JSON-RPC connection...
üì¶ Current block number: 1234567n
‚úÖ Connected to network: Filecoin Calibration (Chain ID: 314159)
üëõ Wallet address: 0x1234...abcd
üí∞ tFIL balance: 50.0 tFIL
üíµ USDFC balance: 30.0 USDFC

üéâ JSON-RPC connection test successful!
```

## 6. Understanding JSON-RPC Methods

### Golden Path Essential Methods

These are the key methods you'll use in the Golden Path:

```javascript
// Check connection and get block number
await publicClient.getBlockNumber()

// Check wallet balance
await publicClient.getBalance({ address })

// Read contract data (like token balances)
await publicClient.readContract({
  address: contractAddress,
  abi: contractAbi,
  functionName: 'balanceOf',
  args: [userAddress]
})
```

### For Complete Method Reference

- **Viem Documentation**: [viem.sh/docs/actions/public/introduction](https://viem.sh/docs/actions/public/introduction)
- **Wagmi Documentation**: [wagmi.sh/react/api/hooks](https://wagmi.sh/react/api/hooks)
- **Filecoin JSON-RPC**: [docs.filecoin.io/reference/json-rpc/](https://docs.filecoin.io/reference/json-rpc/)

## Troubleshooting

### Connection Issues
- **RPC timeout**: Try a different endpoint (Ankr or ChainupCloud)
- **Network mismatch**: Ensure Chain ID is 314159
- **Rate limiting**: Use your own RPC node for heavy usage

### Authentication Errors
- **Invalid private key**: Ensure no `0x` prefix in `.env`
- **Wrong network**: Verify you're on Calibration testnet
- **Insufficient gas**: Ensure you have tFIL for transactions

### Contract Interaction Issues
- **Contract not found**: Verify contract addresses are correct
- **Method not found**: Check ABI matches deployed contract
- **Transaction reverted**: Check contract state and parameters

## Next Steps

üéâ **Congratulations!** You've completed Step 2 of the Golden Path.

**Next**: [Step 3: Install Synapse SDK](quick-start.md) - Create a local app using the Synapse SDK

## Additional Resources

- [Filecoin JSON-RPC Documentation](https://docs.filecoin.io/reference/json-rpc/)
- [Wagmi Documentation](https://wagmi.sh/)
- [Viem Documentation](https://viem.sh/)
- [Filecoin EVM Documentation](https://docs.filecoin.io/smart-contracts/fundamentals/)
</file>

<file path="docs/setup.md">
# Step 1: Setup Wallet & USDFC Tokens

This is the first step in your Golden Path to success with PDP-Payments. You'll set up MetaMask with the Filecoin Calibration testnet and obtain USDFC stablecoin tokens for payments.

## Prerequisites

- **Google Chrome browser** (recommended for best compatibility)
- **MetaMask browser extension** installed
- **Disable all other wallet extensions** (to avoid conflicts)

## 1. Install and Configure MetaMask

### Install MetaMask
1. Visit [metamask.io](https://metamask.io/download.html)
2. Install the MetaMask extension for Chrome
3. Create a new wallet or import an existing one
4. **Important**: Disable all other wallet extensions to prevent conflicts

### Add Filecoin Calibration Testnet
1. Visit [Chainlist for Filecoin Calibration](https://chainlist.org/chain/314159)
2. Click "Connect Wallet" and approve the connection
3. Click "Add to MetaMask" for Filecoin Calibration Testnet
4. Approve adding the network in MetaMask

**Manual Setup (if needed):**
- Network Name: `Filecoin ‚Äî Calibration Testnet`
- RPC URL: `https://api.calibration.node.glif.io/rpc/v1`
- Chain ID: `314159`
- Currency Symbol: `tFIL`
- Block Explorer: `https://calibration.filfox.info/`

## 2. Get Test FIL (tFIL) Tokens

1. Copy your wallet address from MetaMask
2. Visit the [Calibration Faucet](https://faucet.calibnet.chainsafe-fil.io/)
3. Paste your address and click "Send Funds"
4. You'll receive 100 tFIL (can request every 12 hours, max 2 times)
5. Verify the tokens appear in your MetaMask wallet

## 3. Get USDFC Stablecoin Tokens

USDFC is the stablecoin used for payments in the PDP system. You'll mint USDFC by depositing tFIL as collateral.

> **‚úÖ Testnet Confirmation**: The USDFC protocol at [usdfc.secured.finance](https://usdfc.secured.finance/#/) **does support Filecoin Calibration testnet**. When you connect, make sure you're on the "Filecoin ‚Äî Calibration Network" to mint testnet USDFC using your testnet tFIL.

### Access the USDFC Protocol
1. Visit [usdfc.secured.finance](https://usdfc.secured.finance/#/)
2. **Important**: Ensure you're connected to "Filecoin ‚Äî Calibration Network" (not mainnet)
3. Click "Connect Wallet" and select MetaMask

### Mint USDFC Tokens
1. Click "Open Trove" in the top-left section
2. **Set Collateral Amount**: Enter amount of tFIL to deposit (e.g., 50 tFIL)
3. **Set Borrow Amount**: Enter USDFC to mint (keep collateral ratio above 150%)
   - Example: 50 tFIL ‚Üí mint ~30 USDFC (167% collateral ratio)
4. Review the details:
   - **Liquidation Reserve**: 20 USDFC (refundable when closing trove)
   - **Borrowing Fee**: 0.5% one-time fee
   - **Total Debt**: Borrow amount + reserve + fee
5. Click "Confirm" and approve the MetaMask transaction

### Add USDFC Token to MetaMask
1. In MetaMask, click "Import tokens"
2. Enter USDFC contract address: `0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0`
3. Token symbol: `USDFC`
4. Decimals: `18`
5. Click "Add Custom Token"

## 4. Verify Your Setup

You should now have:
- ‚úÖ MetaMask connected to Filecoin Calibration testnet
- ‚úÖ tFIL tokens in your wallet (for gas fees)
- ‚úÖ USDFC tokens in your wallet (for storage payments)
- ‚úÖ USDFC token visible in MetaMask

**Recommended Amounts:**
- **Minimum**: 10 tFIL + 10 USDFC
- **Recommended**: 50 tFIL + 30 USDFC

## Troubleshooting

### MetaMask Issues
- **Wrong network**: Ensure you're on "Filecoin ‚Äî Calibration Testnet"
- **No tokens showing**: Try refreshing MetaMask or re-importing the USDFC token
- **Transaction fails**: Ensure you have enough tFIL for gas fees

### Faucet Issues
- **Rate limited**: Wait 12 hours between requests
- **Need more tokens**: Contact the team on [Filecoin Slack](https://filecoin.io/slack) #fil-pdp channel

### USDFC Minting Issues
- **Collateral ratio too low**: Increase tFIL deposit or decrease USDFC borrow amount
- **Transaction fails**: Ensure you have enough tFIL for gas fees

## Next Steps

üéâ **Congratulations!** You've completed Step 1 of the Golden Path.

**Next**: [Step 2: Configure JSON-RPC](setup-detailed.md) - Set up Filecoin JSON-RPC for blockchain interactions

## Additional Resources

- [USDFC Stablecoin Documentation](https://docs.secured.finance/)
- [Filecoin Calibration Network Info](https://docs.filecoin.io/networks/calibration/)
- [MetaMask Setup Guide](https://docs.filecoin.io/basics/assets/metamask-setup/)
</file>

<file path="examples/hotvault-demo/client/public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="examples/hotvault-demo/client/public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="examples/hotvault-demo/client/public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="examples/hotvault-demo/client/public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="examples/hotvault-demo/client/public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="examples/hotvault-demo/client/src/app/dashboard/_components/CostBanner.tsx">
import { Card } from "@/components/ui/card";
import { Typography } from "@/components/ui/typography";
import {
  DollarSign,
  Lock,
  HardDrive,
  Calculator,
  ChevronDown,
  ChevronUp,
  Upload,
  InfoIcon,
} from "lucide-react";
import { formatFileSize } from "@/lib/utils";
import { useState } from "react";
import { Button } from "@/components/ui/button";
import { usePayment } from "@/contexts/PaymentContext";
import * as Constants from "@/lib/constants";

interface FileInfo {
  id: number;
  filename: string;
  size: number;
}

interface CostBannerProps {
  fileSizeGB?: number;
  existingFiles?: FileInfo[];
  onSelectFile?: () => void;
}

export const CostBanner: React.FC<CostBannerProps> = ({
  fileSizeGB = 0,
  existingFiles = [],
  onSelectFile,
}) => {
  const [isExpanded, setIsExpanded] = useState(true);
  const {
    paymentStatus,
    approveToken,
    depositFunds,
    approveServiceOperator,
    refreshPaymentSetupStatus,
    initiateProofSetCreation,
  } = usePayment();

  // Use the same constants as defined in the smart contract
  const costPerGBPerMonth = Constants.STORAGE_RATE_PER_GB || 2;
  const lockPeriodDays = Constants.LOCK_PERIOD_DAYS || 10;
  const daysInMonth = 30;

  // Convert bytes to GB for calculations
  const bytesToGB = (bytes: number) => bytes / (1024 * 1024 * 1024);

  // Calculate costs using the same method as the smart contract
  const calculateMonthlyCost = (sizeGB: number) => {
    if (!sizeGB) return "0";
    // Convert to the same precision as used in the smart contract
    return (sizeGB * costPerGBPerMonth).toFixed(5);
  };

  const calculateLockedAmount = (sizeGB: number) => {
    const monthlyCost = parseFloat(calculateMonthlyCost(sizeGB));
    // Use the same calculation method as in the smart contract
    return ((monthlyCost * lockPeriodDays) / daysInMonth).toFixed(5);
  };

  const monthlyCost = calculateMonthlyCost(fileSizeGB);
  const lockedAmount = calculateLockedAmount(fileSizeGB);

  const existingFilesTotalSizeGB = existingFiles.reduce((acc, file) => {
    return acc + bytesToGB(file.size);
  }, 0);

  const existingFilesTotalMonthlyCost = calculateMonthlyCost(
    existingFilesTotalSizeGB
  );
  const existingFilesTotalLocked = calculateLockedAmount(
    existingFilesTotalSizeGB
  );

  const totalSizeGB = existingFilesTotalSizeGB + fileSizeGB;
  const totalMonthlyCost = (
    parseFloat(existingFilesTotalMonthlyCost) + parseFloat(monthlyCost)
  ).toFixed(5);


  return (
    <Card className="mb-6 bg-gradient-to-br from-blue-50/80 to-indigo-50/80 border-blue-200">
      <div
        className="p-4 cursor-pointer flex items-center justify-between"
        onClick={() => setIsExpanded(!isExpanded)}
      >
        <div className="flex items-center gap-3">
          <Calculator className="w-6 h-6 text-blue-600" />
          <div>
            <Typography variant="h4" className="text-blue-900 font-semibold">
              Storage Cost Calculator
            </Typography>
            {!isExpanded && totalSizeGB > 0 && (
              <Typography variant="small" className="text-blue-700">
                Total: {formatFileSize(totalSizeGB * 1024 * 1024 * 1024)} ‚Ä¢{" "}
                {totalMonthlyCost} USDFC/month
              </Typography>
            )}
          </div>
        </div>
        <Button
          variant="ghost"
          size="icon"
          className="text-blue-600 hover:text-blue-800"
          onClick={(e) => {
            e.stopPropagation();
            setIsExpanded(!isExpanded);
          }}
        >
          {isExpanded ? <ChevronUp /> : <ChevronDown />}
        </Button>
      </div>

      {isExpanded && (
        <div className="px-6 pb-6 space-y-6">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <Card className="p-4 bg-white/50 border-blue-100">
              <div className="flex items-start gap-3">
                <DollarSign className="w-5 h-5 text-green-600 mt-1" />
                <div className="flex-1">
                  <h3 className="font-medium text-gray-900 mb-2">Base Rates</h3>
                  <div className="space-y-2 text-sm">
                    <div className="flex justify-between items-center">
                      <span className="text-gray-600">Storage Rate:</span>
                      <span className="font-medium text-gray-900">
                        {costPerGBPerMonth} USDFC / GiB / month
                      </span>
                    </div>
                    <div className="flex justify-between items-center">
                      <span className="text-gray-600">Lockup Period:</span>
                      <span className="font-medium text-gray-900">
                        {lockPeriodDays} days 
                      </span>
                    </div>
                    <div className="flex justify-between items-center">
                      <span className="text-gray-600">
                        Current FWS Balance:
                      </span>
                      <span className="font-medium text-gray-900">
                        {paymentStatus.accountFunds} USDFC
                      </span>
                    </div>
                    <div className="flex justify-between items-center">
                      <span className="text-gray-600">
                        Current Locked Funds:
                      </span>
                      <span className="font-medium text-gray-900">
                        {paymentStatus.lockedFunds.current} USDFC
                      </span>
                    </div>
                  </div>
                </div>
              </div>
            </Card>

            <Card
              className={`p-4 ${
                fileSizeGB > 0 ? "bg-blue-100/50" : "bg-white/50"
              } border-blue-100 transition-colors duration-300`}
            >
              <div className="flex items-start gap-3">
                <Upload className="w-5 h-5 text-blue-600 mt-1" />
                <div className="w-full">
                  <h3 className="font-medium text-gray-900 mb-2">
                    Selected File{" "}
                    {fileSizeGB > 0 && (
                      <span className="text-sm font-normal text-blue-600">
                        (Not yet uploaded)
                      </span>
                    )}
                  </h3>
                  {fileSizeGB > 0 ? (
                    <div className="space-y-2 text-sm">
                      <div className="flex justify-between items-center">
                        <span className="text-gray-600">Size:</span>
                        <span className="font-medium text-gray-900">
                          {formatFileSize(fileSizeGB * 1024 * 1024 * 1024)}
                        </span>
                      </div>
                      <div className="flex justify-between items-center">
                        <span className="text-gray-600">Monthly Cost:</span>
                        <span className="font-medium text-gray-900">
                          {monthlyCost} USDFC
                        </span>
                      </div>
                      <div className="flex justify-between items-center">
                        <span className="text-gray-600">Required Lock:</span>
                        <span className="font-medium text-gray-900">
                          {lockedAmount} USDFC
                        </span>
                      </div>
                    </div>
                  ) : (
                    <div className="space-y-3">
                      <div className="text-sm text-gray-500">
                        No file selected
                      </div>
                      {onSelectFile && (
                        <Button
                          variant="outline"
                          size="sm"
                          className="w-full"
                          onClick={onSelectFile}
                        >
                          <Upload className="w-4 h-4 mr-2" />
                          Select File
                        </Button>
                      )}
                    </div>
                  )}
                </div>
              </div>
            </Card>
          </div>

          {totalSizeGB > 0 && (
            <div className="mt-6">
              <Card className="p-4 bg-gradient-to-r from-blue-100/50 to-indigo-100/50 border-blue-200">
                <div className="flex items-start gap-3">
                  <Lock className="w-5 h-5 text-indigo-600 mt-1" />
                  <div className="w-full">
                    <h3 className="font-medium text-gray-900 mb-3">
                      Total Storage Summary
                    </h3>
                    <div className="grid grid-cols-2 lg:grid-cols-4 gap-4">
                      <div className="p-3 bg-white/80 rounded-lg">
                        <div className="text-sm text-gray-600 mb-1">
                          Total Size
                        </div>
                        <div className="font-semibold text-gray-900">
                          {formatFileSize(totalSizeGB * 1024 * 1024 * 1024)}
                        </div>
                      </div>
                      <div className="p-3 bg-white/80 rounded-lg">
                        <div className="text-sm text-gray-600 mb-1">
                          Monthly Cost
                        </div>
                        <div className="font-semibold text-gray-900">
                          {totalMonthlyCost} USDFC
                        </div>
                      </div>
                      <div className="p-3 bg-white/80 rounded-lg">
                        <div className="text-sm text-gray-600 mb-1">
                          Total Locked
                        </div>
                        <div className="font-semibold text-blue-900">
                          {parseFloat(
                            paymentStatus.lockedFunds.current
                          ).toFixed(5)}{" "}
                          USDFC
                        </div>
                      </div>
                      <div className="p-3 bg-white/80 rounded-lg">
                        <div className="text-sm text-gray-600 mb-1">
                          Total Files
                        </div>
                        <div className="font-semibold text-blue-900">
                          {existingFiles.length}
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </Card>
            </div>
          )}

          <div className="bg-white/70 rounded-lg border border-blue-100 p-4">
            <h3 className="font-medium text-gray-900 mb-2 flex items-center gap-2">
              <InfoIcon className="w-4 h-4 text-blue-500" />
              How Costs Are Calculated
            </h3>
            <div className="text-sm text-gray-600 space-y-2">
              <p>
                <span className="font-medium text-gray-700">Monthly Cost:</span>{" "}
                Each GB costs {costPerGBPerMonth} USDFC per month.
              </p>
              <p>
                <span className="font-medium text-gray-700">Lockup Amount:</span>{" "}
                {lockPeriodDays} days worth of storage costs are locked (
                {((lockPeriodDays / daysInMonth) * 100).toFixed(0)}% of monthly
                cost).
              </p>
              <p className="text-xs text-gray-500 italic">
                Example: A 5GB file costs 10 USDFC per month, with{" "}
                {((10 * lockPeriodDays) / daysInMonth).toFixed(2)} USDFC locked
                amount.
              </p>
            </div>
          </div>
        </div>
      )}
    </Card>
  );
};
</file>

<file path="examples/hotvault-demo/client/src/app/dashboard/_components/DashboardHeader.tsx">
"use client";

import { Typography } from "@/components/ui/typography";
import { motion, AnimatePresence } from "framer-motion";
import { DASHBOARD_SECTIONS, DashboardSection } from "@/types/dashboard";
import { Dispatch, SetStateAction } from "react";
import { Files, Wallet } from "lucide-react";
import { PaymentBalanceHeader } from "./PaymentBalanceHeader";
import Image from "next/image";

interface DashboardHeaderProps {
  account: string;
  activeTab: DashboardSection;
  setActiveTab: Dispatch<SetStateAction<DashboardSection>>;
  isAccountMenuOpen: boolean;
  setIsAccountMenuOpen: Dispatch<SetStateAction<boolean>>;
  handleAccountSwitch: () => void;
  disconnectWallet: () => void;
}

export const DashboardHeader: React.FC<DashboardHeaderProps> = ({
  account,
  activeTab,
  setActiveTab,
  isAccountMenuOpen,
  setIsAccountMenuOpen,
  handleAccountSwitch,
  disconnectWallet,
}) => {
  return (
    <motion.header
      className="w-full border-b border-gray-200/80 fixed top-0 bg-white/80 backdrop-blur-md z-50"
      initial={{ y: -100 }}
      animate={{ y: 0 }}
      transition={{ type: "spring", stiffness: 100 }}
    >
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex items-center justify-between h-16">
          <div className="flex items-center gap-10">
            <motion.div
              className="flex items-center gap-2"
              whileHover={{ scale: 1.02 }}
            >
              <div className="w-8 h-8 relative">
                <Image
                  src="/logo.png"
                  alt="Hot Vault Logo"
                  fill
                  className="object-contain"
                  priority
                />
              </div>
              <Typography
                variant="h1"
                className="text-xl font-mono tracking-tight"
              >
                Hot Vault
              </Typography>
            </motion.div>

            <nav className="flex items-center space-x-1">
              <button
                onClick={() => setActiveTab(DASHBOARD_SECTIONS.FILES)}
                className={`flex items-center gap-2 px-4 py-2 rounded-md text-sm font-medium transition-colors ${
                  activeTab === DASHBOARD_SECTIONS.FILES
                    ? "bg-blue-50 text-blue-700"
                    : "text-gray-600 hover:text-gray-900 hover:bg-gray-100"
                }`}
              >
                <Files size={16} />
                Files
              </button>

              <button
                onClick={() => setActiveTab(DASHBOARD_SECTIONS.PAYMENTS)}
                className={`flex items-center gap-2 px-4 py-2 rounded-md text-sm font-medium transition-colors ${
                  activeTab === DASHBOARD_SECTIONS.PAYMENTS
                    ? "bg-blue-50 text-blue-700"
                    : "text-gray-600 hover:text-gray-900 hover:bg-gray-100"
                }`}
              >
                <Wallet size={16} />
                Payment Setup
              </button>
            </nav>
          </div>

          <div className="flex items-center gap-4">
            <PaymentBalanceHeader />

            <div className="relative">
              <motion.button
                onClick={() => setIsAccountMenuOpen(!isAccountMenuOpen)}
                className="flex items-center gap-2 px-4 py-2 rounded-lg bg-gray-50 hover:bg-gray-100 transition-colors"
                whileHover={{ scale: 1.02 }}
                whileTap={{ scale: 0.98 }}
              >
                <div className="w-2 h-2 rounded-full bg-green-500" />
                <Typography variant="small" className="font-mono">
                  {account.slice(0, 6)}...{account.slice(-4)}
                </Typography>
              </motion.button>

              <AnimatePresence>
                {isAccountMenuOpen && (
                  <motion.div
                    className="absolute right-0 mt-2 w-72 bg-white rounded-xl shadow-lg border border-gray-200 overflow-hidden"
                    initial={{ opacity: 0, y: 10 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: 10 }}
                  >
                    <div className="p-4 border-b border-gray-100">
                      <Typography variant="small" className="text-gray-500">
                        Connected Account
                      </Typography>
                      <Typography
                        variant="small"
                        className="font-mono text-sm mt-1"
                      >
                        {account.slice(0, 6)}...{account.slice(-4)}
                      </Typography>
                    </div>
                    <div className="p-2">
                      <motion.button
                        onClick={handleAccountSwitch}
                        className="w-full px-4 py-2 text-left hover:bg-gray-50 rounded-lg flex items-center gap-2"
                        whileHover={{ x: 4 }}
                      >
                        <svg
                          className="w-4 h-4 text-gray-500"
                          fill="none"
                          viewBox="0 0 24 24"
                          stroke="currentColor"
                        >
                          <path
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            strokeWidth={2}
                            d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"
                          />
                        </svg>
                        <Typography variant="small">Switch Account</Typography>
                      </motion.button>
                      <motion.button
                        onClick={disconnectWallet}
                        className="w-full px-4 py-2 text-left hover:bg-red-50 rounded-lg flex items-center gap-2 text-red-600"
                        whileHover={{ x: 4 }}
                      >
                        <svg
                          className="w-4 h-4"
                          fill="none"
                          viewBox="0 0 24 24"
                          stroke="currentColor"
                        >
                          <path
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            strokeWidth={2}
                            d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"
                          />
                        </svg>
                        <Typography variant="small">Disconnect</Typography>
                      </motion.button>
                    </div>
                  </motion.div>
                )}
              </AnimatePresence>
            </div>
          </div>
        </div>
      </div>
    </motion.header>
  );
};
</file>

<file path="examples/hotvault-demo/client/src/app/dashboard/_components/FileIcon.tsx">
"use client";

interface FileIconProps {
  filename: string;
}

export const FileIcon: React.FC<FileIconProps> = ({ filename }) => {
  const extension = filename.split(".").pop()?.toLowerCase() || "";

  if (
    ["jpg", "jpeg", "png", "gif", "svg", "webp", "bmp", "ico"].includes(
      extension
    )
  ) {
    return (
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        className="h-6 w-6 text-blue-500"
      >
        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
        <circle cx="8.5" cy="8.5" r="1.5"></circle>
        <polyline points="21 15 16 10 5 21"></polyline>
      </svg>
    );
  }

  if (["pdf", "doc", "docx", "txt", "rtf", "odt", "md"].includes(extension)) {
    return (
      <svg
        className="h-6 w-6 text-red-500"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
      >
        <path
          strokeLinecap="round"
          strokeLinejoin="round"
          strokeWidth={2}
          d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
        />
      </svg>
    );
  }

  if (["xls", "xlsx", "csv", "ods", "numbers"].includes(extension)) {
    return (
      <svg
        className="h-6 w-6 text-green-500"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
      >
        <path
          strokeLinecap="round"
          strokeLinejoin="round"
          strokeWidth={2}
          d="M9 17v-2m3 2v-4m3 4v-6m2 10H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
        />
      </svg>
    );
  }

  if (
    ["zip", "rar", "7z", "tar", "gz", "bz2", "xz", "iso"].includes(extension)
  ) {
    return (
      <svg
        className="h-6 w-6 text-amber-500"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
      >
        <path
          strokeLinecap="round"
          strokeLinejoin="round"
          strokeWidth={2}
          d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4"
        />
      </svg>
    );
  }

  if (
    [
      "js",
      "ts",
      "jsx",
      "tsx",
      "html",
      "css",
      "scss",
      "json",
      "xml",
      "yaml",
      "yml",
      "py",
      "rb",
      "java",
      "c",
      "cpp",
      "go",
      "rs",
      "php",
    ].includes(extension)
  ) {
    return (
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        className="h-6 w-6 text-purple-500"
      >
        <polyline points="16 18 22 12 16 6"></polyline>
        <polyline points="8 6 2 12 8 18"></polyline>
      </svg>
    );
  }

  if (["mp4", "mov", "avi", "mkv", "wmv", "flv", "webm"].includes(extension)) {
    return (
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        className="h-6 w-6 text-blue-600"
      >
        <rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"></rect>
        <line x1="10" y1="8" x2="10" y2="16"></line>
        <line x1="14" y1="8" x2="14" y2="16"></line>
      </svg>
    );
  }

  if (["mp3", "wav", "ogg", "flac", "aac", "m4a"].includes(extension)) {
    return (
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
        className="h-6 w-6 text-green-600"
      >
        <path d="M9 18V5l12-2v13"></path>
        <circle cx="6" cy="18" r="3"></circle>
        <circle cx="18" cy="16" r="3"></circle>
      </svg>
    );
  }

  return (
    <svg
      className="h-6 w-6 text-gray-400"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"
      />
    </svg>
  );
};
</file>

<file path="examples/hotvault-demo/client/src/app/dashboard/_components/FileRowComponent.tsx">
"use client";

import { formatDistanceToNow } from "date-fns";
import { motion } from "framer-motion";
import { Download, Trash2 } from "lucide-react";

import { FileIcon } from "./FileIcon";
import { Piece } from "./types";

interface FileRowProps {
  piece: Piece;
  index: number;
  formatFileSize: (bytes: number) => string;
  handleDownload: (piece: Piece) => void;
  handleRemoveRoot: (piece: Piece) => void;
  openProofDetails: (piece: Piece) => void;
  downloadsInProgress: {
    [cid: string]: boolean;
  };
}

const tableRowVariants = {
  hidden: { opacity: 0, x: -5 },
  visible: (custom: number) => ({
    opacity: 1,
    x: 0,
    transition: { delay: custom * 0.05, duration: 0.2 },
  }),
};

export const FileRowComponent: React.FC<FileRowProps> = ({
  piece,
  index,
  formatFileSize,
  handleDownload,
  handleRemoveRoot,
  openProofDetails,
  downloadsInProgress,
}) => {
  const isPendingRemoval = piece.pendingRemoval;
  const isDownloading = downloadsInProgress[piece.cid];
  const hasProof =
    piece.serviceProofSetId !== undefined && piece.serviceProofSetId !== null;
  const rowClasses = isPendingRemoval
    ? "hover:bg-gray-50 bg-red-50"
    : "hover:bg-gray-50";

  return (
    <motion.tr
      key={piece.id}
      className={rowClasses}
      variants={tableRowVariants}
      initial="hidden"
      animate="visible"
      custom={index}
      whileHover={{
        backgroundColor: isPendingRemoval
          ? "rgba(254, 226, 226, 0.9)"
          : "rgba(249, 250, 251, 0.9)",
        transition: { duration: 0.15 },
      }}
    >
      <td className="px-6 py-4 whitespace-nowrap">
        <div className="flex items-center">
          <motion.div
            className="flex-shrink-0 h-10 w-10 bg-gray-100 rounded-lg flex items-center justify-center"
            whileHover={{ scale: 1.05, transition: { duration: 0.2 } }}
          >
            <FileIcon filename={piece.filename} />
          </motion.div>
          <div className="ml-4">
            <div className="text-sm font-medium text-gray-900">
              {piece.filename}
            </div>
            <div className="text-sm text-gray-500 flex items-center flex-wrap gap-1">
              <span title={piece.cid} className="font-mono">
                CID: {piece.cid.substring(0, 8)}...
              </span>
              {isPendingRemoval && (
                <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-red-100 text-red-800">
                  <svg
                    className="w-3 h-3 mr-1"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={2}
                      d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
                    />
                  </svg>
                  Removal pending
                </span>
              )}
              {isDownloading && (
                <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800">
                  <svg
                    className="w-3 h-3 mr-1 animate-spin"
                    viewBox="0 0 24 24"
                  >
                    <circle
                      className="opacity-25"
                      cx="12"
                      cy="12"
                      r="10"
                      stroke="currentColor"
                      strokeWidth="4"
                    ></circle>
                    <path
                      className="opacity-75"
                      fill="currentColor"
                      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                    ></path>
                  </svg>
                  Downloading
                </span>
              )}
            </div>
          </div>
        </div>
      </td>
      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
        {formatFileSize(piece.size)}
      </td>
      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
        {formatDistanceToNow(new Date(piece.createdAt), {
          addSuffix: true,
        })}
        {isPendingRemoval && piece.removalDate && (
          <div className="text-red-600 text-xs mt-1 flex items-center">
            <svg
              className="w-3 h-3 mr-1"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
              />
            </svg>
            Will be removed{" "}
            {formatDistanceToNow(new Date(piece.removalDate), {
              addSuffix: true,
            })}
          </div>
        )}
      </td>
      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
        {hasProof ? (
          <div className="flex items-center flex-wrap gap-2">
            <div className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="h-3 w-3 mr-1"
              >
                <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
              </svg>
              Proof Available
            </div>
            <button
              onClick={() => openProofDetails(piece)}
              className="ml-2 text-xs text-blue-600 hover:underline flex items-center"
              title="View proof details"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="h-3 w-3 mr-1"
              >
                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                <polyline points="15 3 21 3 21 9"></polyline>
                <line x1="10" y1="14" x2="21" y2="3"></line>
              </svg>
              Details
            </button>
          </div>
        ) : (
          <span className="text-gray-400 text-xs italic">None</span>
        )}
      </td>
      <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
        <div className="flex items-center justify-end space-x-2">
          <motion.button
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={() => handleDownload(piece)}
            disabled={isDownloading}
            className={`text-blue-600 hover:text-blue-900 ${
              isDownloading ? "opacity-50 cursor-not-allowed" : ""
            }`}
            title="Download file"
          >
            <Download className="h-5 w-5" />
          </motion.button>

          <motion.button
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
            onClick={() => handleRemoveRoot(piece)}
            className="text-red-600 hover:text-red-900"
            title="Remove file"
          >
            <Trash2 className="h-5 w-5" />
          </motion.button>
        </div>
      </td>
    </motion.tr>
  );
};
</file>

<file path="examples/hotvault-demo/client/src/app/dashboard/_components/FilesTab.tsx">
"use client";

import { Typography } from "@/components/ui/typography";
import { Button } from "@/components/ui/button";
import { motion, AnimatePresence } from "framer-motion";
import { useState, useCallback, useEffect } from "react";
import type { ReactElement } from "react";
import { useDropzone } from "react-dropzone";
import { API_BASE_URL } from "@/lib/constants";
import { formatDistanceToNow } from "date-fns";
import {
  AlertTriangle,
  Download,
  Trash2,
  ExternalLink,
  Eye,
} from "lucide-react";
import { toast } from "sonner";
import Image from "next/image";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { formatFileSize, getFilePreviewType } from "@/lib/utils";
import { useUpload } from "@/hooks/useUpload";
import { useUploadStore } from "@/store/upload-store";
import { UploadProgress } from "@/components/ui/upload-progress";
import { useAuth } from "@/contexts/AuthContext";
import { usePayment } from "@/contexts/PaymentContext";
import { UPLOAD_COMPLETED_EVENT } from "@/components/ui/global-upload-progress";
import { ROOT_REMOVED_EVENT } from "./PaymentBalanceHeader";
import { CostBanner } from "./CostBanner";
import { BALANCE_UPDATED_EVENT } from "@/contexts/PaymentContext";

interface Piece {
  id: number;
  cid: string;
  filename: string;
  size: number;
  serviceName: string;
  serviceUrl: string;
  createdAt: string;
  updatedAt: string;
  pendingRemoval?: boolean;
  removalDate?: string;
  proofSetDbId?: number;
  serviceProofSetId?: string;
  rootId?: string;
}

interface FilesTabProps {
  isLoading: boolean;
  onTabChange?: (tab: string) => void;
}

interface DownloadError extends Error {
  options?: string[];
}

const fadeInUp = {
  hidden: { opacity: 0, y: 10 },
  visible: { opacity: 1, y: 0, transition: { duration: 0.2 } },
};

const scaleIn = {
  hidden: { opacity: 0, scale: 0.95 },
  visible: { opacity: 1, scale: 1, transition: { duration: 0.15 } },
};

const tableRowVariants = {
  hidden: { opacity: 0, x: -5 },
  visible: (custom: number) => ({
    opacity: 1,
    x: 0,
    transition: { delay: custom * 0.05, duration: 0.2 },
  }),
};

type ProofSetStatus = "none" | "creating" | "ready" | "generating";

export const FilesTab = ({
  isLoading: initialLoading,
  onTabChange,
}: FilesTabProps): ReactElement => {
  const [selectedImage, setSelectedImage] = useState<File | null>(null);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [pieces, setPieces] = useState<Piece[]>([]);
  const [isLoading, setIsLoading] = useState(initialLoading);
  const [authError, setAuthError] = useState<string | null>(null);
  const [downloadsInProgress, setDownloadsInProgress] = useState<{
    [cid: string]: boolean;
  }>({});
  const [fileSizeGB, setFileSizeGB] = useState<number>(0);
  // Add a timestamp to trigger re-renders when payment status is refreshed
  const [lastPaymentRefresh, setLastPaymentRefresh] = useState<number>(
    Date.now()
  );

  const { disconnectWallet, userProofSetId, updateUserProofSetId } = useAuth();
  const { refreshPaymentSetupStatus } = usePayment();

  const [isProofDialogOpen, setIsProofDialogOpen] = useState(false);
  const [selectedProof, setSelectedProof] = useState<{
    pieceId: number;
    pieceFilename: string;
    serviceProofSetId: string;
    cid: string;
    rootId?: string;
  } | null>(null);

  const [proofSetStatus, setProofSetStatus] = useState<ProofSetStatus>(
    userProofSetId ? "ready" : "none"
  );

  const fetchProofs = useCallback(async () => {
    try {
      if (userProofSetId) {
        console.log(
          "[FilesTab] Using existing userProofSetId:",
          userProofSetId
        );
        setProofSetStatus("ready");
        return;
      }

      const response = await fetch(`${API_BASE_URL}/api/v1/auth/status`, {
        method: "GET",
        credentials: "include",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
        },
      });

      if (response.status === 401) {
        console.log(
          "[FilesTab] Auth status response 401:",
          await response.json()
        );
        setAuthError("Your session has expired. Please login again.");
        return;
      }

      if (!response.ok) {
        const data = await response.json();
        console.log("[FilesTab] Auth status response not OK:", data);
        if (data.error?.includes("Proof set not found")) {
          setProofSetStatus("none");
        } else {
          console.warn(
            `[FilesTab.tsx:fetchProofs] Failed to fetch proofs: ${response.statusText}`
          );
          // Keep the current status instead of assuming "creating"
          return;
        }
        return;
      }

      const data = await response.json();
      console.log("[FilesTab] Auth status response:", data);

      // Check the auth status response for proof set state
      if (data.proofSetReady) {
        console.log("[FilesTab] Setting proof set status to ready");
        setProofSetStatus("ready");

        // Make a separate call to get the proof set ID
        try {
          const proofSetResponse = await fetch(
            `${API_BASE_URL}/api/v1/proofset/id`,
            {
              method: "GET",
              credentials: "include",
              headers: {
                Accept: "application/json",
                "Content-Type": "application/json",
              },
            }
          );

          if (proofSetResponse.ok) {
            const proofSetData = await proofSetResponse.json();
            console.log("[FilesTab] Proof set data:", proofSetData);
            if (proofSetData.proofSetId) {
              console.log(
                "[FilesTab] Found proofSetId:",
                proofSetData.proofSetId
              );
              updateUserProofSetId(proofSetData.proofSetId);
            }
          } else {
            console.warn(
              "[FilesTab] Failed to fetch proof set ID:",
              proofSetResponse.statusText
            );
          }
        } catch (error) {
          console.error("[FilesTab] Error fetching proof set ID:", error);
        }
      } else if (data.proofSetInitiated) {
        console.log("[FilesTab] Setting proof set status to creating");
        setProofSetStatus("creating");
      } else {
        console.log("[FilesTab] Setting proof set status to none");
        setProofSetStatus("none");
      }

      // Update pieces with proof data if available
      if (data.pieces) {
        console.log("[FilesTab] Updating pieces with proof data:", data.pieces);
        setPieces((prevPieces) =>
          prevPieces.map((piece) => {
            const pieceWithProof = data.pieces.find(
              (p: Piece) => p.id === piece.id
            );
            if (pieceWithProof?.proofSetDbId) {
              return {
                ...piece,
                proofSetDbId: pieceWithProof.proofSetDbId,
                rootId: pieceWithProof.rootId,
              };
            }
            return piece;
          })
        );
      }
    } catch (error) {
      console.warn(
        "[FilesTab.tsx:fetchProofs] Error checking proof status:",
        error
      );
    }
  }, [
    userProofSetId,
    setProofSetStatus,
    setAuthError,
    setPieces,
    updateUserProofSetId,
  ]);

  useEffect(() => {
    if (userProofSetId) {
      setProofSetStatus("ready");
    }
  }, [userProofSetId]);

  useEffect(() => {
    if (proofSetStatus === "creating" && pieces.length > 0 && !userProofSetId) {
      const proofCheckInterval = setInterval(() => {
        console.log("[FilesTab.tsx] Checking if proof sets are ready...");
        fetchProofs();
      }, 15000);

      return () => clearInterval(proofCheckInterval);
    }
  }, [proofSetStatus, pieces.length, userProofSetId, fetchProofs]);

  const fetchPieces = useCallback(async () => {
    try {
      setIsLoading(true);
      const token = localStorage.getItem("jwt_token");
      if (!token) {
        setAuthError("Authentication required. Please login again.");
        return [];
      }

      const response = await fetch(`${API_BASE_URL}/api/v1/pieces`, {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });

      if (response.status === 401) {
        setAuthError("Your session has expired. Please login again.");
        return [];
      }

      if (!response.ok) {
        throw new Error(`Failed to fetch pieces: ${response.statusText}`);
      }

      const data = await response.json();
      setPieces(data);

      // Refresh payment status after successfully fetching pieces
      try {
        await refreshPaymentSetupStatus();
        // Update last payment refresh timestamp to trigger re-renders
        setLastPaymentRefresh(Date.now());
        // Dispatch custom event to update balance in other components
        window.dispatchEvent(
          new CustomEvent(BALANCE_UPDATED_EVENT, {
            detail: {
              timestamp: Date.now(),
              action: "pieces_refreshed",
            },
          })
        );
        console.log(
          "[FilesTab.tsx:fetchPieces] Payment status refreshed successfully"
        );
      } catch (paymentError) {
        console.error(
          "[FilesTab.tsx:fetchPieces] Error refreshing payment status:",
          paymentError
        );
      }

      return data;
    } catch (error) {
      console.error(
        "[FilesTab.tsx:fetchPieces] ‚ùå Error fetching pieces:",
        error
      );
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, [refreshPaymentSetupStatus]);

  const {
    uploadFile,
    handleCancelUpload: cancelUpload,
    hasActiveUpload,
  } = useUpload(fetchPieces);
  const uploadProgress = useUploadStore((state) => state.uploadProgress);

  useEffect(() => {
    let isMounted = true;

    const loadData = async () => {
      try {
        if (isMounted) {
          const data = await fetchPieces();
          if (isMounted && data) {
            await fetchProofs();
          }
        }
      } catch (error: unknown) {
        if (isMounted && !authError) {
          const errorMessage =
            error instanceof Error ? error.message : "Unknown error";
          toast.error(`Error loading files: ${errorMessage}`);
        }
      }
    };

    loadData();

    // Handler for upload completion
    const handleUploadCompleted = () => {
      console.log(
        "[FilesTab] Detected upload completion, refreshing file list and payment status"
      );

      if (!isMounted) return;

      setIsLoading(true);

      fetchPieces()
        .then(() => {
          if (!isMounted) return;

          console.log(
            "[FilesTab] File list and payment status refreshed successfully after upload"
          );
          setIsLoading(false);

          // Update last payment refresh timestamp to trigger re-renders
          setLastPaymentRefresh(Date.now());

          // Display success message to user
          toast.success(
            "File uploaded successfully and payment information updated",
            {
              duration: 3000,
            }
          );

          setTimeout(() => {
            if (!isMounted) return;
            refreshPaymentSetupStatus()
              .then(() => {
                setLastPaymentRefresh(Date.now());
                console.log("[FilesTab] Second balance refresh completed");

                setTimeout(() => {
                  if (!isMounted) return;
                  refreshPaymentSetupStatus()
                    .then(() => {
                      setLastPaymentRefresh(Date.now());
                      console.log("[FilesTab] Third balance refresh completed");
                    })
                    .catch((e) =>
                      console.log("[FilesTab] Error in third refresh:", e)
                    );
                }, 2000);
              })
              .catch((e) =>
                console.log("[FilesTab] Error in second refresh:", e)
              );
          }, 1000);
        })
        .catch((error: Error) => {
          if (!isMounted) return;

          console.error(
            "[FilesTab] Error refreshing data after upload:",
            error
          );
          setIsLoading(false);

          refreshPaymentSetupStatus()
            .then(() => {
              setLastPaymentRefresh(Date.now());

              setTimeout(() => {
                if (!isMounted) return;
                refreshPaymentSetupStatus()
                  .then(() => setLastPaymentRefresh(Date.now()))
                  .catch((e) =>
                    console.error("[FilesTab] Error in fallback refresh:", e)
                  );
              }, 2000);
            })
            .catch((e: Error) =>
              console.error("[FilesTab] Failed to refresh payment status:", e)
            );
        });
    };

    const handleBalanceUpdated = () => {
      console.log("[FilesTab] Balance updated detected, triggering re-render");
      setLastPaymentRefresh(Date.now());
    };

    // Add visibility change handler to refresh data when tab becomes visible again
    const handleVisibilityChange = () => {
      if (document.visibilityState === "visible") {
        console.log(
          "[FilesTab] Tab became visible, refreshing balance and file data"
        );

        // Refresh payment status first
        refreshPaymentSetupStatus()
          .then(() => {
            // Then refresh pieces data
            return fetchPieces();
          })
          .then(() => {
            // Update the timestamp to trigger re-renders
            setLastPaymentRefresh(Date.now());

            // Dispatch custom event to update balance in other components
            window.dispatchEvent(
              new CustomEvent(BALANCE_UPDATED_EVENT, {
                detail: {
                  timestamp: Date.now(),
                  action: "visibility_change",
                },
              })
            );
            console.log("[FilesTab] Data refreshed after tab became visible");
          })
          .catch((error) => {
            console.error(
              "[FilesTab] Error refreshing data on visibility change:",
              error
            );
          });
      }
    };

    window.addEventListener(UPLOAD_COMPLETED_EVENT, handleUploadCompleted);
    window.addEventListener(BALANCE_UPDATED_EVENT, handleBalanceUpdated);
    document.addEventListener("visibilitychange", handleVisibilityChange);

    return () => {
      isMounted = false;
      window.removeEventListener(UPLOAD_COMPLETED_EVENT, handleUploadCompleted);
      window.removeEventListener(BALANCE_UPDATED_EVENT, handleBalanceUpdated);
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, [authError, fetchPieces, fetchProofs, refreshPaymentSetupStatus]);

  useEffect(() => {
    const firstPieceWithProof = pieces.find(
      (p) => p.proofSetDbId !== null && p.proofSetDbId !== undefined
    );
    const derivedProofSetId = firstPieceWithProof?.serviceProofSetId || null;

    if (derivedProofSetId !== userProofSetId) {
      if (derivedProofSetId) {
        console.log(
          `[FilesTab.tsx] Found piece with different Proof Set ID: ${derivedProofSetId} (Piece ID: ${firstPieceWithProof?.id})`
        );
      } else {
        console.log("[FilesTab.tsx] No pieces with Proof Set ID found.");
      }
    } else {
      console.log(
        `[FilesTab.tsx] Proof Set ID check: Current ID (${userProofSetId}) matches pieces. Found piece ID: ${firstPieceWithProof?.id}`
      );
    }
  }, [pieces, userProofSetId]);

  const [isRemoveDialogOpen, setIsRemoveDialogOpen] = useState(false);
  const [pieceToRemove, setPieceToRemove] = useState<Piece | null>(null);

  useEffect(() => {
    const checkToken = () => {
      const token = localStorage.getItem("jwt_token");
      if (!token) {
        setAuthError("Authentication required. Please login again.");
      } else {
        if (authError) setAuthError(null);
      }
    };

    checkToken();

    const tokenInterval = setInterval(checkToken, 60000);

    return () => {
      clearInterval(tokenInterval);
    };
  }, [authError]);

  const onDrop = useCallback((acceptedFiles: File[]) => {
    if (acceptedFiles.length === 0) return;

    const file = acceptedFiles[0];

    // Check file size (99MB limit)
    // const maxFileSize = 99 * 1024 * 1024; // 99MB in bytes
    // if (file.size > maxFileSize) {
    //   toast.error(
    //     `File is too large. Maximum size is 99MB. Current size: ${formatFileSize(
    //       file.size
    //     )}`
    //   );
    //   return;
    // }

    setSelectedImage(file);

    const sizeInGB = file.size / (1024 * 1024 * 1024);
    setFileSizeGB(Number(sizeInGB.toFixed(6)));

    if (file.type.startsWith("image/")) {
      const objectUrl = URL.createObjectURL(file);
      setPreviewUrl(objectUrl);
    } else {
      setPreviewUrl(null);
    }
  }, []);

  const isUploadDisabled = useCallback(() => {
    if (proofSetStatus === "none" && pieces.length === 0) {
      return true;
    }
    if (proofSetStatus === "creating") {
      return true;
    }
    return false;
  }, [proofSetStatus, pieces.length]);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    maxFiles: 1,
    disabled: isUploadDisabled(),
  });

  const handleSubmitImage = async () => {
    if (!selectedImage) return;

    try {
      await uploadFile(selectedImage);
      setSelectedImage(null);
      setPreviewUrl(null);
    } catch (error) {
      console.error("[FilesTab] Upload failed:", error);
    }
  };

  const handleDownload = (piece: Piece) => {
    const token = localStorage.getItem("jwt_token");
    if (!token) {
      toast.error("Authentication required. Please login to download files");
      return;
    }

    setDownloadsInProgress((prev) => ({
      ...prev,
      [piece.cid]: true,
    }));

    toast.info(`Preparing ${piece.filename} for download...`);

    const encodedCid = encodeURIComponent(piece.cid);

    downloadWithMethod(piece, encodedCid, false)
      .catch((error) => {
        console.error(
          "[FilesTab.tsx:handleDownload] Error with direct download:",
          error
        );

        if (
          error.message &&
          (error.message.includes("pdptool not found") ||
            error.message.includes("Failed to download file"))
        ) {
          toast.info("Direct download failed. Trying IPFS gateway...");
          return downloadWithMethod(piece, encodedCid, true);
        }
        throw error;
      })
      .catch((error) => {
        console.error(
          "[FilesTab.tsx:handleDownload] Error with gateway download:",
          error
        );
        handleDownloadError(piece, error);
      });
  };

  const downloadWithMethod = (
    piece: Piece,
    encodedCid: string,
    useGateway: boolean
  ) => {
    const token = localStorage.getItem("jwt_token");
    if (!token) {
      return Promise.reject(new Error("Authentication required"));
    }

    const url = useGateway
      ? `${API_BASE_URL}/api/v1/download/${encodedCid}?gateway=true`
      : `${API_BASE_URL}/api/v1/download/${encodedCid}`;

    return fetch(url, {
      headers: {
        Authorization: `Bearer ${token}`,
      },
    })
      .then(async (response) => {
        if (!response.ok) {
          let errorMessage = `Download failed: ${response.statusText}`;
          let errorOptions: string[] = [];

          const contentType = response.headers.get("content-type");
          if (contentType && contentType.includes("application/json")) {
            try {
              const errorData = await response.json();
              if (errorData.error) {
                errorMessage = errorData.error;
                if (errorData.options) {
                  errorOptions = errorData.options;
                }
                console.error(
                  "[FilesTab.tsx:downloadWithMethod] Error details:",
                  errorData
                );
              }
            } catch (e) {
              console.error(
                "[FilesTab.tsx:downloadWithMethod] Failed to parse error as JSON:",
                e
              );
            }
          } else {
            try {
              const errorText = await response.text();
              if (errorText) {
                errorMessage += ` - ${errorText}`;
              }
            } catch (textError) {
              console.error(
                "[FilesTab.tsx:downloadWithMethod] Failed to parse error:",
                textError
              );
            }
          }

          const error = new Error(errorMessage) as DownloadError;
          error.options = errorOptions;
          throw error;
        }

        if (response.redirected) {
          window.open(response.url, "_blank");

          setDownloadsInProgress((prev) => {
            const newState = { ...prev };
            delete newState[piece.cid];
            return newState;
          });

          toast.success(
            `${piece.filename} opened in new tab from IPFS gateway`
          );
          return null;
        }

        return response.blob();
      })
      .then((blob) => {
        if (!blob) return;

        const url = window.URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.setAttribute("download", piece.filename);
        document.body.appendChild(link);
        link.click();

        setTimeout(() => {
          document.body.removeChild(link);
          window.URL.revokeObjectURL(url);
        }, 100);

        toast.success(`${piece.filename} downloaded successfully`, {
          duration: 3000,
        });

        setDownloadsInProgress((prev) => {
          const newState = { ...prev };
          delete newState[piece.cid];
          return newState;
        });
      });
  };

  const handleDownloadError = (piece: Piece, error: DownloadError) => {
    const options = error.options || [];
    const cid = piece.cid.split(":")[0];

    if (options.length > 0) {
      toast.error(
        <div className="flex flex-col gap-2">
          <div>Download failed: {error.message}</div>
          <div className="mt-2">
            <p className="text-sm font-semibold mb-1">Options:</p>
            <div className="flex flex-col gap-1">
              {options.map((option: string, index: number) => (
                <div key={index} className="text-sm">
                  {option}
                </div>
              ))}
            </div>
          </div>
          <Button
            size="sm"
            variant="outline"
            className="flex items-center gap-2 mt-1"
            onClick={() => {
              const gatewayUrl = `https://ipfs.io/ipfs/${cid}`;
              window.open(gatewayUrl, "_blank");

              setDownloadsInProgress((prev) => {
                const newState = { ...prev };
                delete newState[piece.cid];
                return newState;
              });
            }}
          >
            <ExternalLink className="h-4 w-4" />
            Open in IPFS Gateway
          </Button>
        </div>,
        { duration: 10000 }
      );
    } else {
      toast.error(error.message || "Download failed");
    }

    setDownloadsInProgress((prev) => {
      const newState = { ...prev };
      delete newState[piece.cid];
      return newState;
    });
  };

  const handleRemoveRoot = (piece: Piece) => {
    setPieceToRemove(piece);
    setIsRemoveDialogOpen(true);
  };

  const submitRemoveRoot = async () => {
    if (!pieceToRemove) return;

    try {
      const token = localStorage.getItem("jwt_token");
      if (!token) {
        throw new Error("Authentication required");
      }

      const response = await fetch(`${API_BASE_URL}/api/v1/roots/remove`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({
          pieceId: pieceToRemove.id,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to remove root");
      }

      const result = await response.json();
      console.log("[FilesTab.tsx:submitRemoveRoot] Success:", result);

      toast.success("Root removed and file deleted successfully");

      // Update the local state to remove the piece immediately
      setPieces((prevPieces) =>
        prevPieces.filter((p) => p.id !== pieceToRemove.id)
      );

      // Dispatch the ROOT_REMOVED_EVENT to trigger balance refresh
      window.dispatchEvent(new Event(ROOT_REMOVED_EVENT));

      // Refresh payment data and notify components
      try {
        await refreshPaymentSetupStatus();

        // Update the timestamp to force re-renders
        setLastPaymentRefresh(Date.now());

        // Dispatch custom event to update balance in other components
        window.dispatchEvent(
          new CustomEvent(BALANCE_UPDATED_EVENT, {
            detail: {
              timestamp: Date.now(),
              action: "root_removed",
            },
          })
        );

        console.log(
          "[FilesTab.tsx:submitRemoveRoot] Payment status refreshed successfully"
        );
      } catch (paymentError) {
        console.error(
          "[FilesTab.tsx:submitRemoveRoot] Error refreshing payment status:",
          paymentError
        );
      }

      // Close dialog
      setIsRemoveDialogOpen(false);
      setPieceToRemove(null);
    } catch (error) {
      console.error("[FilesTab.tsx:submitRemoveRoot] Error:", error);
      toast.error(error instanceof Error ? error.message : "Unknown error");
    }
  };

  const openProofDetails = (piece: Piece) => {
    if (piece.serviceProofSetId === undefined) {
      console.warn(
        "Attempted to open proof details for piece without serviceProofSetId:",
        piece.id
      );
      toast.error("Proof Set ID not available for this piece.");
      return;
    }

    setSelectedProof({
      pieceId: piece.id,
      pieceFilename: piece.filename,
      serviceProofSetId: piece.serviceProofSetId, // Use service ID
      cid: piece.cid,
      rootId: piece.rootId, // Include rootId when available
    });
    setIsProofDialogOpen(true);
  };

  const getFileIcon = (filename: string) => {
    const extension = filename.split(".").pop()?.toLowerCase() || "";

    if (
      ["jpg", "jpeg", "png", "gif", "bmp", "svg", "webp"].includes(extension)
    ) {
      return (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className="h-6 w-6 text-blue-400"
        >
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
          <circle cx="8.5" cy="8.5" r="1.5"></circle>
          <polyline points="21 15 16 10 5 21"></polyline>
        </svg>
      );
    }

    if (["pdf", "doc", "docx", "txt", "rtf", "odt"].includes(extension)) {
      return (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className="h-6 w-6 text-red-400"
        >
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
        </svg>
      );
    }

    if (["xls", "xlsx", "csv", "ods"].includes(extension)) {
      return (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className="h-6 w-6 text-green-500"
        >
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
        </svg>
      );
    }

    if (["zip", "rar", "tar", "gz", "7z"].includes(extension)) {
      return (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className="h-6 w-6 text-amber-500"
        >
          <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>
          <polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline>
          <line x1="12" y1="22.08" x2="12" y2="12"></line>
        </svg>
      );
    }

    if (
      [
        "js",
        "ts",
        "jsx",
        "tsx",
        "html",
        "css",
        "java",
        "py",
        "c",
        "cpp",
        "rb",
        "php",
      ].includes(extension)
    ) {
      return (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className="h-6 w-6 text-purple-500"
        >
          <polyline points="16 18 22 12 16 6"></polyline>
          <polyline points="8 6 2 12 8 18"></polyline>
        </svg>
      );
    }

    if (
      ["mp4", "mov", "avi", "mkv", "wmv", "flv", "webm"].includes(extension)
    ) {
      return (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className="h-6 w-6 text-blue-600"
        >
          <rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"></rect>
          <line x1="10" y1="8" x2="10" y2="16"></line>
          <line x1="14" y1="8" x2="14" y2="16"></line>
        </svg>
      );
    }

    if (["mp3", "wav", "ogg", "flac", "aac", "m4a"].includes(extension)) {
      return (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className="h-6 w-6 text-green-600"
        >
          <path d="M9 18V5l12-2v13"></path>
          <circle cx="6" cy="18" r="3"></circle>
          <circle cx="18" cy="16" r="3"></circle>
        </svg>
      );
    }

    return (
      <svg
        className="h-6 w-6 text-gray-400"
        fill="none"
        viewBox="0 0 24 24"
        stroke="currentColor"
      >
        <path
          strokeLinecap="round"
          strokeLinejoin="round"
          strokeWidth={2}
          d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"
        />
      </svg>
    );
  };

  const renderPieceRow = (piece: Piece, index: number) => {
    const isPendingRemoval = piece.pendingRemoval;
    const isDownloading = downloadsInProgress[piece.cid];
    const hasProof =
      piece.serviceProofSetId !== undefined && piece.serviceProofSetId !== null;
    const rowClasses = isPendingRemoval
      ? "hover:bg-gray-50 bg-red-50"
      : "hover:bg-gray-50";

    return (
      <motion.tr
        key={piece.id}
        className={rowClasses}
        variants={tableRowVariants}
        initial="hidden"
        animate="visible"
        custom={index}
        whileHover={{
          backgroundColor: isPendingRemoval
            ? "rgba(254, 226, 226, 0.9)"
            : "rgba(249, 250, 251, 0.9)",
          transition: { duration: 0.15 },
        }}
      >
        <td className="px-6 py-4 whitespace-nowrap">
          <div className="flex items-center">
            <motion.div
              className="flex-shrink-0 h-10 w-10 bg-gray-100 rounded-lg flex items-center justify-center"
              whileHover={{ scale: 1.05, transition: { duration: 0.2 } }}
            >
              {getFileIcon(piece.filename)}
            </motion.div>
            <div className="ml-4">
              <div className="text-sm font-medium text-gray-900">
                {piece.filename}
              </div>
              <div className="text-sm text-gray-500 flex items-center flex-wrap gap-1">
                <span title={piece.cid} className="font-mono">
                  CID: {piece.cid.substring(0, 8)}...
                </span>
                {isPendingRemoval && (
                  <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-red-100 text-red-800">
                    <svg
                      className="w-3 h-3 mr-1"
                      fill="none"
                      viewBox="0 0 24 24"
                      stroke="currentColor"
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
                      />
                    </svg>
                    Removal pending
                  </span>
                )}
                {isDownloading && (
                  <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800">
                    <svg
                      className="w-3 h-3 mr-1 animate-spin"
                      viewBox="0 0 24 24"
                    >
                      <circle
                        className="opacity-25"
                        cx="12"
                        cy="12"
                        r="10"
                        stroke="currentColor"
                        strokeWidth="4"
                      ></circle>
                      <path
                        className="opacity-75"
                        fill="currentColor"
                        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                      ></path>
                    </svg>
                    Downloading
                  </span>
                )}
              </div>
            </div>
          </div>
        </td>
        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
          {formatFileSize(piece.size)}
        </td>
        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
          {formatDistanceToNow(new Date(piece.createdAt), {
            addSuffix: true,
          })}
          {isPendingRemoval && piece.removalDate && (
            <div className="text-red-600 text-xs mt-1 flex items-center">
              <svg
                className="w-3 h-3 mr-1"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"
                />
              </svg>
              Will be removed{" "}
              {formatDistanceToNow(new Date(piece.removalDate), {
                addSuffix: true,
              })}
            </div>
          )}
        </td>
        <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
          {hasProof ? (
            <div className="flex items-center flex-wrap gap-2">
              <div className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  className="h-3 w-3 mr-1"
                >
                  <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                </svg>
                {/* Display serviceProofSetId */}
                Set #{piece.serviceProofSetId}
              </div>
            </div>
          ) : (
            <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800">
              Not available
            </span>
          )}
        </td>
        <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
          {isDownloading ? (
            <div className="flex items-center justify-end gap-2 text-blue-600">
              <div className="animate-spin h-4 w-4 border-2 border-blue-500 rounded-full border-t-transparent"></div>
              <span>Downloading...</span>
            </div>
          ) : (
            <div className="flex items-center justify-end space-x-2">
              <motion.div
                whileHover={{ scale: 1.1 }}
                whileTap={{ scale: 0.95 }}
              >
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => {
                    handleDownload(piece);
                  }}
                  disabled={isDownloading}
                  className="h-8 flex items-center transition-all duration-200 hover:text-blue-600"
                >
                  <Download className="h-4 w-4 mr-1" />
                  <span>Download</span>
                </Button>
              </motion.div>

              {hasProof && (
                <motion.div
                  whileHover={{ scale: 1.1 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => openProofDetails(piece)}
                    className="h-8 flex items-center transition-all duration-200 hover:text-blue-600"
                  >
                    <Eye className="h-4 w-4 mr-1" />
                    <span>Details</span>
                  </Button>
                </motion.div>
              )}

              {!isPendingRemoval && (
                <motion.div
                  whileHover={{ scale: 1.1 }}
                  whileTap={{ scale: 0.95 }}
                >
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => handleRemoveRoot(piece)}
                    disabled={piece.pendingRemoval}
                    className="h-8 flex items-center transition-all duration-200 hover:text-red-600"
                  >
                    <Trash2 className="h-4 w-4 mr-1" />
                    <span>Remove</span>
                  </Button>
                </motion.div>
              )}
            </div>
          )}
        </td>
      </motion.tr>
    );
  };

  const renderProofSetStatusBanner = () => {
    console.log(
      "[FilesTab] Rendering banner - status:",
      proofSetStatus,
      "pieces:",
      pieces.length
    );

    if (proofSetStatus === "none" && pieces.length === 0) {
      console.log("[FilesTab] Showing 'Proof Set Required' banner");
      return (
        <motion.div
          className="mb-6 p-4 bg-blue-100 border border-blue-100 rounded-lg text-blue-700 flex items-center gap-3"
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
        >
          <div className="flex-1">
            <p className="font-medium mb-1">Please Setup a Vault</p>
            <p className="text-sm">
              You need to setup a Vault in the Payment setup tab before you can
              upload files. This is a one time setup to onboard you to HotVault.
            </p>
            <Button
              variant="outline"
              size="sm"
              className="mt-2"
              onClick={() => {
                onTabChange?.("payment");
              }}
            >
              Go to Vault Setup
            </Button>
          </div>
        </motion.div>
      );
    }

    if (proofSetStatus === "creating") {
      console.log("[FilesTab] Showing 'Proof Set Creating' banner");
      return (
        <motion.div
          className="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg text-blue-700 flex items-center gap-3"
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
        >
          <div className="flex-shrink-0 bg-blue-100 p-2 rounded-full">
            <div className="animate-spin h-5 w-5 border-2 border-blue-500 rounded-full border-t-transparent"></div>
          </div>
          <div className="flex-1">
            <p className="font-medium mb-1">Proof Set Creation in Progress</p>
            <p className="text-sm">
              Your proof set is being created on FWS. This process typically
              takes few minutesto complete. During this time, uploads are
              disabled until the proof set creation is finalized.
            </p>
          </div>
        </motion.div>
      );
    }

    console.log("[FilesTab] No banner shown");
    return null;
  };

  const getDropzoneMessage = () => {
    if (proofSetStatus === "none" && pieces.length === 0) {
      return "Create a proof set in Payment Setup before uploading";
    }
    if (proofSetStatus === "creating") {
      return "Uploads disabled while proof set is being created";
    }
    return isDragActive
      ? "Drop to upload"
      : "Drag and drop any file here, or click to select";
  };

  return (
    <motion.div
      key="files"
      initial={{ opacity: 0, x: 20 }}
      animate={{ opacity: 1, x: 0 }}
      exit={{ opacity: 0, x: -20 }}
      transition={{ duration: 0.3 }}
      className="p-6"
    >
      <AnimatePresence>
        {authError && (
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -10 }}
            transition={{ duration: 0.2 }}
            className="bg-red-50 border-l-4 border-red-500 text-red-700 p-4 mb-6 rounded-md shadow-sm"
          >
            <div className="flex items-center">
              <svg
                className="h-5 w-5 text-red-500 mr-2"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
                />
              </svg>
              <span className="font-medium">Auth Error:</span>
              <span className="ml-2">{authError}</span>
            </div>
            <Button
              className="mt-3 bg-red-100 text-red-800 hover:bg-red-200 transition-colors"
              size="sm"
              onClick={disconnectWallet}
            >
              Login Again
            </Button>
          </motion.div>
        )}
      </AnimatePresence>

      {renderProofSetStatusBanner()}

      {proofSetStatus === "ready" && (
        <div className="mb-6 flex justify-end">
          <a
            href={`http://explore-pdp.xyz:5173/proofsets/${userProofSetId}`}
            target="_blank"
            rel="noopener noreferrer"
            className="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 border bg-background hover:text-accent-foreground h-10 px-4 py-2 gap-2 text-blue-600 border-blue-200 hover:bg-blue-50"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
              className="h-4 w-4"
            >
              <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
            </svg>
            View Your Vault
            <ExternalLink className="h-3 w-3" />
          </a>
        </div>
      )}

      {proofSetStatus === "ready" && (
        <CostBanner
          fileSizeGB={fileSizeGB}
          existingFiles={pieces.map((piece) => ({
            id: piece.id,
            filename: piece.filename,
            size: piece.size,
          }))}
          key={`cost-banner-${lastPaymentRefresh}`} // Add this key to force re-rendering
        />
      )}

      <motion.div
        className="mb-8 bg-white rounded-xl shadow-sm p-6 overflow-hidden"
        variants={fadeInUp}
        initial="hidden"
        animate="visible"
      >
        <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4 mb-6">
          <div>
            <Typography variant="h2" className="text-xl font-mono">
              My Files
            </Typography>
            <Typography
              variant="small"
              className="text-gray-500 mt-1 flex items-center gap-2"
            >
              Upload, manage and share your files
            </Typography>
          </div>
          <div className="flex items-center gap-4">
            <motion.div whileHover={{ scale: 1.02 }} whileTap={{ scale: 0.98 }}>
              <Button
                onClick={handleSubmitImage}
                disabled={isUploadDisabled() || !selectedImage}
                className="px-4 py-2 text-sm font-medium text-white bg-blue-500 rounded-lg hover:bg-blue-600 transition-colors duration-200 shadow-sm hover:shadow focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {isUploadDisabled()
                  ? "Upload Disabled (Create Vault First)"
                  : selectedImage
                  ? "Upload Selected File"
                  : "Select a File First"}
              </Button>
            </motion.div>
          </div>
        </div>

        <div
          {...getRootProps()}
          className={`text-center p-8 rounded-xl border-2 border-dashed transition-all duration-300 cursor-pointer mb-6 ${
            isUploadDisabled()
              ? "border-gray-300 bg-gray-100 cursor-not-allowed"
              : isDragActive
              ? "border-blue-500 bg-blue-50 scale-[1.01]"
              : selectedImage
              ? "border-green-500 bg-green-50"
              : "border-gray-200 hover:border-blue-300 hover:bg-gray-50"
          }`}
        >
          <input {...getInputProps()} />
          <AnimatePresence mode="wait">
            {isUploadDisabled() ? (
              <motion.div
                key="disabled"
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                transition={{ duration: 0.2 }}
                className="py-8 px-4 flex flex-col items-center"
              >
                <motion.div className="w-16 h-16 mb-4 rounded-full bg-gray-200 flex items-center justify-center transition-colors duration-300 border-2 border-gray-300">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    className="h-7 w-7 text-gray-400"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={1.5}
                      d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"
                    />
                  </svg>
                </motion.div>
                <Typography
                  variant="body"
                  className="text-gray-500 transition-colors duration-300 mb-1"
                >
                  Uploads disabled
                </Typography>
                <Typography variant="small" className="text-gray-400">
                  Please wait for proof set creation to complete
                </Typography>
              </motion.div>
            ) : selectedImage ? (
              <motion.div
                key="preview"
                className="relative mx-auto flex flex-col items-center"
                initial={{ opacity: 0, scale: 0.95 }}
                animate={{ opacity: 1, scale: 1 }}
                exit={{ opacity: 0, scale: 0.95 }}
                transition={{ duration: 0.2 }}
              >
                <div className="mb-2 text-base font-medium text-gray-700">
                  Preview
                </div>
                <div className="relative max-w-md overflow-hidden">
                  {previewUrl ? (
                    <Image
                      src={previewUrl}
                      alt="Preview"
                      className="block max-h-48 w-auto h-auto rounded-md shadow-sm object-contain bg-white"
                      width={0}
                      height={0}
                      sizes="100vw"
                    />
                  ) : (
                    <div className="w-72 h-48 rounded-md shadow-sm bg-white border border-gray-100 flex items-center justify-center overflow-hidden">
                      <div className="flex flex-col items-center justify-center p-6">
                        {(() => {
                          const fileType = getFilePreviewType(
                            selectedImage.name
                          );
                          const extension = selectedImage.name
                            .split(".")
                            .pop()
                            ?.toUpperCase();

                          switch (fileType) {
                            case "document":
                              return (
                                <>
                                  <div className="bg-red-50 p-5 rounded-lg mb-3 border border-red-100 shadow-sm">
                                    {getFileIcon(selectedImage.name)}
                                  </div>
                                  <div className="text-center">
                                    <div className="font-medium text-gray-700 mb-1 max-w-[220px] truncate">
                                      {selectedImage.name}
                                    </div>
                                    <div className="text-xs text-white px-3 py-1 bg-red-500 rounded-full">
                                      {extension} DOCUMENT
                                    </div>
                                  </div>
                                </>
                              );

                            case "spreadsheet":
                              return (
                                <>
                                  <div className="bg-green-50 p-5 rounded-lg mb-3 border border-green-100 shadow-sm">
                                    {getFileIcon(selectedImage.name)}
                                  </div>
                                  <div className="text-center">
                                    <div className="font-medium text-gray-700 mb-1 max-w-[220px] truncate">
                                      {selectedImage.name}
                                    </div>
                                    <div className="text-xs text-white px-3 py-1 bg-green-500 rounded-full">
                                      {extension} SPREADSHEET
                                    </div>
                                  </div>
                                </>
                              );

                            case "code":
                              return (
                                <>
                                  <div className="bg-purple-50 p-5 rounded-lg mb-3 border border-purple-100 shadow-sm">
                                    {getFileIcon(selectedImage.name)}
                                  </div>
                                  <div className="text-center">
                                    <div className="font-medium text-gray-700 mb-1 max-w-[220px] truncate">
                                      {selectedImage.name}
                                    </div>
                                    <div className="text-xs text-white px-3 py-1 bg-purple-500 rounded-full">
                                      {extension} CODE
                                    </div>
                                  </div>
                                </>
                              );

                            case "archive":
                              return (
                                <>
                                  <div className="bg-amber-50 p-5 rounded-lg mb-3 border border-amber-100 shadow-sm">
                                    {getFileIcon(selectedImage.name)}
                                  </div>
                                  <div className="text-center">
                                    <div className="font-medium text-gray-700 mb-1 max-w-[220px] truncate">
                                      {selectedImage.name}
                                    </div>
                                    <div className="text-xs text-white px-3 py-1 bg-amber-500 rounded-full">
                                      {extension} ARCHIVE
                                    </div>
                                  </div>
                                </>
                              );

                            case "video":
                              return (
                                <>
                                  <div className="bg-blue-50 p-5 rounded-lg mb-3 border border-blue-100 shadow-sm">
                                    {getFileIcon(selectedImage.name)}
                                  </div>
                                  <div className="text-center">
                                    <div className="font-medium text-gray-700 mb-1 max-w-[220px] truncate">
                                      {selectedImage.name}
                                    </div>
                                    <div className="text-xs text-white px-3 py-1 bg-blue-600 rounded-full">
                                      {extension} VIDEO
                                    </div>
                                  </div>
                                </>
                              );

                            case "audio":
                              return (
                                <>
                                  <div className="bg-green-50 p-5 rounded-lg mb-3 border border-green-100 shadow-sm">
                                    {getFileIcon(selectedImage.name)}
                                  </div>
                                  <div className="text-center">
                                    <div className="font-medium text-gray-700 mb-1 max-w-[220px] truncate">
                                      {selectedImage.name}
                                    </div>
                                    <div className="text-xs text-white px-3 py-1 bg-green-600 rounded-full">
                                      {extension} AUDIO
                                    </div>
                                  </div>
                                </>
                              );

                            default:
                              return (
                                <>
                                  <div className="bg-gray-50 p-5 rounded-lg mb-3 border border-gray-100 shadow-sm">
                                    {getFileIcon(selectedImage.name)}
                                  </div>
                                  <div className="text-center">
                                    <div className="font-medium text-gray-700 mb-1 max-w-[220px] truncate">
                                      {selectedImage.name}
                                    </div>
                                    <div className="text-xs text-gray-500 px-3 py-1 bg-gray-100 rounded-full">
                                      {extension}
                                    </div>
                                  </div>
                                </>
                              );
                          }
                        })()}
                      </div>
                    </div>
                  )}
                  <motion.button
                    onClick={(e) => {
                      e.stopPropagation();
                      setSelectedImage(null);
                      setPreviewUrl(null);
                      setFileSizeGB(0);
                    }}
                    className="absolute top-2 right-2 p-1.5 bg-red-200 text-red-700 rounded-full hover:bg-red-300 transition-colors leading-none shadow-sm"
                    aria-label="Remove file"
                    whileHover={{ scale: 1.1 }}
                    whileTap={{ scale: 0.9 }}
                  >
                    <Trash2 className="w-4 h-4" />
                  </motion.button>
                </div>
                <div className="mt-4 text-sm text-gray-600 max-w-md truncate">
                  {formatFileSize(selectedImage.size || 0)}
                </div>
              </motion.div>
            ) : (
              <motion.div
                key="upload-prompt"
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                transition={{ duration: 0.2 }}
                className="py-8 px-4 flex flex-col items-center"
              >
                <motion.div
                  className={`w-16 h-16 mb-4 rounded-full ${
                    isDragActive ? "bg-blue-100" : "bg-gray-50"
                  } flex items-center justify-center transition-colors duration-300 border-2 ${
                    isDragActive ? "border-blue-300" : "border-gray-200"
                  }`}
                  animate={{
                    scale: isDragActive ? 1.05 : 1,
                    rotate: isDragActive ? [0, -5, 5, -5, 5, 0] : 0,
                  }}
                  transition={{
                    duration: 0.3,
                    rotate: { duration: 0.5, ease: "easeInOut" },
                  }}
                >
                  <svg
                    className={`w-7 h-7 ${
                      isDragActive ? "text-blue-600" : "text-gray-500"
                    } transition-all duration-300`}
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth={1.5}
                      d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"
                    />
                  </svg>
                </motion.div>
                <Typography
                  variant="body"
                  className={`${
                    isUploadDisabled()
                      ? "text-gray-500"
                      : isDragActive
                      ? "text-blue-600 font-medium"
                      : "text-gray-700"
                  } transition-colors duration-300 mb-1`}
                >
                  {getDropzoneMessage()}
                </Typography>
                <Typography variant="small" className="text-gray-400">
                  Accepts any file type
                </Typography>
              </motion.div>
            )}
          </AnimatePresence>
        </div>
        <UploadProgress
          uploadProgress={uploadProgress}
          onCancel={cancelUpload}
          hasActiveAbortController={hasActiveUpload}
        />
      </motion.div>

      <motion.div
        className="bg-white rounded-xl shadow-sm overflow-hidden"
        variants={scaleIn}
        initial="hidden"
        animate="visible"
      >
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Name
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Size
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Uploaded
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Proof
                </th>
                <th className="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Actions
                </th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              <AnimatePresence>
                {isLoading ? (
                  Array(3)
                    .fill(0)
                    .map((_, index) => (
                      <motion.tr
                        key={`skeleton-${index}`}
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                        transition={{ delay: index * 0.05 }}
                      >
                        <td colSpan={6} className="px-6 py-4">
                          <div className="flex items-center">
                            <div className="h-10 w-10 rounded-lg bg-gray-200 animate-pulse"></div>
                            <div className="ml-4 space-y-2">
                              <div className="h-4 bg-gray-200 rounded animate-pulse w-[180px]"></div>
                              <div className="h-3 bg-gray-200 rounded animate-pulse w-[120px]"></div>
                            </div>
                          </div>
                        </td>
                      </motion.tr>
                    ))
                ) : pieces.length === 0 ? (
                  <motion.tr
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    transition={{ duration: 0.3 }}
                  >
                    <td colSpan={6} className="px-6 py-12 text-center">
                      <motion.div
                        className="flex flex-col items-center"
                        initial={{ scale: 0.95 }}
                        animate={{ scale: 1 }}
                        transition={{ duration: 0.3, delay: 0.1 }}
                      >
                        <svg
                          className="h-12 w-12 text-gray-300 mb-4"
                          fill="none"
                          viewBox="0 0 24 24"
                          stroke="currentColor"
                        >
                          <path
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            strokeWidth={1}
                            d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4"
                          />
                        </svg>
                        <Typography
                          variant="body"
                          className="text-gray-500 mb-2"
                        >
                          No files uploaded yet
                        </Typography>
                        <Typography variant="small" className="text-gray-400">
                          Use the upload section above to add your first file
                        </Typography>
                      </motion.div>
                    </td>
                  </motion.tr>
                ) : (
                  pieces.map((piece, index) => renderPieceRow(piece, index))
                )}
              </AnimatePresence>
            </tbody>
          </table>
        </div>
      </motion.div>

      <Dialog open={isRemoveDialogOpen} onOpenChange={setIsRemoveDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle className="flex items-center gap-2 text-red-600">
              <Trash2 className="h-5 w-5" />
              Remove Root
            </DialogTitle>
            <DialogDescription>
              This will schedule the root for removal from the PDP service. The
              file will be removed in 24 hours. This action cannot be undone.
            </DialogDescription>
          </DialogHeader>
          {pieceToRemove && (
            <div className="py-4 border-t border-b border-gray-100 my-4">
              <div className="flex items-center mb-4">
                <div className="text-sm font-medium text-gray-900 mr-2">
                  File:
                </div>
                <div className="text-sm text-gray-600">
                  {pieceToRemove.filename}
                </div>
              </div>
              <div className="mb-2">
                <div className="text-sm font-medium text-gray-900 mb-1">
                  CID:
                </div>
                <div className="flex items-start">
                  <textarea
                    className="text-sm text-gray-600 font-mono bg-gray-50 p-2 rounded-md w-full resize-none border border-gray-200"
                    value={pieceToRemove.cid}
                    readOnly
                    rows={2}
                    style={{ maxWidth: "400px" }}
                  />
                  <button
                    onClick={() => {
                      navigator.clipboard.writeText(pieceToRemove.cid);
                      toast.success("CID copied to clipboard");
                    }}
                    className="ml-2 p-1 text-gray-500 hover:text-gray-700"
                    title="Copy CID"
                  >
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="16"
                      height="16"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      className="feather feather-copy"
                    >
                      <rect
                        x="9"
                        y="9"
                        width="13"
                        height="13"
                        rx="2"
                        ry="2"
                      ></rect>
                      <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                  </button>
                </div>
              </div>
            </div>
          )}
          <div className="bg-amber-50 border-l-4 border-amber-500 text-amber-700 p-3 rounded-md mt-2">
            <div className="flex">
              <AlertTriangle className="h-5 w-5 text-amber-600 mr-2 flex-shrink-0" />
              <div>
                <p className="text-sm font-medium">Warning</p>
                <p className="text-sm">
                  This file will be removed from the service and cannot be
                  restored.
                </p>
              </div>
            </div>
          </div>
          <DialogFooter>
            <Button
              variant="outline"
              onClick={() => setIsRemoveDialogOpen(false)}
            >
              Cancel
            </Button>
            <Button
              onClick={submitRemoveRoot}
              variant="destructive"
              className="bg-red-600 hover:bg-red-700"
            >
              Schedule Removal
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <Dialog open={isProofDialogOpen} onOpenChange={setIsProofDialogOpen}>
        <DialogContent className="max-w-3xl">
          <DialogHeader>
            <DialogTitle className="flex items-center gap-2">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="h-5 w-5 text-green-600"
              >
                <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
              </svg>
              Proof Details
            </DialogTitle>
            <DialogDescription>
              View verification proof information for this file
            </DialogDescription>
          </DialogHeader>

          {selectedProof && (
            <div className="py-4">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="p-3 bg-gray-50 rounded-lg">
                  <h3 className="text-sm font-medium text-gray-500 mb-1">
                    File
                  </h3>
                  <p className="text-sm font-medium break-all">
                    {selectedProof.pieceFilename}
                  </p>
                </div>
                <div className="p-3 bg-gray-50 rounded-lg">
                  <h3 className="text-sm font-medium text-gray-500 mb-1">
                    Proof Set ID
                  </h3>
                  <p className="text-sm font-medium font-mono flex items-center gap-1">
                    {selectedProof.serviceProofSetId}
                    <button
                      onClick={() => {
                        navigator.clipboard.writeText(
                          selectedProof.serviceProofSetId || ""
                        );
                        toast.success("Proof Set ID copied to clipboard");
                      }}
                      className="text-blue-500 hover:text-blue-700"
                      title="Copy Proof Set ID"
                    >
                      <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="14"
                        height="14"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      >
                        <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                        <rect
                          x="8"
                          y="2"
                          width="8"
                          height="4"
                          rx="1"
                          ry="1"
                        ></rect>
                      </svg>
                    </button>
                  </p>
                </div>

                {selectedProof.rootId && (
                  <div className="col-span-1 md:col-span-2 p-3 bg-purple-50 rounded-lg border border-purple-100">
                    <h3 className="text-sm font-medium text-gray-700 mb-1 flex items-center">
                      <svg
                        xmlns="http://www.w3.org/2000/svg"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        className="h-4 w-4 mr-1 text-purple-500"
                      >
                        <path d="M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6"></path>
                        <line x1="2" y1="20" x2="2" y2="20"></line>
                      </svg>
                      Proof Set Root
                    </h3>
                    <div className="flex items-center gap-1 bg-white rounded p-3 text-sm font-mono break-all">
                      {selectedProof.rootId}
                      <button
                        onClick={() => {
                          navigator.clipboard.writeText(
                            selectedProof.rootId || ""
                          );
                          toast.success("Root ID copied to clipboard");
                        }}
                        className="ml-1 text-blue-500 hover:text-blue-700 flex-shrink-0"
                        title="Copy Root ID"
                      >
                        <svg
                          xmlns="http://www.w3.org/2000/svg"
                          width="14"
                          height="14"
                          viewBox="0 0 24 24"
                          fill="none"
                          stroke="currentColor"
                          strokeWidth="2"
                          strokeLinecap="round"
                          strokeLinejoin="round"
                        >
                          <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                          <rect
                            x="8"
                            y="2"
                            width="8"
                            height="4"
                            rx="1"
                            ry="1"
                          ></rect>
                        </svg>
                      </button>
                    </div>
                    <p className="text-xs text-gray-500 mt-2">
                      The root is a cryptographic commitment that represents
                      this file in the PDP system.
                    </p>
                  </div>
                )}

                <div className="col-span-1 md:col-span-2">
                  <h3 className="text-sm font-medium text-gray-500 mb-1">
                    Content ID (CID)
                  </h3>
                  <div className="flex items-center gap-1 bg-gray-50 rounded p-3 text-sm font-mono break-all">
                    {selectedProof.cid}
                    <button
                      onClick={() => {
                        navigator.clipboard.writeText(selectedProof.cid);
                        toast.success("CID copied to clipboard");
                      }}
                      className="ml-1 text-blue-500 hover:text-blue-700 flex-shrink-0"
                      title="Copy CID"
                    >
                      <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="14"
                        height="14"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      >
                        <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                        <rect
                          x="8"
                          y="2"
                          width="8"
                          height="4"
                          rx="1"
                          ry="1"
                        ></rect>
                      </svg>
                    </button>
                  </div>
                </div>
              </div>

              <div className="mt-6 bg-gradient-to-r from-green-50 to-blue-50 p-5 rounded-lg border border-gray-200">
                <h3 className="text-sm font-semibold mb-3 flex items-center gap-2">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    className="h-4 w-4 text-green-600"
                  >
                    <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                    <polyline points="22 4 12 14.01 9 11.01"></polyline>
                  </svg>
                  View Proof in PDP Explorer
                </h3>
                <p className="text-sm text-gray-600 mb-3">
                  The PDP Explorer provides detailed verification information
                  about your data&apos;s proof of storage.
                </p>
                <div className="flex flex-col gap-2">
                  <Button
                    className="gap-2 justify-start bg-gradient-to-r from-green-500 to-blue-500 hover:from-green-600 hover:to-blue-600 text-white"
                    onClick={() =>
                      window.open(
                        ` http://explore-pdp.xyz:5173/proofsets/${selectedProof?.serviceProofSetId}`,
                        "_blank"
                      )
                    }
                  >
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      className="h-4 w-4"
                    >
                      <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                    </svg>
                    View Proof Set #{selectedProof?.serviceProofSetId}
                  </Button>
                </div>
              </div>
            </div>
          )}

          <DialogFooter>
            <Button
              onClick={() => setIsProofDialogOpen(false)}
              variant="outline"
            >
              Close
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </motion.div>
  );
};
</file>

<file path="examples/hotvault-demo/client/src/app/dashboard/_components/FileUploadSection.tsx">
"use client";

import { useState, useCallback, useRef } from "react";
import { useAuth } from "@/contexts/AuthContext";
import { useDropzone } from "react-dropzone";
import { Button } from "@/components/ui/button";
import { motion, AnimatePresence } from "framer-motion";
import Image from "next/image";
import { useRouter } from "next/navigation";
import { Typography } from "@/components/ui/typography";
import { API_BASE_URL } from "@/lib/constants";
import { toast } from "sonner";
import { useUploadStore } from "@/store/upload-store";
import { Loader, AlertTriangle, ExternalLink } from "lucide-react";
import { CostBanner } from "./CostBanner";
import { formatFileSize } from "@/lib/utils";
import ChunkedUploader from "@/components/ChunkedUploader";

interface FileUploadProps {
  onUploadSuccess: () => void;
}

export const FileUploadSection: React.FC<FileUploadProps> = ({
  onUploadSuccess,
}) => {
  const [selectedImage, setSelectedImage] = useState<File | null>(null);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [fileSizeGB, setFileSizeGB] = useState<number>(0);
  const router = useRouter();
  const { proofSetReady, isLoading: isAuthLoading, userProofSetId } = useAuth();
  const { uploadProgress, setUploadProgress } = useUploadStore();
  const [useChunkedUpload, setUseChunkedUpload] = useState<boolean>(false);

  const abortControllerRef = useRef<AbortController | null>(null);
  const uploadTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const uploadStartTimeRef = useRef<number | null>(null);

  const handleSubmitImage = async () => {
    if (!selectedImage) return;

    const token = localStorage.getItem("jwt_token");
    if (!token) {
      toast.error("Authentication required. Please login again.");
      return;
    }

    abortControllerRef.current = new AbortController();
    const signal = abortControllerRef.current.signal;

    uploadStartTimeRef.current = Date.now();

    const formData = new FormData();
    formData.append("file", selectedImage);

    try {
      setUploadProgress({
        status: "uploading",
        progress: 0,
        lastUpdated: Date.now(),
        isStalled: false,
        filename: selectedImage.name,
      });

      uploadTimeoutRef.current = setTimeout(() => {
        setUploadProgress((prev) => ({
          ...(prev || { status: "uploading", filename: selectedImage.name }),
          isStalled: true,
        }));
      }, 30000);

      console.log(
        `[FileUploadSection] üöÄ Uploading ${selectedImage.name} to ${API_BASE_URL}/api/v1/upload`
      );

      const xhr = new XMLHttpRequest();

      const uploadPromise = new Promise((resolve, reject) => {
        xhr.open("POST", `${API_BASE_URL}/api/v1/upload`, true);
        xhr.setRequestHeader("Authorization", `Bearer ${token}`);

        xhr.upload.onprogress = (event) => {
          if (event.lengthComputable) {
            const percentComplete = Math.round(
              (event.loaded / event.total) * 100
            );
            setUploadProgress((prev) => ({
              ...(prev || {
                status: "uploading",
                filename: selectedImage.name,
              }),
              progress: percentComplete,
              lastUpdated: Date.now(),
              isStalled: false,
            }));

            if (uploadTimeoutRef.current) {
              clearTimeout(uploadTimeoutRef.current);
            }
            uploadTimeoutRef.current = setTimeout(() => {
              setUploadProgress((prev) => ({
                ...(prev || {
                  status: "uploading",
                  filename: selectedImage.name,
                }),
                isStalled: true,
              }));
            }, 30000);
          }
        };

        xhr.onload = function () {
          if (xhr.status >= 200 && xhr.status < 300) {
            try {
              const data = JSON.parse(xhr.responseText) as {
                status: string;
                progress: number;
                message?: string;
                cid?: string;
                jobId?: string;
                proofSetId?: string;
              };
              resolve(data);
            } catch {
              reject(new Error("Invalid JSON response"));
            }
          } else {
            let errorMessage = "Upload failed";
            try {
              const errorData = JSON.parse(xhr.responseText);
              errorMessage =
                errorData.message || errorData.error || errorMessage;
            } catch {
              errorMessage = xhr.responseText || errorMessage;
            }
            reject(new Error(errorMessage));
          }
        };

        xhr.onerror = () => reject(new Error("Network error during upload"));
        xhr.ontimeout = () => reject(new Error("Upload request timed out"));

        xhr.onabort = () => {
          console.log("[FileUploadSection] Upload aborted");
          reject(new Error("AbortError"));
        };

        xhr.timeout = 3600000;

        xhr.send(formData);

        if (signal) {
          signal.addEventListener("abort", () => {
            xhr.abort();
          });
        }
      });

      const data = (await uploadPromise) as {
        status: string;
        progress: number;
        message?: string;
        cid?: string;
        jobId?: string;
        proofSetId?: string;
      };

      if (uploadTimeoutRef.current) {
        clearTimeout(uploadTimeoutRef.current);
        uploadTimeoutRef.current = null;
      }

      setUploadProgress({
        status: "success",
        cid: data.cid,
        message: "File uploaded successfully!",
        lastUpdated: Date.now(),
        jobId: data.jobId,
      });

      if (data.jobId) {
        setUploadProgress((prev) => ({
          ...(prev || { filename: selectedImage.name }),
          status: "processing",
        }));

        const pollStatus = async () => {
          try {
            const statusResponse = await fetch(
              `${API_BASE_URL}/api/v1/upload/status/${data.jobId}`,
              {
                headers: {
                  Authorization: `Bearer ${token}`,
                },
              }
            );

            if (!statusResponse.ok) {
              throw new Error("Failed to check proof status");
            }

            const statusData = await statusResponse.json();

            if (statusData.status === "complete") {
              setUploadProgress((prev) => ({
                ...(prev || { filename: selectedImage.name }),
                status: "complete",
                message: "File uploaded and proof generated!",
                serviceProofSetId: statusData.serviceProofSetId,
              }));

              if (pollIntervalRef.current) {
                clearInterval(pollIntervalRef.current);
                pollIntervalRef.current = null;
              }

              onUploadSuccess();

              setTimeout(() => {
                setUploadProgress({
                  status: "complete",
                  message: "Upload complete",
                });
                setSelectedImage(null);
                setPreviewUrl(null);
              }, 5000);
            } else if (statusData.status === "failed") {
              console.error(
                "[FileUploadSection] ‚ùå Proof generation failed:",
                statusData
              );
              setUploadProgress((prev) => ({
                ...(prev || { filename: selectedImage.name }),
                status: "error",
                error: statusData.error || "Proof generation failed",
              }));

              if (pollIntervalRef.current) {
                clearInterval(pollIntervalRef.current);
                pollIntervalRef.current = null;
              }
            } else {
              setUploadProgress((prev) => ({
                ...(prev || { filename: selectedImage.name }),
                status: statusData.status,
                progress: statusData.progress,
                message: statusData.message,
                lastUpdated: Date.now(),
                isStalled: false,
                serviceProofSetId:
                  statusData.proofSetId || prev?.serviceProofSetId,
              }));
            }
          } catch (error) {
            console.error(
              "[FileUploadSection] ‚ùå Error polling status:",
              error
            );
          }
        };

        pollStatus();
        pollIntervalRef.current = setInterval(pollStatus, 3000);
      } else {
        onUploadSuccess();

        setTimeout(() => {
          setUploadProgress({
            status: "complete",
            message: "Upload complete",
          });
          setSelectedImage(null);
          setPreviewUrl(null);
        }, 5000);
      }
    } catch (error) {
      if (uploadTimeoutRef.current) {
        clearTimeout(uploadTimeoutRef.current);
        uploadTimeoutRef.current = null;
      }

      console.error("[FileUploadSection] üí• Upload caught error:", error);
      if (error instanceof Error) {
        if (error.name !== "AbortError") {
          setUploadProgress({
            status: "error",
            error: error.message,
            lastUpdated: Date.now(),
          });
          toast.error(`Upload failed: ${error.message}`);
        }
      }
    }
  };

  const renderUploadProgress = () => {
    if (!uploadProgress) return null;

    const getStatusText = () => {
      switch (uploadProgress.status) {
        case "uploading":
          return uploadProgress.isStalled
            ? "Upload seems to be taking longer than expected..."
            : "Uploading file...";
        case "processing":
          return "Processing and generating proof...";
        case "adding_root":
          return `Adding file to proof set${
            uploadProgress.serviceProofSetId
              ? ` (${uploadProgress.serviceProofSetId})`
              : ""
          }...`;
        case "finalizing":
          return "Finalizing proof set registration...";
        case "success":
          return "File uploaded successfully!";
        case "complete":
          return "File uploaded and proof generated!";
        case "error":
          return `Error: ${uploadProgress.error || "Something went wrong"}`;
        case "pending":
          return "Waiting for proof set creation to complete...";
        default:
          return "Processing...";
      }
    };

    const getProgressBarColor = () => {
      switch (uploadProgress.status) {
        case "error":
          return "bg-red-500";
        case "success":
        case "complete":
          return "bg-green-500";
        case "processing":
          return "bg-blue-500";
        default:
          return "bg-blue-500";
      }
    };

    let progressWidth = "0%";
    if (uploadProgress.status === "uploading") {
      progressWidth = `${uploadProgress.progress || 0}%`;
    } else if (uploadProgress.status === "processing") {
      progressWidth = `${uploadProgress.progress || 50}%`;
    } else if (
      uploadProgress.status === "success" ||
      uploadProgress.status === "complete"
    ) {
      progressWidth = "100%";
    }

    return (
      <motion.div
        initial={{ opacity: 0, y: 10 }}
        animate={{ opacity: 1, y: 0 }}
        className="bg-white border rounded-lg p-4 mt-6 shadow-sm"
      >
        <div className="flex justify-between items-center mb-2">
          <div className="font-medium text-sm">{getStatusText()}</div>
        </div>

        <div className="w-full bg-gray-200 rounded-full h-2 overflow-hidden">
          <motion.div
            initial={{ width: "0%" }}
            animate={{ width: progressWidth }}
            transition={{ duration: 0.5 }}
            className={`h-full ${getProgressBarColor()}`}
          ></motion.div>
        </div>

        {uploadProgress.message && (
          <div className="mt-2 text-sm text-gray-600">
            {uploadProgress.message}
          </div>
        )}

        {uploadProgress.cid && (
          <div className="mt-2 text-xs font-mono bg-gray-50 p-2 rounded border break-all">
            CID: {uploadProgress.cid}
          </div>
        )}
      </motion.div>
    );
  };

  const onDrop = useCallback((acceptedFiles: File[]) => {
    if (acceptedFiles.length === 0) return;

    const file = acceptedFiles[0];
    if (!file.type.startsWith("image/")) {
      toast.error("Only image files are allowed (jpg, png, gif, etc.)");
      return;
    }

    // const maxFileSize = 100 * 1024 * 1024;
    // if (file.size > maxFileSize) {
    //   toast.error(
    //     `File is too large. Maximum size is 100MB. Current size: ${formatFileSize(
    //       file.size
    //     )}`
    //   );
    //   return;
    // }

    setSelectedImage(file);
    setFileSizeGB(file.size / (1024 * 1024 * 1024));
    const url = URL.createObjectURL(file);
    setPreviewUrl(url);
  }, []);

  const { getRootProps, getInputProps, isDragActive, fileRejections } =
    useDropzone({
      onDrop,
      maxFiles: 1,
      accept: {
        "image/*": [".jpg", ".jpeg", ".png", ".gif", ".webp", ".bmp", ".svg"],
      },
    });

  if (isAuthLoading) {
    return (
      <div className="space-y-4 mb-8 p-6 bg-white rounded-xl shadow-sm border flex items-center justify-center min-h-[200px]">
        <Loader className="animate-spin text-gray-400" size={24} />
        <Typography variant="muted" className="ml-2">
          Loading user status...
        </Typography>
      </div>
    );
  }

  function isUploadDisabled() {
    return !proofSetReady;
  }

  return (
    <div className="w-full space-y-4">
      <CostBanner fileSizeGB={fileSizeGB} />
      <div className="flex flex-col md:flex-row md:items-center justify-between gap-4 mb-4">
        <Typography variant="h3" className="text-xl font-semibold">
          Upload New Image
        </Typography>
        {proofSetReady && (
          <motion.div whileHover={{ scale: 1.02 }} whileTap={{ scale: 0.98 }}>
            <a
              href={`http://explore-pdp.xyz:5173/proofsets/${userProofSetId}`}
              target="_blank"
              rel="noopener noreferrer"
              className="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 border bg-background hover:text-accent-foreground h-10 px-4 py-2 gap-2 text-blue-600 border-blue-200 hover:bg-blue-50"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="h-4 w-4"
              >
                <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
              </svg>
              View Your Vault
              <ExternalLink className="h-3 w-3" />
            </a>
          </motion.div>
        )}
      </div>

      <div className="bg-white rounded-xl shadow-sm border p-6">
        <div className="flex flex-col md:flex-row gap-4 items-start md:items-center justify-between">
          <div className="flex-1">
            <Typography variant="h4" className="text-lg font-medium mb-1">
              {proofSetReady ? "Add an image to storage" : "Proof Set Required"}
            </Typography>
            <Typography variant="muted" className="text-gray-500 text-sm">
              {proofSetReady
                ? "Upload any image file (JPG, PNG, GIF, etc.) to store it securely with automated proof generation."
                : "Please complete the payment setup to activate your proof set before uploading images."}
            </Typography>
          </div>
          <div className="flex space-x-2">
            <motion.div whileHover={{ scale: 1.02 }} whileTap={{ scale: 0.98 }}>
              <Button
                onClick={handleSubmitImage}
                disabled={!selectedImage || !proofSetReady || useChunkedUpload}
                className="px-4 py-2 text-sm font-medium text-white bg-blue-500 rounded-lg hover:bg-blue-600 transition-colors duration-200 shadow-sm hover:shadow focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {selectedImage ? "Upload Selected Image" : "Upload Image"}
              </Button>
            </motion.div>
          </div>
        </div>

        {/* Upload mode toggle */}
        <div className="mt-4 mb-2 flex items-center justify-end">
          <div className="flex items-center space-x-2">
            <span className="text-sm text-gray-500">Standard Upload</span>
            <label className="relative inline-flex items-center cursor-pointer">
              <input
                type="checkbox"
                className="sr-only peer"
                checked={useChunkedUpload}
                onChange={() => setUseChunkedUpload(!useChunkedUpload)}
              />
              <div className="w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
            </label>
            <span className="text-sm text-gray-500">Large File Upload</span>
          </div>
        </div>

        {useChunkedUpload ? (
          <div className="mt-6">
            <ChunkedUploader
              onUploadSuccess={() => {
                onUploadSuccess();
              }}
              accept="image/*"
              maxFileSize={10 * 1024 * 1024 * 1024}
              chunkSize={5 * 1024 * 1024}
            />
          </div>
        ) : (
          <div
            {...getRootProps()}
            className={`text-center p-8 rounded-xl border-2 border-dashed transition-all duration-300 mt-6 ${
              proofSetReady
                ? "cursor-pointer"
                : "cursor-not-allowed bg-gray-50 opacity-70"
            } ${
              isDragActive
                ? "border-blue-500 bg-blue-50 scale-[1.01]"
                : selectedImage
                ? "border-green-500 bg-green-50"
                : "border-gray-200 hover:border-blue-300 hover:bg-gray-50"
            }`}
            onClick={(e) => !proofSetReady && e.stopPropagation()}
          >
            <input {...getInputProps()} disabled={!proofSetReady} />
            <AnimatePresence mode="wait">
              {!proofSetReady ? (
                <motion.div
                  key="proof-set-required"
                  className="flex flex-col items-center justify-center text-gray-500"
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  exit={{ opacity: 0 }}
                >
                  <AlertTriangle size={40} className="mb-3 text-orange-400" />
                  <Typography
                    variant="h4"
                    className="font-medium text-orange-600 mb-1"
                  >
                    Proof Set Required
                  </Typography>
                  <Typography variant="muted" className="text-sm">
                    Go to the{" "}
                    <a
                      href="#"
                      onClick={(e) => {
                        e.preventDefault();
                        router.push("/dashboard?tab=payment");
                      }}
                      className="text-blue-500 hover:underline font-medium"
                    >
                      Payment Setup
                    </a>{" "}
                    tab to complete the required steps.
                  </Typography>
                </motion.div>
              ) : selectedImage ? (
                <motion.div
                  key="preview"
                  className="relative mx-auto flex flex-col items-center"
                  initial={{ opacity: 0, scale: 0.95 }}
                  animate={{ opacity: 1, scale: 1 }}
                  exit={{ opacity: 0, scale: 0.95 }}
                  transition={{ duration: 0.2 }}
                >
                  <div className="mb-2 text-base font-medium text-gray-700">
                    Image Preview
                  </div>
                  <div className="relative max-w-md overflow-hidden">
                    <Image
                      src={previewUrl!}
                      alt="Preview"
                      className="block max-h-48 w-auto h-auto rounded-md shadow-sm object-contain bg-white"
                      width={0}
                      height={0}
                      sizes="100vw"
                    />
                    <motion.button
                      onClick={(e) => {
                        e.stopPropagation();
                        setSelectedImage(null);
                        setPreviewUrl(null);
                        setFileSizeGB(0);
                      }}
                      className="absolute top-2 right-2 p-1.5 bg-red-500 text-white rounded-full hover:bg-red-600 transition-colors leading-none shadow-sm"
                      aria-label="Remove image"
                      whileHover={{ scale: 1.1 }}
                      whileTap={{ scale: 0.9 }}
                    >
                      <svg
                        className="w-3 h-3"
                        fill="none"
                        viewBox="0 0 24 24"
                        stroke="currentColor"
                      >
                        <path
                          strokeLinecap="round"
                          strokeLinejoin="round"
                          strokeWidth={3}
                          d="M6 18L18 6M6 6l12 12"
                        />
                      </svg>
                    </motion.button>
                  </div>
                  <div className="mt-4 text-sm text-gray-600">
                    {formatFileSize(selectedImage.size)}
                  </div>
                </motion.div>
              ) : (
                <motion.div
                  key="upload-prompt"
                  initial={{ opacity: 0 }}
                  animate={{ opacity: 1 }}
                  exit={{ opacity: 0 }}
                  transition={{ duration: 0.2 }}
                  className="py-8 px-4 flex flex-col items-center"
                >
                  <motion.div
                    className={`w-16 h-16 mb-4 rounded-full ${
                      isDragActive ? "bg-blue-100" : "bg-gray-50"
                    } flex items-center justify-center transition-colors duration-300 border-2 ${
                      isDragActive ? "border-blue-300" : "border-gray-200"
                    }`}
                    animate={{
                      scale: isDragActive ? 1.05 : 1,
                      rotate: isDragActive ? [0, -5, 5, -5, 5, 0] : 0,
                    }}
                    transition={{
                      duration: 0.3,
                      rotate: { duration: 0.5, ease: "easeInOut" },
                    }}
                  >
                    <svg
                      className={`w-7 h-7 ${
                        isDragActive ? "text-blue-600" : "text-gray-500"
                      } transition-all duration-300`}
                      fill="none"
                      viewBox="0 0 24 24"
                      stroke="currentColor"
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={1.5}
                        d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"
                      />
                    </svg>
                  </motion.div>
                  <Typography
                    variant="body"
                    className={`${
                      isUploadDisabled()
                        ? "text-gray-500"
                        : isDragActive
                        ? "text-blue-600 font-medium"
                        : "text-gray-700"
                    } transition-colors duration-300 mb-1`}
                  >
                    {isDragActive
                      ? "Drop image here"
                      : "Drag and drop an image, or click to select"}
                  </Typography>
                  <Typography variant="small" className="text-gray-400">
                    Supports JPG, PNG, GIF, WebP, and other image formats
                  </Typography>
                  {fileRejections.length > 0 && (
                    <Typography variant="small" className="text-red-500 mt-2">
                      Only image files are allowed
                    </Typography>
                  )}
                  <Typography variant="small" className="text-gray-400 mt-3">
                    For files larger than 100MB, use the &quot;Large File
                    Upload&quot; option
                  </Typography>
                </motion.div>
              )}
            </AnimatePresence>
          </div>
        )}

        {proofSetReady && !useChunkedUpload && renderUploadProgress()}
      </div>
    </div>
  );
};
</file>

<file path="examples/hotvault-demo/client/src/app/dashboard/_components/index.ts">
export { DashboardHeader } from "./DashboardHeader";
export { FilesTab } from "./FilesTab";
export { TokenBalanceCard } from "./TokenBalanceCard";
export { PaymentSetupTab } from "./PaymentSetupTab";
export { FileIcon } from "./FileIcon";
export { FileRowComponent } from "./FileRowComponent";
export { ProofDetailsDialog } from "./ProofDetailsDialog";
export { RemoveConfirmationDialog } from "./RemoveConfirmationDialog";
export * from "./types";
</file>

<file path="examples/hotvault-demo/client/src/app/dashboard/_components/PaymentBalanceHeader.tsx">
"use client";

import { usePayment } from "@/contexts/PaymentContext";
import { formatCurrency } from "@/lib/utils";
import { Plus, Loader, Shield, ChevronDown, Wallet } from "lucide-react";
import { useEffect, useState, useRef } from "react";
import { UPLOAD_COMPLETED_EVENT } from "@/components/ui/global-upload-progress";
import { BALANCE_UPDATED_EVENT } from "@/contexts/PaymentContext";
import { toast } from "sonner";
import * as Constants from "@/lib/constants";

export const ROOT_REMOVED_EVENT = "ROOT_REMOVED";

export const PaymentBalanceHeader = () => {
  const {
    paymentStatus,
    refreshPaymentSetupStatus,
    depositFunds,
    approveToken,
  } = usePayment();
  const [showDetails, setShowDetails] = useState(false);
  const [isAddingFunds, setIsAddingFunds] = useState(false);
  const [isSettingAllowance, setIsSettingAllowance] = useState(false);
  const [depositAmount, setDepositAmount] = useState("");
  const [allowanceAmount, setAllowanceAmount] = useState("");
  const [isProcessing, setIsProcessing] = useState(false);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const detailsRef = useRef<HTMLDivElement>(null);

  const lastRefreshTimeRef = useRef<number>(0);
  const DEBOUNCE_INTERVAL = 1500;

  const refreshPaymentWithIndicator = async () => {
    try {
      setIsRefreshing(true);
      await refreshPaymentSetupStatus();
    } finally {
      setTimeout(() => setIsRefreshing(false), 500);
    }
  };

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        detailsRef.current &&
        !detailsRef.current.contains(event.target as Node)
      ) {
        setShowDetails(false);
        setIsAddingFunds(false);
        setIsSettingAllowance(false);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  useEffect(() => {
    const handleUploadComplete = () => {
      console.log(
        "[PaymentBalanceHeader] File upload completed, refreshing balance"
      );
      refreshPaymentWithIndicator();
    };

    const handleRootRemoved = () => {
      console.log("[PaymentBalanceHeader] Root removed, refreshing balance");
      refreshPaymentWithIndicator();
    };

    const handleBalanceUpdate = (event: CustomEvent) => {
      console.log("[PaymentBalanceHeader] Balance updated:", event.detail);

      const now = Date.now();
      if (now - lastRefreshTimeRef.current < DEBOUNCE_INTERVAL) {
        console.log("[PaymentBalanceHeader] Skipping refresh due to debounce", {
          timeSinceLastRefresh: now - lastRefreshTimeRef.current,
          debounceInterval: DEBOUNCE_INTERVAL,
        });
        return;
      }

      lastRefreshTimeRef.current = now;

      refreshPaymentWithIndicator()
        .then(() => {
          console.log(
            "[PaymentBalanceHeader] Payment status refreshed after balance update"
          );
          setShowDetails(false);
        })
        .catch((error) => {
          console.error(
            "[PaymentBalanceHeader] Error refreshing payment status:",
            error
          );
        });
    };

    window.addEventListener(UPLOAD_COMPLETED_EVENT, handleUploadComplete);
    window.addEventListener(ROOT_REMOVED_EVENT, handleRootRemoved);
    window.addEventListener(
      BALANCE_UPDATED_EVENT,
      handleBalanceUpdate as EventListener
    );

    return () => {
      window.removeEventListener(UPLOAD_COMPLETED_EVENT, handleUploadComplete);
      window.removeEventListener(ROOT_REMOVED_EVENT, handleRootRemoved);
      window.removeEventListener(
        BALANCE_UPDATED_EVENT,
        handleBalanceUpdate as EventListener
      );
    };
  }, [refreshPaymentSetupStatus]);

  const handleAddFunds = async () => {
    if (!depositAmount || parseFloat(depositAmount) <= 0) {
      toast.error("Please enter a valid amount");
      return;
    }

    setIsProcessing(true);
    try {
      const result = await depositFunds(depositAmount);
      if (result) {
        toast.success(`Successfully deposited ${depositAmount} USDFC`);
        setDepositAmount("");
        setIsAddingFunds(false);
      } else {
        toast.error("Failed to deposit USDFC");
      }
    } catch (error) {
      console.error("Error depositing USDFC:", error);
      toast.error("Error depositing USDFC. Please try again.");
    } finally {
      setIsProcessing(false);
    }
  };

  const handleSetAllowance = async () => {
    if (!allowanceAmount || parseFloat(allowanceAmount) <= 0) {
      toast.error("Please enter a valid amount");
      return;
    }

    setIsProcessing(true);
    try {
      const result = await approveToken(toContractValue(allowanceAmount));
      if (result) {
        toast.success(`Successfully set allowance to ${allowanceAmount} USDFC`);
        setAllowanceAmount("");
        setIsSettingAllowance(false);
      } else {
        toast.error("Failed to set allowance");
      }
    } catch (error) {
      console.error("Error setting allowance:", error);
      toast.error("Error setting allowance. Please try again.");
    } finally {
      setIsProcessing(false);
    }
  };

  const toContractValue = (value: string): string => {
    if (!value) return "0";
    return (parseFloat(value) * 1e18).toString();
  };

  if (
    !paymentStatus.isLoading &&
    !paymentStatus.isDeposited &&
    !paymentStatus.proofSetReady &&
    !paymentStatus.isCreatingProofSet
  ) {
    return null;
  }

  return (
    <div className="flex items-center justify-end px-4 h-12">
      <div className="relative" ref={detailsRef}>
        <button
          onClick={() => setShowDetails(!showDetails)}
          className="flex items-center gap-3 px-3 py-1.5 text-sm bg-white hover:bg-gray-50 rounded-md border border-gray-200 transition-colors"
        >
          <div className="flex items-center gap-2">
            <Wallet
              className={`w-4 h-4 ${
                isRefreshing ? "text-blue-500 animate-pulse" : "text-gray-500"
              }`}
            />
            <span>
              {isRefreshing
                ? "Updating..."
                : formatCurrency(paymentStatus.accountFunds) + " USDFC"}
            </span>
          </div>
          <ChevronDown className="w-4 h-4 text-gray-500" />
        </button>

        {showDetails && (
          <div className="absolute right-0 top-full mt-1 w-[320px] bg-white rounded-lg shadow-lg border border-gray-200 divide-y divide-gray-100">
            <div className="p-3">
              <h3 className="text-sm font-medium text-gray-700 mb-2">
                Balance Summary
              </h3>
              <div className="space-y-2">
                <div className="flex justify-between text-sm">
                  <span className="text-gray-600">Wallet Balance:</span>
                  <span className="font-medium">
                    {formatCurrency(paymentStatus.usdcBalance)} USDFC
                  </span>
                </div>
                <div className="flex justify-between text-sm">
                  <span className="text-gray-600">FWS Balance:</span>
                  <span className="font-medium">
                    {formatCurrency(paymentStatus.accountFunds)} USDFC
                  </span>
                </div>
                <div className="flex justify-between text-sm">
                  <span className="text-gray-600">Locked Funds:</span>
                  <span className="font-medium font-mono overflow-hidden text-ellipsis max-w-[150px]">
                    {parseFloat(paymentStatus.lockedFunds.current).toFixed(5) +
                      " USDFC"}
                  </span>
                </div>
                <div className="flex justify-between text-sm">
                  <span className="text-gray-600">
                    Available for Withdrawal:
                  </span>
                  <span className="font-medium font-mono overflow-hidden text-ellipsis max-w-[150px]">
                    {Math.max(
                      0,
                      parseFloat(paymentStatus.accountFunds) -
                        parseFloat(paymentStatus.lockedFunds.current)
                    ).toFixed(5)}{" "}
                    USDFC
                  </span>
                </div>
              </div>
            </div>

            {/* {paymentStatus.operatorApproval && (
              <div className="p-3">
                <h3 className="text-sm font-medium text-gray-700 mb-2">
                  Operator Approval
                </h3>
                <div className="space-y-2">
                  <div className="flex justify-between text-sm">
                    <span className="text-gray-600">Rate Usage:</span>
                    <span className="font-mono text-xs overflow-hidden text-ellipsis max-w-[150px]">
                      {formatContractValue(
                        paymentStatus.operatorApproval.rateUsage
                      )}
                      /
                      {formatContractValue(
                        paymentStatus.operatorApproval.rateAllowance
                      )}{" "}
                      USDFC
                    </span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span className="text-gray-600">Lockup Usage:</span>
                    <span className="font-mono text-xs overflow-hidden text-ellipsis max-w-[150px]">
                      {formatContractValue(
                        paymentStatus.operatorApproval.lockupUsage
                      )}
                      /
                      {formatContractValue(
                        paymentStatus.operatorApproval.lockupAllowance
                      )}{" "}
                      USDFC
                    </span>
                  </div>
                </div>
              </div>
            )} */}

            <div className="p-3">
              <h3 className="text-sm font-medium text-gray-700 mb-2">
                Actions
              </h3>
              <div className="space-y-2">
                <button
                  onClick={() => {
                    setIsAddingFunds(!isAddingFunds);
                    setIsSettingAllowance(false);
                  }}
                  className="w-full text-left px-3 py-2 text-sm rounded hover:bg-gray-50 flex items-center"
                >
                  <Plus className="w-4 h-4 mr-2" />
                  Add Funds
                </button>
                <button
                  onClick={() => {
                    setIsSettingAllowance(!isSettingAllowance);
                    setIsAddingFunds(false);
                  }}
                  className="w-full text-left px-3 py-2 text-sm rounded hover:bg-gray-50 flex items-center"
                >
                  <Shield className="w-4 h-4 mr-2" />
                  Set Allowance
                </button>

                {isAddingFunds && (
                  <div className="mt-2 p-3 bg-gray-50 rounded-lg">
                    <input
                      type="number"
                      value={depositAmount}
                      onChange={(e) => setDepositAmount(e.target.value)}
                      className="w-full rounded border border-gray-300 px-3 py-1.5 text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500"
                      placeholder="Amount to deposit"
                      min="0.01"
                      step="0.01"
                      disabled={isProcessing}
                    />
                    <button
                      onClick={handleAddFunds}
                      disabled={isProcessing || !depositAmount}
                      className="w-full mt-2 px-3 py-1.5 bg-blue-600 text-white rounded text-sm font-medium hover:bg-blue-700 disabled:bg-gray-400 flex items-center justify-center"
                    >
                      {isProcessing ? (
                        <>
                          <Loader size={14} className="animate-spin mr-1" />
                          {paymentStatus.error &&
                          paymentStatus.error.includes("Waiting")
                            ? paymentStatus.error
                            : "Processing..."}
                        </>
                      ) : (
                        "Deposit"
                      )}
                    </button>
                  </div>
                )}

                {isSettingAllowance && (
                  <div className="mt-2 p-3 bg-gray-50 rounded-lg">
                    <input
                      type="number"
                      value={allowanceAmount}
                      onChange={(e) => setAllowanceAmount(e.target.value)}
                      className="w-full rounded border border-gray-300 px-3 py-1.5 text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500"
                      placeholder="Allowance amount"
                      min={Constants.PROOF_SET_FEE}
                      step="0.01"
                      disabled={isProcessing}
                    />
                    <button
                      onClick={handleSetAllowance}
                      disabled={isProcessing || !allowanceAmount}
                      className="w-full mt-2 px-3 py-1.5 bg-blue-600 text-white rounded text-sm font-medium hover:bg-blue-700 disabled:bg-gray-400 flex items-center justify-center"
                    >
                      {isProcessing ? (
                        <>
                          <Loader size={14} className="animate-spin mr-1" />
                          {paymentStatus.error &&
                          paymentStatus.error.includes("Waiting")
                            ? paymentStatus.error
                            : "Processing..."}
                        </>
                      ) : (
                        "Approve"
                      )}
                    </button>
                    <p className="mt-1 text-xs text-gray-600">
                      Min: {Constants.PROOF_SET_FEE} USDFC
                    </p>
                  </div>
                )}
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};
</file>

<file path="examples/hotvault-demo/client/src/app/dashboard/_components/PaymentSetupTab.tsx">
import { useState, useEffect } from "react";
import { usePayment } from "@/contexts/PaymentContext";
import { useAuth } from "@/contexts/AuthContext";
import { TokenBalanceCard } from "./TokenBalanceCard";
import {
  CheckCircle,
  Loader,
  Info,
  AlertTriangle,
  Files,
  ExternalLink,
  RefreshCw,
} from "lucide-react";
import * as Constants from "@/lib/constants";
import { toast } from "react-hot-toast";
import { TransactionHistory } from "./TransactionHistory";
import { DASHBOARD_SECTIONS, DashboardSection } from "@/types/dashboard";
import { BALANCE_UPDATED_EVENT } from "@/contexts/PaymentContext";

enum PaymentStep {
  APPROVE_TOKEN = 0,
  DEPOSIT = 1,
  APPROVE_OPERATOR = 2,
  CREATE_PROOF_SET = 3,
  COMPLETE = 4,
}

interface PaymentSetupTabProps {
  setActiveTab?: (tab: DashboardSection) => void;
}

const StepIcon = ({
  completed,
  active,
  number,
}: {
  completed: boolean;
  active: boolean;
  number: number;
}) => {
  if (completed) {
    return (
      <div className="w-8 h-8 rounded-full bg-green-100 flex items-center justify-center">
        <CheckCircle className="w-5 h-5 text-green-600" />
      </div>
    );
  }
  return (
    <div
      className={`w-8 h-8 rounded-full ${
        active ? "bg-blue-100 text-blue-600" : "bg-gray-100 text-gray-500"
      } flex items-center justify-center`}
    >
      <span className="text-sm font-semibold">{number}</span>
    </div>
  );
};

const formatLargeNumber = (num: string) => {
  const trimmed = num.replace(/\.?0+$/, "");
  if (trimmed.length <= 12) return trimmed;

  return `${trimmed.slice(0, 8)}...${trimmed.slice(-4)}`;
};

const toDisplayValue = (value: string): string => {
  if (!value) return "";
  const numValue = parseFloat(value) / 1e18;
  return numValue.toFixed(5);
};

const toContractValue = (value: string): string => {
  if (!value) return "";
  return (parseFloat(value) * 1e18).toString();
};

export const PaymentSetupTab = ({ setActiveTab }: PaymentSetupTabProps) => {
  const {
    paymentStatus,
    approveToken,
    depositFunds,
    approveServiceOperator,
    refreshPaymentSetupStatus,
    initiateProofSetCreation,
  } = usePayment();
  const { account, userProofSetId } = useAuth();
  const [isProcessing, setIsProcessing] = useState(false);
  const [currentStep, setCurrentStep] = useState<PaymentStep>(
    PaymentStep.APPROVE_TOKEN
  );

  const [tokenAllowance, setTokenAllowance] = useState("100");
  const [depositAmount, setDepositAmount] = useState(
    (parseFloat(Constants.PROOF_SET_FEE) + 0.01).toFixed(2)
  );
  const [rateAllowance, setRateAllowance] = useState("");
  const [lockupAllowance, setLockupAllowance] = useState("");
  const [isUpdatingAllowances, setIsUpdatingAllowances] = useState(false);
  const [isProofSetClicked, setIsProofSetClicked] = useState(false);
  const [isRefreshing, setIsRefreshing] = useState(false);

  useEffect(() => {
    const handleBalanceUpdate = (event: CustomEvent) => {
      console.log("[PaymentSetupTab] Balance updated:", event.detail);
      if (event.detail) {
        if (currentStep === PaymentStep.DEPOSIT) {
          if (
            event.detail.newBalance &&
            parseFloat(event.detail.newBalance) >=
              parseFloat(Constants.PROOF_SET_FEE)
          ) {
            setCurrentStep(PaymentStep.APPROVE_OPERATOR);
          }
        }
      }

      setIsProcessing(false);
    };

    window.addEventListener(
      BALANCE_UPDATED_EVENT,
      handleBalanceUpdate as EventListener
    );

    return () => {
      window.removeEventListener(
        BALANCE_UPDATED_EVENT,
        handleBalanceUpdate as EventListener
      );
    };
  }, [currentStep]);

  useEffect(() => {
    if (paymentStatus.isOperatorApproved && !isUpdatingAllowances) {
      setRateAllowance(
        toDisplayValue(paymentStatus.operatorApproval?.rateAllowance || "")
      );
      setLockupAllowance(
        toDisplayValue(paymentStatus.operatorApproval?.lockupAllowance || "")
      );
    }
  }, [
    paymentStatus.isOperatorApproved,
    paymentStatus.operatorApproval,
    isUpdatingAllowances,
  ]);

  useEffect(() => {
    if (paymentStatus.proofSetReady) {
      setCurrentStep(PaymentStep.COMPLETE);
      setIsProofSetClicked(false);
    } else if (paymentStatus.isCreatingProofSet) {
      setCurrentStep(PaymentStep.CREATE_PROOF_SET);
    } else if (paymentStatus.isOperatorApproved) {
      setCurrentStep(PaymentStep.CREATE_PROOF_SET);
    } else if (paymentStatus.isDeposited) {
      setCurrentStep(PaymentStep.APPROVE_OPERATOR);
    } else if (paymentStatus.isTokenApproved) {
      setCurrentStep(PaymentStep.DEPOSIT);
    } else {
      setCurrentStep(PaymentStep.APPROVE_TOKEN);
    }
  }, [paymentStatus]);

  useEffect(() => {
    setIsProcessing(false);
  }, [
    account,
    paymentStatus.isTokenApproved,
    paymentStatus.isDeposited,
    paymentStatus.isOperatorApproved,
  ]);

  const handleApproveToken = async () => {
    if (!tokenAllowance || parseFloat(tokenAllowance) <= 0) {
      toast.error("Please enter a valid allowance amount");
      return;
    }

    if (!paymentStatus.hasMinimumBalance) {
      toast.error(
        `You need at least ${Constants.MINIMUM_USDFC_BALANCE} USDFC in your wallet to proceed`
      );
      return;
    }

    setIsProcessing(true);
    try {
      const result = await approveToken(tokenAllowance);
      if (result) {
        toast.success(`USDFC token approved for ${tokenAllowance} USDFC`);
        await refreshPaymentSetupStatus();
      } else {
        toast.error("Failed to approve USDFC token");
      }
    } catch (error) {
      console.error("Error approving token:", error);
      toast.error("Error approving token. Please try again.");
    } finally {
      setIsProcessing(false);
    }
  };

  const handleDeposit = async () => {
    if (
      !depositAmount ||
      parseFloat(depositAmount) < parseFloat(Constants.PROOF_SET_FEE)
    ) {
      toast.error(
        `Deposit amount must be at least ${Constants.PROOF_SET_FEE} USDFC`
      );
      return;
    }

    if (!paymentStatus.hasMinimumBalance) {
      toast.error(
        `You need at least ${Constants.MINIMUM_USDFC_BALANCE} USDFC in your wallet to proceed`
      );
      return;
    }

    setIsProcessing(true);
    try {
      const result = await depositFunds(depositAmount);
      if (result) {
        toast.success(
          `Successfully deposited ${depositAmount} USDFC to FWS funds`
        );
        await refreshPaymentSetupStatus();
      } else {
        toast.error("Failed to deposit USDFC");
      }
    } catch (error) {
      console.error("Error depositing USDFC:", error);
      toast.error("Error depositing USDFC. Please try again.");
    } finally {
      setIsProcessing(false);
    }
  };

  const handleApproveOperator = async () => {
    if (
      !rateAllowance ||
      parseFloat(rateAllowance) <= 0 ||
      !lockupAllowance ||
      parseFloat(lockupAllowance) <= 0
    ) {
      toast.error("Please enter both rate and lockup allowance values");
      return;
    }

    setIsProcessing(true);
    try {
      const result = await approveServiceOperator(
        toContractValue(rateAllowance),
        toContractValue(lockupAllowance)
      );
      if (result) {
        toast.success(
          `PDP Service operator ${
            paymentStatus.isOperatorApproved ? "updated" : "approved"
          } with ${rateAllowance} USDFC rate allowance and ${lockupAllowance} USDFC lockup allowance`
        );
        setIsUpdatingAllowances(false);
        await refreshPaymentSetupStatus();
      } else {
        toast.error(
          `Failed to ${
            paymentStatus.isOperatorApproved ? "update" : "approve"
          } PDP Service operator`
        );
      }
    } catch (error) {
      console.error("Error with operator approval:", error);
      toast.error(
        `Error ${
          paymentStatus.isOperatorApproved ? "updating" : "approving"
        } operator. Please try again.`
      );
    } finally {
      setIsProcessing(false);
    }
  };

  const handleCreateProofSet = async () => {
    if (
      parseFloat(paymentStatus.accountFunds) <
      parseFloat(Constants.PROOF_SET_FEE)
    ) {
      toast.error(
        `Insufficient funds in FWS. You need at least ${Constants.PROOF_SET_FEE} USDFC in your FWS funds to create a proof set.`
      );
      return;
    }

    setIsProofSetClicked(true);
    try {
      const result = await initiateProofSetCreation();
      if (!result) {
        toast.error("Failed to create Hot Vault space");
        setIsProofSetClicked(false);
      }
    } catch (error) {
      console.error("Error creating Hot Vault space:", error);
      toast.error("Error creating Hot Vault space. Please try again.");
      setIsProofSetClicked(false);
    }
  };

  const handleManualRefresh = async () => {
    setIsRefreshing(true);
    try {
      await refreshPaymentSetupStatus();
      toast.success("Balances refreshed", { duration: 2000 });
    } catch (error) {
      console.error("Error refreshing balances:", error);
    } finally {
      setIsRefreshing(false);
    }
  };

  const renderTokenApprovalStep = () => {
    const isActive = currentStep === PaymentStep.APPROVE_TOKEN;
    const isCompleted = currentStep > PaymentStep.APPROVE_TOKEN;

    return (
      <div
        className={`w-full p-6 rounded-2xl transition-all ${
          isCompleted
            ? "bg-green-50"
            : isActive
            ? "bg-white border border-gray-200"
            : "bg-gray-50"
        }`}
      >
        <div className="flex items-start gap-4">
          <StepIcon completed={isCompleted} active={isActive} number={1} />
          <div className="flex-1">
            <div className="flex items-center justify-between">
              <div>
                <h3
                  className={`font-semibold text-lg ${
                    isCompleted
                      ? "text-green-700"
                      : isActive
                      ? "text-gray-900"
                      : "text-gray-600"
                  }`}
                >
                  Authorize USDFC Token
                </h3>
                <p className="text-sm text-gray-500 mt-1">
                  {isCompleted ? "Completed" : "Allow FWS to use your USDFC"}
                </p>
              </div>
              {isCompleted && (
                <span className="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-green-100 text-green-800">
                  Completed
                </span>
              )}
            </div>

            {isActive && (
              <div className="mt-4 space-y-4">
                <div className="bg-blue-50 rounded-lg p-4 flex items-start gap-3">
                  <Info className="w-5 h-5 text-blue-500 mt-0.5" />
                  <div className="flex-1">
                    <p className="text-sm text-blue-900 font-medium">
                      Set Token Allowance
                    </p>
                    <p className="text-sm text-blue-700 mt-1">
                      Specify how many USDFC tokens FWS can transfer on your
                      behalf.
                    </p>
                  </div>
                </div>

                <div className="space-y-3">
                  <input
                    type="number"
                    value={tokenAllowance}
                    onChange={(e) => setTokenAllowance(e.target.value)}
                    className="w-full rounded-lg border border-gray-300 px-4 py-2.5 text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500"
                    placeholder="Allowance amount"
                    min="10"
                    step="0.01"
                    disabled={isProcessing}
                  />
                  <div className="flex items-center justify-between text-sm text-gray-500">
                    <span>Minimum required: 10 USDFC</span>
                    <span>
                      Wallet balance: {paymentStatus.usdcBalance} USDFC
                    </span>
                  </div>
                  <button
                    onClick={handleApproveToken}
                    disabled={!paymentStatus.hasMinimumBalance || isProcessing}
                    className="w-full px-4 py-2.5 bg-blue-600 text-white rounded-lg text-sm font-medium hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed flex items-center justify-center gap-2"
                  >
                    {isProcessing ? (
                      <>
                        <Loader className="w-4 h-4 animate-spin" />
                        {paymentStatus.error &&
                        paymentStatus.error.includes(
                          "Waiting for blockchain confirmation"
                        )
                          ? paymentStatus.error
                          : "Processing..."}
                      </>
                    ) : (
                      "Approve Token"
                    )}
                  </button>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    );
  };

  const renderDepositStep = () => {
    const isActive = currentStep === PaymentStep.DEPOSIT;
    const isCompleted = currentStep > PaymentStep.DEPOSIT;

    return (
      <div
        className={`w-full p-6 rounded-2xl transition-all ${
          isCompleted
            ? "bg-green-50"
            : isActive
            ? "bg-white border border-gray-200"
            : "bg-gray-50"
        }`}
      >
        <div className="flex items-start gap-4">
          <StepIcon completed={isCompleted} active={isActive} number={2} />
          <div className="flex-1">
            <div className="flex items-center justify-between">
              <div>
                <h3
                  className={`font-semibold text-lg ${
                    isCompleted
                      ? "text-green-700"
                      : isActive
                      ? "text-gray-900"
                      : "text-gray-600"
                  }`}
                >
                  Deposit USDFC
                </h3>
                <p className="text-sm text-gray-500 mt-1">
                  {isCompleted ? "Completed" : "Deposit funds into FWS"}
                </p>
              </div>
              {isCompleted && (
                <span className="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-green-100 text-green-800">
                  Completed
                </span>
              )}
            </div>

            {isActive && (
              <div className="mt-4 space-y-4">
                <div className="bg-blue-50 rounded-lg p-4 flex items-start gap-3">
                  <Info className="w-5 h-5 text-blue-500 mt-0.5" />
                  <div className="flex-1">
                    <p className="text-sm text-blue-900 font-medium">
                      Deposit Funds
                    </p>
                    <p className="text-sm text-blue-700 mt-1">
                      Deposit USDFC tokens to fund your vault.
                    </p>
                    {paymentStatus.lastApprovalTimestamp > 0 &&
                      Date.now() - paymentStatus.lastApprovalTimestamp <
                        10000 && (
                        <p className="text-sm text-amber-600 mt-2 font-medium">
                          Note: If you just approved tokens, the system may need
                          a few seconds to confirm the transaction.
                        </p>
                      )}
                  </div>
                </div>

                <div className="space-y-3">
                  <input
                    type="number"
                    value={depositAmount}
                    onChange={(e) => setDepositAmount(e.target.value)}
                    className="w-full rounded-lg border border-gray-300 px-4 py-2.5 text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500"
                    placeholder="Deposit amount"
                    min="10"
                    step="0.01"
                    disabled={isProcessing}
                  />
                  <div className="flex items-center justify-between text-sm text-gray-500">
                    <span>Minimum required: 10 USDFC</span>
                    <span>
                      Wallet balance: {paymentStatus.usdcBalance} USDFC
                    </span>
                  </div>
                  <button
                    onClick={handleDeposit}
                    disabled={!paymentStatus.hasMinimumBalance || isProcessing}
                    className="w-full px-4 py-2.5 bg-blue-600 text-white rounded-lg text-sm font-medium hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed flex items-center justify-center gap-2"
                  >
                    {isProcessing ? (
                      <>
                        <Loader size={14} className="animate-spin mr-1" />
                        {paymentStatus.error &&
                        paymentStatus.error.includes("Waiting")
                          ? paymentStatus.error
                          : "Processing..."}
                      </>
                    ) : (
                      "Deposit Funds"
                    )}
                  </button>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    );
  };

  const renderOperatorApprovalStep = () => {
    const isActive = currentStep === PaymentStep.APPROVE_OPERATOR;
    const isCompleted = currentStep > PaymentStep.APPROVE_OPERATOR;
    const isUpdating = isUpdatingAllowances;

    return (
      <div
        className={`w-full p-6 rounded-2xl transition-all ${
          isCompleted && !isUpdating
            ? "bg-green-50"
            : isActive || isUpdating
            ? "bg-white border border-gray-200"
            : "bg-gray-50"
        }`}
      >
        <div className="flex items-start gap-4">
          <StepIcon
            completed={isCompleted && !isUpdating}
            active={isActive || isUpdating}
            number={3}
          />
          <div className="flex-1">
            <div className="flex items-center justify-between">
              <div>
                <h3
                  className={`font-semibold text-lg ${
                    isCompleted && !isUpdating
                      ? "text-green-700"
                      : isActive || isUpdating
                      ? "text-gray-900"
                      : "text-gray-600"
                  }`}
                >
                  Approve PDP Service on FWS
                </h3>
              </div>
              {isCompleted && !isUpdating ? (
                <span className="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-green-100 text-green-800">
                  Completed
                </span>
              ) : null}
            </div>

            {isCompleted && !isUpdating && !isActive && (
              <div className="mt-4 bg-white rounded-lg border border-gray-200 p-4">
                <div className="space-y-4">
                  <div>
                    <div className="flex items-center justify-between mb-2">
                      <div className="text-sm font-medium text-gray-700">
                        <span>Rate Allowance</span>
                      </div>
                      <div className="p-3 bg-gray-50 rounded-lg">
                        <div className="font-mono text-sm break-all">
                          {formatLargeNumber(
                            toDisplayValue(
                              paymentStatus.operatorApproval?.rateAllowance ||
                                "0"
                            )
                          )}{" "}
                          USDFC/epoch
                        </div>
                      </div>
                    </div>
                  </div>

                  <div>
                    <div className="flex items-center justify-between mb-2">
                      <div className="text-sm font-medium text-gray-700">
                        <span>Lockup Allowance</span>
                      </div>
                      <div className="p-3 bg-gray-50 rounded-lg">
                        <div className="font-mono text-sm break-all">
                          {formatLargeNumber(
                            toDisplayValue(
                              paymentStatus.operatorApproval?.lockupAllowance ||
                                "0"
                            )
                          )}{" "}
                          USDFC
                        </div>
                      </div>
                    </div>
                  </div>

                  <button
                    onClick={() => setIsUpdatingAllowances(true)}
                    className="mt-2 w-full px-4 py-2.5 bg-white border border-gray-200 text-sm font-medium rounded-lg text-gray-700 hover:bg-gray-50 flex items-center justify-center gap-2"
                  >
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="14"
                      height="14"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      className="text-gray-500"
                    >
                      <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" />
                      <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" />
                    </svg>
                    Update Settings
                  </button>
                </div>
              </div>
            )}

            {(isActive || isUpdating) && (
              <div className="mt-4 space-y-4">
                <div className="bg-blue-50 rounded-lg p-4 flex items-start gap-3">
                  <Info className="w-5 h-5 text-blue-500 mt-0.5" />
                  <div className="flex-1">
                    <p className="text-sm text-blue-900 font-medium">
                      Configure Payment Settings
                    </p>
                    <p className="text-sm text-blue-700 mt-1">
                      Set allowances for the PDP Service to manage payments on
                      your behalf.
                    </p>
                  </div>
                </div>

                <div className="space-y-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      Rate Allowance (USDFC/epoch)
                    </label>
                    <p className="text-xs mb-2 font-medium text-gray-500">
                      Maximum USDFC/epoch that PDP can spend from your FWS funds
                    </p>
                    <input
                      type="number"
                      value={rateAllowance}
                      onChange={(e) => setRateAllowance(e.target.value)}
                      className="w-full rounded-lg border border-gray-300 px-4 py-2.5 text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500"
                      placeholder="Enter rate allowance"
                      min="0.01"
                      step="0.01"
                      disabled={isProcessing}
                    />
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      Lockup Allowance (USDFC)
                    </label>
                    <input
                      type="number"
                      value={lockupAllowance}
                      onChange={(e) => setLockupAllowance(e.target.value)}
                      className="w-full rounded-lg border border-gray-300 px-4 py-2.5 text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500"
                      placeholder="Enter lockup allowance"
                      min="0.01"
                      step="0.01"
                      disabled={isProcessing}
                    />
                  </div>

                  <div className="flex gap-3">
                    <button
                      onClick={handleApproveOperator}
                      disabled={isProcessing}
                      className="flex-1 px-4 py-2.5 bg-blue-600 text-white rounded-lg text-sm font-medium hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed flex items-center justify-center gap-2"
                    >
                      {isProcessing ? (
                        <>
                          <Loader className="w-4 h-4 animate-spin" />
                          {paymentStatus.error &&
                          paymentStatus.error.includes(
                            "Waiting for blockchain confirmation"
                          )
                            ? paymentStatus.error
                            : "Processing..."}
                        </>
                      ) : isUpdating ? (
                        "Update Settings"
                      ) : (
                        "Approve"
                      )}
                    </button>
                    {isUpdating && (
                      <button
                        onClick={() => {
                          setIsUpdatingAllowances(false);
                          setRateAllowance(
                            paymentStatus.operatorApproval?.rateAllowance || ""
                          );
                          setLockupAllowance(
                            paymentStatus.operatorApproval?.lockupAllowance ||
                              ""
                          );
                        }}
                        className="px-4 py-2.5 border border-gray-300 text-gray-700 rounded-lg text-sm font-medium hover:bg-gray-50"
                        disabled={isProcessing}
                      >
                        Cancel
                      </button>
                    )}
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    );
  };

  const renderCreateProofSetStep = () => {
    const isActive = currentStep === PaymentStep.CREATE_PROOF_SET;
    const isTrulyCompleted = currentStep > PaymentStep.CREATE_PROOF_SET;
    const isProcessingCreation =
      paymentStatus.isCreatingProofSet && !isTrulyCompleted;

    return (
      <div
        className={`w-full p-6 rounded-2xl transition-all ${
          isTrulyCompleted
            ? "bg-green-50"
            : isActive || isProcessingCreation
            ? "bg-white border border-gray-200"
            : "bg-gray-50"
        }`}
      >
        <div className="flex items-start gap-4">
          <StepIcon
            completed={isTrulyCompleted}
            active={isActive || isProcessingCreation}
            number={4}
          />
          <div className="flex-1">
            <div className="flex items-center justify-between">
              <div>
                <h3
                  className={`font-semibold text-lg ${
                    isTrulyCompleted
                      ? "text-green-700"
                      : isActive || isProcessingCreation
                      ? "text-gray-900"
                      : "text-gray-600"
                  }`}
                >
                  Get Hot Vault Space
                </h3>
                <p className="text-sm text-gray-500 mt-1">
                  {isTrulyCompleted
                    ? "Completed"
                    : isProcessingCreation || isProofSetClicked
                    ? "Creation in progress..."
                    : "This will cost you a one-time fee of 0.1 USDFC from your FWS funds."}
                </p>
              </div>
              {isTrulyCompleted && (
                <span className="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-green-100 text-green-800">
                  We have deducted 0.1 USDFC from your FWS funds.
                </span>
              )}
            </div>

            {isActive && !isProcessingCreation && !isProofSetClicked && (
              <div className="mt-4 space-y-4">
                <div className="bg-blue-50 rounded-lg p-4 flex items-start gap-3">
                  <Info className="w-5 h-5 text-blue-500 mt-0.5" />
                  <div className="flex-1">
                    <p className="text-sm text-blue-900 font-medium">
                      Create Your Proof Set
                    </p>
                    <p className="text-sm text-blue-700 mt-1">
                      This will register your unique proof set with the Hot
                      Vault service. This process may take several minutes.
                    </p>
                    <p className="text-sm text-blue-700 mt-1">
                      <span className="font-medium">Cost:</span>{" "}
                      {Constants.PROOF_SET_FEE} USDFC from your FWS funds
                      <span className="ml-2 font-medium">
                        Available in FWS:
                      </span>{" "}
                      {paymentStatus.accountFunds} USDFC
                    </p>
                    {parseFloat(paymentStatus.accountFunds) <
                      parseFloat(Constants.PROOF_SET_FEE) && (
                      <p className="text-sm text-amber-600 mt-2 font-medium">
                        ‚ö†Ô∏è You need at least {Constants.PROOF_SET_FEE} USDFC in
                        your FWS funds to proceed.
                      </p>
                    )}
                  </div>
                </div>

                <button
                  onClick={handleCreateProofSet}
                  disabled={
                    isProcessingCreation ||
                    isProofSetClicked ||
                    parseFloat(paymentStatus.accountFunds) <
                      parseFloat(Constants.PROOF_SET_FEE)
                  }
                  className="w-full px-4 py-2.5 bg-blue-600 text-white rounded-lg text-sm font-medium hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed flex items-center justify-center gap-2"
                >
                  Get Hot Vault Space
                </button>
              </div>
            )}

            {(isProcessingCreation || isProofSetClicked) && (
              <div className="mt-4 bg-blue-50 rounded-lg p-4">
                <div className="flex items-center gap-3">
                  <div className="animate-spin">
                    <Loader className="w-5 h-5 text-blue-600" />
                  </div>
                  <div>
                    <p className="text-sm font-medium text-blue-900">
                      Setting Up Hot Vault Space
                    </p>
                    <p className="text-sm text-blue-700 mt-1">
                      Please wait while we set up your Hot Vault space. This
                      typically takes a few minutes.
                    </p>
                  </div>
                </div>
              </div>
            )}

            {isTrulyCompleted && (
              <div className="mt-4 bg-white rounded-lg p-4 border border-green-100">
                <div className="flex items-start gap-3">
                  <CheckCircle className="w-5 h-5 text-green-600 mt-0.5" />
                  <div className="flex-1">
                    <p className="text-base font-medium text-green-900">
                      Hot Vault Space Created Successfully!
                    </p>
                    <p className="text-sm text-green-700 mt-1">
                      Your Hot Vault space is ready. You can now proceed to
                      upload files.
                    </p>
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    );
  };

  const renderCompletionStep = () => {
    const isCompleted =
      paymentStatus.proofSetReady && currentStep === PaymentStep.COMPLETE;

    return (
      <div
        className={`w-full p-6 rounded-2xl transition-all ${
          isCompleted ? "bg-green-50" : "bg-gray-50"
        }`}
      >
        <div className="flex items-start gap-4">
          <StepIcon completed={isCompleted} active={false} number={5} />
          <div className="flex-1">
            <div className="flex items-center justify-between">
              <div>
                <h3
                  className={`font-semibold text-lg ${
                    isCompleted ? "text-green-700" : "text-gray-600"
                  }`}
                >
                  Setup Complete
                </h3>
                <p className="text-sm text-gray-500 mt-1">
                  {isCompleted ? "All steps completed" : "Pending completion"}
                </p>
              </div>
            </div>

            {isCompleted && (
              <div className="mt-4 bg-white rounded-lg p-4 border border-green-100">
                <div className="flex items-start gap-3">
                  <CheckCircle className="w-5 h-5 text-green-600 mt-0.5" />
                  <div className="w-full">
                    <p className="text-base font-medium text-green-900">
                      Payment setup complete!
                    </p>
                    <p className="text-sm text-green-700 mt-1">
                      Your payment setup is complete. You can now use all
                      features of the Hot Vault service. Please go to the files
                      tab to upload your files.
                    </p>
                    <div className="mt-4 flex flex-col sm:flex-row gap-2">
                      <button
                        onClick={() =>
                          setActiveTab && setActiveTab(DASHBOARD_SECTIONS.FILES)
                        }
                        className="inline-flex items-center justify-center rounded-md text-sm font-medium h-10 px-4 py-2 gap-2 bg-blue-600 text-white hover:bg-blue-700"
                      >
                        <Files className="w-4 h-4" />
                        Go to Files Tab
                      </button>
                      <button
                        onClick={() =>
                          window.open(
                            `http://explore-pdp.xyz:5173/proofsets/${userProofSetId}`,
                            "_blank"
                          )
                        }
                        className="inline-flex items-center justify-center rounded-md text-sm font-medium h-10 px-4 py-2 gap-2 text-blue-600 hover:text-blue-700"
                      >
                        <svg
                          xmlns="http://www.w3.org/2000/svg"
                          width="16"
                          height="16"
                          viewBox="0 0 24 24"
                          fill="none"
                          stroke="currentColor"
                          strokeWidth="2"
                          strokeLinecap="round"
                          strokeLinejoin="round"
                          className="mr-1"
                        >
                          <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                        </svg>
                        View Your Vault
                        <ExternalLink className="h-3 w-3" />
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    );
  };

  return (
    <div className="animate-fadeIn">
      <div className="px-6 py-4">
        <div className="flex flex-col sm:flex-row sm:items-center justify-between gap-4">
          <h1 className="text-xl font-semibold text-gray-900">Payment Setup</h1>
          <div className="flex gap-2">
            <button
              onClick={handleManualRefresh}
              disabled={isRefreshing}
              className="inline-flex items-center justify-center rounded-md text-sm font-medium h-10 px-4 py-2 gap-2 border border-gray-200 hover:bg-gray-50 text-gray-700"
            >
              {isRefreshing ? (
                <Loader className="w-4 h-4 animate-spin" />
              ) : (
                <RefreshCw className="w-4 h-4" />
              )}
              Refresh Balances
            </button>
            {paymentStatus.proofSetReady && userProofSetId && (
              <a
                href={`http://explore-pdp.xyz:5173/proofsets/${userProofSetId}`}
                target="_blank"
                rel="noopener noreferrer"
                className="inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 border bg-background hover:text-accent-foreground h-10 px-4 py-2 gap-2 text-blue-600 border-blue-200 hover:bg-blue-50"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  className="h-4 w-4"
                >
                  <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                </svg>
                View Your Vault
                <ExternalLink className="h-3 w-3" />
              </a>
            )}
          </div>
        </div>
      </div>

      <div className="px-6 grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div>
          <TokenBalanceCard />

          <div className="mt-6">
            <TransactionHistory />
          </div>
        </div>

        {/* Right Column - Setup Steps */}
        <div className="lg:col-span-2">
          <div className="bg-white rounded-2xl border border-gray-200 overflow-hidden">
            <div className="p-5 border-b border-gray-100">
              <h3 className="text-lg font-medium text-gray-900">
                Payment Setup Steps
              </h3>
              <p className="text-sm text-gray-600 mt-1">
                Complete these steps to enable Hot Vault service
              </p>
            </div>

            <div className="p-5 space-y-4">
              {renderTokenApprovalStep()}
              {renderDepositStep()}
              {renderOperatorApprovalStep()}
              {renderCreateProofSetStep()}
              {renderCompletionStep()}

              {!paymentStatus.hasMinimumBalance &&
                !paymentStatus.proofSetReady &&
                (currentStep === PaymentStep.APPROVE_TOKEN ||
                  currentStep === PaymentStep.DEPOSIT) && (
                  <div className="mt-4 p-4 bg-amber-50 rounded-lg border border-amber-100 flex items-start gap-3">
                    <AlertTriangle className="w-5 h-5 text-amber-500 flex-shrink-0" />
                    <div>
                      <p className="font-medium text-amber-800">
                        Insufficient Balance
                      </p>
                      <p className="text-sm text-amber-700 mt-1">
                        You need at least {Constants.MINIMUM_USDFC_BALANCE}{" "}
                        USDFC in your wallet to complete the setup.
                        {paymentStatus.isDeposited
                          ? " Please deposit more funds before proceeding."
                          : " Please complete the token approval step and deposit funds."}
                      </p>
                    </div>
                  </div>
                )}

              {parseFloat(paymentStatus.accountFunds) <
                parseFloat(Constants.PROOF_SET_FEE) &&
                !paymentStatus.proofSetReady &&
                currentStep === PaymentStep.CREATE_PROOF_SET && (
                  <div className="mt-4 p-4 bg-amber-50 rounded-lg border border-amber-100 flex items-start gap-3">
                    <AlertTriangle className="w-5 h-5 text-amber-500 flex-shrink-0" />
                    <div>
                      <p className="font-medium text-amber-800">
                        Insufficient FWS Funds
                      </p>
                      <p className="text-sm text-amber-700 mt-1">
                        You need at least {Constants.PROOF_SET_FEE} USDFC in
                        your FWS funds to create a proof set. Please deposit
                        more funds before proceeding.
                      </p>
                    </div>
                  </div>
                )}

              {paymentStatus.error && (
                <div className="mt-4 p-4 bg-red-50 rounded-lg border border-red-100 flex items-start gap-3">
                  <AlertTriangle className="w-5 h-5 text-red-500 flex-shrink-0" />
                  <div>
                    <p className="font-medium text-red-800">Error</p>
                    <p className="text-sm text-red-700 mt-1">
                      {paymentStatus.error}
                    </p>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="examples/hotvault-demo/client/src/app/dashboard/_components/ProofDetailsDialog.tsx">
"use client";

import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import { toast } from "sonner";
import { ProofDetails } from "./types";

interface ProofDetailsDialogProps {
  isOpen: boolean;
  onClose: () => void;
  selectedProof: ProofDetails | null;
}

export const ProofDetailsDialog: React.FC<ProofDetailsDialogProps> = ({
  isOpen,
  onClose,
  selectedProof,
}) => {
  if (!selectedProof) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-lg">
        <DialogHeader>
          <DialogTitle className="text-xl">Proof Details</DialogTitle>
        </DialogHeader>
        <div className="mt-4 space-y-6">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div className="col-span-1 md:col-span-2">
              <h3 className="text-sm font-medium text-gray-500 mb-1">
                File Name
              </h3>
              <p className="bg-gray-50 rounded p-3 text-sm break-all">
                {selectedProof.pieceFilename}
              </p>
            </div>

            <div className="col-span-1">
              <h3 className="text-sm font-medium text-gray-500 mb-1">
                Proof Set ID
              </h3>
              <div className="flex items-center gap-1 bg-gray-50 rounded p-3 text-sm font-mono break-all">
                {selectedProof.serviceProofSetId}
                <button
                  onClick={() => {
                    navigator.clipboard.writeText(
                      selectedProof.serviceProofSetId
                    );
                    toast.success("Proof Set ID copied to clipboard");
                  }}
                  className="ml-1 text-blue-500 hover:text-blue-700 flex-shrink-0"
                  title="Copy Proof Set ID"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="14"
                    height="14"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                  >
                    <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                    <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                  </svg>
                </button>
              </div>
            </div>

            {selectedProof.rootId && (
              <div className="col-span-1">
                <h3 className="text-sm font-medium text-gray-500 mb-1">
                  Root ID
                </h3>
                <div className="flex items-center gap-1 bg-gray-50 rounded p-3 text-sm font-mono break-all">
                  {selectedProof.rootId}
                  <button
                    onClick={() => {
                      navigator.clipboard.writeText(selectedProof.rootId || "");
                      toast.success("Root ID copied to clipboard");
                    }}
                    className="ml-1 text-blue-500 hover:text-blue-700 flex-shrink-0"
                    title="Copy Root ID"
                  >
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="14"
                      height="14"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                    >
                      <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                      <rect
                        x="8"
                        y="2"
                        width="8"
                        height="4"
                        rx="1"
                        ry="1"
                      ></rect>
                    </svg>
                  </button>
                </div>
                <p className="text-xs text-gray-500 mt-2">
                  The root is a cryptographic commitment that represents this
                  file in the PDP system.
                </p>
              </div>
            )}

            <div className="col-span-1 md:col-span-2">
              <h3 className="text-sm font-medium text-gray-500 mb-1">
                Content ID (CID)
              </h3>
              <div className="flex items-center gap-1 bg-gray-50 rounded p-3 text-sm font-mono break-all">
                {selectedProof.cid}
                <button
                  onClick={() => {
                    navigator.clipboard.writeText(selectedProof.cid);
                    toast.success("CID copied to clipboard");
                  }}
                  className="ml-1 text-blue-500 hover:text-blue-700 flex-shrink-0"
                  title="Copy CID"
                >
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="14"
                    height="14"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                  >
                    <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                    <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                  </svg>
                </button>
              </div>
            </div>
          </div>

          <div className="mt-6 bg-gradient-to-r from-green-50 to-blue-50 p-5 rounded-lg border border-gray-200">
            <h3 className="text-sm font-semibold mb-3 flex items-center gap-2">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="h-4 w-4 text-green-600"
              >
                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                <polyline points="22 4 12 14.01 9 11.01"></polyline>
              </svg>
              View Proof in PDP Explorer
            </h3>
            <p className="text-sm text-gray-600 mb-3">
              The PDP Explorer provides detailed verification information about
              your data&apos;s proof of storage.
            </p>
            <div className="flex flex-col gap-2">
              <Button
                className="gap-2 justify-start bg-gradient-to-r from-green-500 to-blue-500 hover:from-green-600 hover:to-blue-600 text-white"
                onClick={() =>
                  window.open(
                    ` http://explore-pdp.xyz:5173/proofsets/${selectedProof?.serviceProofSetId}`,
                    "_blank"
                  )
                }
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  className="h-4 w-4"
                >
                  <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                </svg>
                View Proof Set #{selectedProof?.serviceProofSetId}
              </Button>
            </div>
          </div>
        </div>

        <DialogFooter>
          <Button onClick={onClose} variant="outline">
            Close
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};
</file>

<file path="examples/hotvault-demo/client/src/app/dashboard/_components/RemoveConfirmationDialog.tsx">
"use client";

import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { AlertTriangle } from "lucide-react";
import { Piece } from "./types";

interface RemoveConfirmationDialogProps {
  isOpen: boolean;
  onClose: () => void;
  pieceToRemove: Piece | null;
  onConfirm: () => Promise<void>;
  isRemovalLoading?: boolean;
}

export const RemoveConfirmationDialog: React.FC<
  RemoveConfirmationDialogProps
> = ({
  isOpen,
  onClose,
  pieceToRemove,
  onConfirm,
  isRemovalLoading = false,
}) => {
  if (!pieceToRemove) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-lg">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2 text-red-600">
            <AlertTriangle className="h-5 w-5" />
            Confirm File Removal
          </DialogTitle>
          <DialogDescription className="pt-2">
            Are you sure you want to remove{" "}
            <span className="font-medium">{pieceToRemove.filename}</span>?
          </DialogDescription>
        </DialogHeader>

        <div className="bg-amber-50 border border-amber-200 p-4 rounded-md my-4">
          <h3 className="text-amber-800 font-medium text-sm mb-2 flex items-center gap-2">
            <AlertTriangle className="h-4 w-4" />
            Important Information
          </h3>
          <p className="text-amber-700 text-sm">
            This action will mark the file for removal from the storage network.
            Once initiated, the removal process typically takes 2-3 days to
            complete.
          </p>
        </div>

        <DialogFooter className="gap-2 sm:justify-end">
          <Button
            variant="outline"
            onClick={onClose}
            disabled={isRemovalLoading}
          >
            Cancel
          </Button>
          <Button
            variant="destructive"
            onClick={onConfirm}
            disabled={isRemovalLoading}
            className="bg-red-600 hover:bg-red-700"
          >
            {isRemovalLoading ? (
              <>
                <svg
                  className="animate-spin -ml-1 mr-2 h-4 w-4 text-white"
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 24 24"
                >
                  <circle
                    className="opacity-25"
                    cx="12"
                    cy="12"
                    r="10"
                    stroke="currentColor"
                    strokeWidth="4"
                  ></circle>
                  <path
                    className="opacity-75"
                    fill="currentColor"
                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                  ></path>
                </svg>
                Processing...
              </>
            ) : (
              "Remove File"
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};
</file>

<file path="examples/hotvault-demo/client/src/app/dashboard/_components/TokenBalanceCard.tsx">
"use client";

import { usePayment } from "@/contexts/PaymentContext";
import { Wallet, Plus, Shield, Loader, X, ArrowDownLeft } from "lucide-react";
import { formatCurrency, formatCurrencyPrecise } from "@/lib/utils";
import { useState, useEffect } from "react";
import { toast } from "sonner";
import * as Constants from "@/lib/constants";
import { UPLOAD_COMPLETED_EVENT } from "@/components/ui/global-upload-progress";
import { ROOT_REMOVED_EVENT } from "./PaymentBalanceHeader";
import { BALANCE_UPDATED_EVENT } from "@/contexts/PaymentContext";

export const TokenBalanceCard = () => {
  const {
    paymentStatus,
    depositFunds,
    approveToken,
    withdrawFunds,
    refreshPaymentSetupStatus,
  } = usePayment();
  const [showAddFunds, setShowAddFunds] = useState(false);
  const [showSetAllowance, setShowSetAllowance] = useState(false);
  const [showWithdraw, setShowWithdraw] = useState(false);
  const [depositAmount, setDepositAmount] = useState("");
  const [allowanceAmount, setAllowanceAmount] = useState("");
  const [withdrawAmount, setWithdrawAmount] = useState("");
  const [isProcessing, setIsProcessing] = useState(false);

  useEffect(() => {
    const handleUploadComplete = () => {
      console.log(
        "[TokenBalanceCard] File upload completed, refreshing balance"
      );
      refreshPaymentSetupStatus();
    };

    const handleRootRemoved = () => {
      console.log("[TokenBalanceCard] Root removed, refreshing balance");
      refreshPaymentSetupStatus();
    };

    const handleBalanceUpdate = (event: CustomEvent) => {
      console.log("[TokenBalanceCard] Balance updated:", event.detail);
      // The balance is already updated in the context
    };

    window.addEventListener(UPLOAD_COMPLETED_EVENT, handleUploadComplete);
    window.addEventListener(ROOT_REMOVED_EVENT, handleRootRemoved);
    window.addEventListener(
      BALANCE_UPDATED_EVENT,
      handleBalanceUpdate as EventListener
    );

    return () => {
      window.removeEventListener(UPLOAD_COMPLETED_EVENT, handleUploadComplete);
      window.removeEventListener(ROOT_REMOVED_EVENT, handleRootRemoved);
      window.removeEventListener(
        BALANCE_UPDATED_EVENT,
        handleBalanceUpdate as EventListener
      );
    };
  }, [refreshPaymentSetupStatus]);

  const handleAddFunds = async () => {
    if (!depositAmount || parseFloat(depositAmount) <= 0) {
      toast.error("Please enter a valid amount");
      return;
    }

    setIsProcessing(true);
    try {
      const result = await depositFunds(depositAmount);
      if (result) {
        toast.success(`Successfully deposited ${depositAmount} USDFC`);
        setDepositAmount("");
        setShowAddFunds(false);
      } else {
        toast.error("Failed to deposit USDFC");
      }
    } catch (error) {
      console.error("Error depositing USDFC:", error);
      toast.error("Error depositing USDFC. Please try again.");
    } finally {
      setIsProcessing(false);
    }
  };

  const handleSetAllowance = async () => {
    if (
      !allowanceAmount ||
      parseFloat(allowanceAmount) < parseFloat(Constants.PROOF_SET_FEE)
    ) {
      toast.error(
        `Allowance must be at least ${Constants.PROOF_SET_FEE} USDFC`
      );
      return;
    }

    setIsProcessing(true);
    try {
      const result = await approveToken(allowanceAmount);
      if (result) {
        toast.success(`Successfully set allowance to ${allowanceAmount} USDFC`);
        setAllowanceAmount("");
        setShowSetAllowance(false);
      } else {
        toast.error("Failed to set allowance");
      }
    } catch (error) {
      console.error("Error setting allowance:", error);
      toast.error("Error setting allowance. Please try again.");
    } finally {
      setIsProcessing(false);
    }
  };

  const handleWithdraw = async () => {
    if (!withdrawAmount || parseFloat(withdrawAmount) <= 0) {
      toast.error("Please enter a valid amount");
      return;
    }

    const withdrawAmountNum = parseFloat(withdrawAmount);
    const lockedAmount = parseFloat(paymentStatus.lockedFunds.current);
    const totalFunds = parseFloat(paymentStatus.accountFunds);

    const availableFunds = Math.max(
      0,
      parseFloat((totalFunds - lockedAmount).toFixed(6))
    );

    console.log("Withdrawal validation:", {
      withdrawAmount: withdrawAmountNum,
      accountFunds: paymentStatus.accountFunds,
      lockedFunds: paymentStatus.lockedFunds,
      availableFunds,
      precision: {
        totalFunds,
        lockedAmount,
        difference: totalFunds - lockedAmount,
      },
    });

    if (withdrawAmountNum > availableFunds + 0.001) {
      const errorMsg = `Cannot withdraw more than available unlocked funds (${formatCurrency(
        availableFunds.toString()
      )} USDFC)`;
      console.error("Withdrawal validation failed:", errorMsg);
      toast.error(errorMsg);
      return;
    }

    if (Math.abs(withdrawAmountNum - totalFunds) < 0.01) {
      setWithdrawAmount(availableFunds.toString());
    }

    setIsProcessing(true);
    try {
      const result = await withdrawFunds(withdrawAmount);
      if (result) {
        toast.success(`Successfully withdrew ${withdrawAmount} USDFC`);
        setWithdrawAmount("");
        setShowWithdraw(false);
      } else {
        if (paymentStatus.error) {
          console.error("Withdrawal failed with error:", paymentStatus.error);
          toast.error(paymentStatus.error);
        } else {
          console.error("Withdrawal failed without specific error");
          toast.error("Failed to withdraw USDFC");
        }
      }
    } catch (error) {
      console.error("Error withdrawing USDFC:", error);
      toast.error("Error withdrawing USDFC. Please try again.");
    } finally {
      setIsProcessing(false);
    }
  };

  const setMaxWithdrawal = () => {
    const availableFunds = Math.max(
      0,
      parseFloat(
        (
          parseFloat(paymentStatus.accountFunds) -
          parseFloat(paymentStatus.lockedFunds.current) -
          0.0001
        ).toFixed(6)
      )
    );
    setWithdrawAmount(availableFunds.toString());
  };

  return (
    <div className="bg-white rounded-lg border border-gray-200">
      <div className="p-6">
        <div className="flex items-center gap-3 mb-6">
          <div className="bg-blue-50 p-2.5 rounded-xl">
            <Wallet className="w-6 h-6 text-blue-500" />
          </div>
          <h3 className="text-2xl font-semibold">USDFC Balance</h3>
        </div>

        <div className="space-y-4">
          {/* Wallet Balance Section */}
          <div className="p-6 bg-blue-50 rounded-xl">
            <div className="flex items-center gap-2 mb-2">
              <Wallet className="w-5 h-5 text-blue-500" />
              <div className="text-[15px] font-medium text-blue-700">
                Wallet Balance
              </div>
            </div>
            <div className="text-2xl font-semibold text-blue-900 font-mono">
              {parseFloat(paymentStatus.usdcBalance).toFixed(5)} USDFC
            </div>
            <div className="text-[15px] text-blue-600 mt-1">
              Available in your connected wallet
            </div>
          </div>

          {/* Total FWS Funds */}
          <div className="p-6 bg-gray-50 rounded-xl">
            <div className="text-[15px] text-gray-600 mb-1">
              Total FWS Funds
            </div>
            <div className="text-2xl font-semibold font-mono">
              {parseFloat(paymentStatus.accountFunds).toFixed(5)} USDFC
            </div>
          </div>

          {/* Locked Funds */}
          <div className="p-6 bg-gray-50 rounded-xl">
            <div className="text-[15px] text-gray-600 mb-1">Locked Funds</div>
            <div className="text-2xl font-semibold font-mono">
              {parseFloat(paymentStatus.lockedFunds.current).toFixed(5)} USDFC
            </div>
          </div>

          {/* Available for Withdrawal */}
          <div className="p-6 bg-gray-50 rounded-xl">
            <div className="text-[15px] text-gray-600 mb-1">
              Available for Withdrawal
            </div>
            <div className="text-2xl font-semibold text-green-700 font-mono">
              {Math.max(
                0,
                parseFloat(paymentStatus.accountFunds) -
                  parseFloat(paymentStatus.lockedFunds.current)
              ).toFixed(5)}{" "}
              USDFC
            </div>
          </div>

          <div className="h-px bg-gray-100 my-2" />

          {/* Action Buttons */}
          <div className="space-y-3">
            <button
              onClick={() => {
                setShowWithdraw(true);
                setShowSetAllowance(false);
                setShowAddFunds(false);
              }}
              className="w-full flex items-center gap-2.5 px-6 py-3 text-[15px] font-medium text-red-600 hover:text-red-700 bg-red-50 hover:bg-red-100 rounded-xl transition-colors"
            >
              <ArrowDownLeft className="w-5 h-5" strokeWidth={2} />
              Withdraw
            </button>
            <button
              onClick={() => {
                setShowSetAllowance(true);
                setShowAddFunds(false);
                setShowWithdraw(false);
              }}
              className="w-full flex items-center gap-2.5 px-6 py-3 text-[15px] font-medium text-purple-600 hover:text-purple-700 bg-purple-50 hover:bg-purple-100 rounded-xl transition-colors"
            >
              <Shield className="w-5 h-5" strokeWidth={2} />
              Set Allowance
            </button>
            <button
              onClick={() => {
                setShowAddFunds(true);
                setShowSetAllowance(false);
                setShowWithdraw(false);
              }}
              className="w-full flex items-center gap-2.5 px-6 py-3 text-[15px] font-medium text-blue-600 hover:text-blue-700 bg-blue-50 hover:bg-blue-100 rounded-xl transition-colors"
            >
              <Plus className="w-5 h-5" strokeWidth={2} />
              Add Funds
            </button>
          </div>

          {/* Action Forms */}
          {showAddFunds && (
            <div className="mt-4 p-4 bg-blue-50 rounded-xl border border-blue-100 animate-fadeIn">
              <div className="flex items-center justify-between mb-3">
                <h4 className="text-sm font-medium text-blue-900">Add Funds</h4>
                <button
                  onClick={() => setShowAddFunds(false)}
                  className="text-blue-500 hover:text-blue-600 p-1 rounded-full hover:bg-blue-100/50"
                >
                  <X className="w-4 h-4" />
                </button>
              </div>
              <div className="space-y-3">
                <input
                  type="number"
                  value={depositAmount}
                  onChange={(e) => setDepositAmount(e.target.value)}
                  className="w-full rounded-lg border border-blue-200 px-3 py-2 text-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500 bg-white"
                  placeholder="Amount to deposit"
                  min="0.01"
                  step="0.01"
                  disabled={isProcessing}
                />
                <button
                  onClick={handleAddFunds}
                  disabled={isProcessing || !depositAmount}
                  className="w-full px-3 py-2 bg-blue-600 text-white rounded-lg text-sm font-medium hover:bg-blue-700 disabled:bg-blue-300 disabled:cursor-not-allowed flex items-center justify-center gap-2"
                >
                  {isProcessing ? (
                    <>
                      <Loader className="w-4 h-4 animate-spin" />
                      Processing...
                    </>
                  ) : (
                    "Deposit"
                  )}
                </button>
              </div>
            </div>
          )}

          {showSetAllowance && (
            <div className="mt-4 p-4 bg-purple-50 rounded-xl border border-purple-100 animate-fadeIn">
              <div className="flex items-center justify-between mb-3">
                <h4 className="text-sm font-medium text-purple-900">
                  Set Allowance
                </h4>
                <button
                  onClick={() => setShowSetAllowance(false)}
                  className="text-purple-500 hover:text-purple-600 p-1 rounded-full hover:bg-purple-100/50"
                >
                  <X className="w-4 h-4" />
                </button>
              </div>
              <div className="space-y-3">
                <div>
                  <input
                    type="number"
                    value={allowanceAmount}
                    onChange={(e) => setAllowanceAmount(e.target.value)}
                    className="w-full rounded-lg border border-purple-200 px-3 py-2 text-sm focus:border-purple-500 focus:ring-1 focus:ring-purple-500 bg-white"
                    placeholder="Allowance amount"
                    min={Constants.PROOF_SET_FEE}
                    step="0.01"
                    disabled={isProcessing}
                  />
                  <p className="mt-1.5 text-xs text-purple-600">
                    Minimum: {Constants.PROOF_SET_FEE} USDFC
                  </p>
                </div>
                <button
                  onClick={handleSetAllowance}
                  disabled={isProcessing || !allowanceAmount}
                  className="w-full px-3 py-2 bg-purple-600 text-white rounded-lg text-sm font-medium hover:bg-purple-700 disabled:bg-purple-300 disabled:cursor-not-allowed flex items-center justify-center gap-2"
                >
                  {isProcessing ? (
                    <>
                      <Loader className="w-4 h-4 animate-spin" />
                      Processing...
                    </>
                  ) : (
                    "Approve"
                  )}
                </button>
              </div>
            </div>
          )}

          {showWithdraw && (
            <div className="mt-4 p-4 bg-red-50 rounded-xl border border-red-100 animate-fadeIn">
              <div className="flex items-center justify-between mb-3">
                <h4 className="text-sm font-medium text-red-900">
                  Withdraw Funds
                </h4>
                <button
                  onClick={() => setShowWithdraw(false)}
                  className="text-red-500 hover:text-red-600 p-1 rounded-full hover:bg-red-100/50"
                >
                  <X className="w-4 h-4" />
                </button>
              </div>
              <div className="space-y-3">
                <div>
                  <div className="flex relative">
                    <input
                      type="number"
                      value={withdrawAmount}
                      onChange={(e) => setWithdrawAmount(e.target.value)}
                      className="w-full rounded-lg border border-red-200 px-3 py-2 text-sm focus:border-red-500 focus:ring-1 focus:ring-red-500 bg-white pr-16"
                      placeholder="Amount to withdraw"
                      min="0.01"
                      step="0.01"
                      disabled={isProcessing}
                    />
                    <button
                      type="button"
                      onClick={setMaxWithdrawal}
                      className="absolute right-2 top-1/2 transform -translate-y-1/2 px-2 py-1 bg-red-100 text-red-700 text-xs font-medium rounded hover:bg-red-200"
                    >
                      Max
                    </button>
                  </div>
                  <p className="mt-1.5 text-xs text-red-600">
                    Available:{" "}
                    {formatCurrencyPrecise(
                      Math.max(
                        0,
                        parseFloat(
                          (
                            parseFloat(paymentStatus.accountFunds) -
                            parseFloat(paymentStatus.lockedFunds.current) -
                            0.0001
                          ).toFixed(6)
                        )
                      ).toString()
                    )}{" "}
                    USDFC
                  </p>
                </div>
                <button
                  onClick={handleWithdraw}
                  disabled={isProcessing || !withdrawAmount}
                  className="w-full px-3 py-2 bg-red-600 text-white rounded-lg text-sm font-medium hover:bg-red-700 disabled:bg-red-300 disabled:cursor-not-allowed flex items-center justify-center gap-2"
                >
                  {isProcessing ? (
                    <>
                      <Loader className="w-4 h-4 animate-spin" />
                      Processing...
                    </>
                  ) : (
                    "Withdraw"
                  )}
                </button>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};
</file>

<file path="examples/hotvault-demo/client/src/app/dashboard/_components/TransactionHistory.tsx">
import { useEffect, useState } from "react";
import { usePayment, TransactionRecord } from "@/contexts/PaymentContext";
import {
  ExternalLink,
  Check,
  AlertCircle,
  Loader,
  RotateCcw,
  Upload,
  Download,
  Shield,
  CheckCircle,
} from "lucide-react";
import { getExplorerUrl } from "@/lib/utils";

export const TransactionHistory = () => {
  const { transactions } = usePayment();
  const [isExpanded, setIsExpanded] = useState(false);
  const [visibleCount, setVisibleCount] = useState(5);

  useEffect(() => {
    setVisibleCount(5);
  }, [transactions.length]);

  const formatDate = (timestamp: number) => {
    return new Date(timestamp).toLocaleString();
  };

  const getTransactionTypeLabel = (type: TransactionRecord["type"]) => {
    switch (type) {
      case "token_approval":
        return "USDFC Token Approval";
      case "deposit":
        return "USDFC Deposit";
      case "operator_approval":
        return "PDP Service Approval";
      case "withdraw":
        return "USDFC Withdrawal";
      default:
        return "Unknown Transaction";
    }
  };

  const getStatusIcon = (status: TransactionRecord["status"]) => {
    switch (status) {
      case "pending":
        return <Loader size={16} className="text-yellow-500 animate-spin" />;
      case "success":
        return <Check size={16} className="text-green-500" />;
      case "failed":
        return <AlertCircle size={16} className="text-red-500" />;
    }
  };

  const getTransactionTypeIcon = (type: TransactionRecord["type"]) => {
    switch (type) {
      case "token_approval":
        return <CheckCircle size={16} className="text-blue-500" />;
      case "deposit":
        return <Upload size={16} className="text-green-500" />;
      case "operator_approval":
        return <Shield size={16} className="text-purple-500" />;
      case "withdraw":
        return <Download size={16} className="text-orange-500" />;
      default:
        return null;
    }
  };

  const handleLoadMore = () => {
    setVisibleCount((prev) => prev + 5);
  };

  if (transactions.length === 0) {
    return (
      <div className="mt-4 bg-white rounded-lg border border-gray-200 overflow-hidden shadow-sm">
        <div className="px-4 py-3 bg-gray-50 border-b border-gray-200 flex justify-between items-center">
          <h3 className="text-sm font-medium text-gray-700 flex items-center">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
              className="w-4 h-4 mr-2 text-gray-500"
            >
              <path d="M8 7h12" />
              <path d="M8 12h12" />
              <path d="M8 17h12" />
              <path d="M3 7h1" />
              <path d="M3 12h1" />
              <path d="M3 17h1" />
            </svg>
            Transaction History
          </h3>
        </div>
        <div className="p-4 text-center">
          <p className="text-sm text-gray-500">No transactions yet</p>
          <p className="text-xs text-gray-400 mt-1">
            Transactions will appear here when you approve tokens, deposit
            funds, set allowances, or withdraw USDFC
          </p>
        </div>
      </div>
    );
  }

  const visibleTransactions = isExpanded
    ? transactions.slice(0, visibleCount)
    : transactions.slice(0, 5);

  const hasMore = isExpanded && visibleCount < transactions.length;

  return (
    <div className="mt-4 bg-white rounded-lg border border-gray-200 overflow-hidden shadow-sm">
      <div
        className="px-4 py-3 bg-gray-50 border-b border-gray-200 flex justify-between items-center cursor-pointer hover:bg-gray-100 transition-colors"
        onClick={() => setIsExpanded(!isExpanded)}
      >
        <h3 className="text-sm font-medium text-gray-700 flex items-center">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
            className="w-4 h-4 mr-2 text-gray-500"
          >
            <path d="M8 7h12" />
            <path d="M8 12h12" />
            <path d="M8 17h12" />
            <path d="M3 7h1" />
            <path d="M3 12h1" />
            <path d="M3 17h1" />
          </svg>
          Transaction History ({transactions.length})
        </h3>
        <button className="text-blue-500 text-xs font-medium">
          {isExpanded ? "Collapse" : "Expand"}
        </button>
      </div>

      {isExpanded && (
        <div className="p-3">
          <div className="space-y-2">
            {visibleTransactions.map((tx) => (
              <div
                key={tx.id}
                className={`p-3 rounded border ${
                  tx.status === "success"
                    ? "bg-green-50 border-green-200"
                    : tx.status === "failed"
                    ? "bg-red-50 border-red-200"
                    : "bg-gray-50 border-gray-200"
                } text-sm`}
              >
                <div className="flex items-center justify-between mb-2">
                  <div className="flex items-center">
                    {getStatusIcon(tx.status)}
                    <div className="flex items-center ml-2">
                      <span className="mr-1">
                        {getTransactionTypeIcon(tx.type)}
                      </span>
                      <span className="font-medium">
                        {getTransactionTypeLabel(tx.type)}
                      </span>
                    </div>
                  </div>
                  <span className="text-xs text-gray-500">
                    {formatDate(tx.timestamp)}
                  </span>
                </div>

                {tx.amount && (
                  <div className="text-xs text-gray-600 mb-1 flex items-center">
                    <span
                      className={`inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium mr-2 ${
                        tx.type === "deposit"
                          ? "bg-green-100 text-green-800"
                          : tx.type === "withdraw"
                          ? "bg-orange-100 text-orange-800"
                          : tx.type === "token_approval"
                          ? "bg-blue-100 text-blue-800"
                          : "bg-purple-100 text-purple-800"
                      }`}
                    >
                      {tx.type === "deposit"
                        ? "Deposit"
                        : tx.type === "withdraw"
                        ? "Withdraw"
                        : tx.type === "token_approval"
                        ? "Approve"
                        : "Operator"}
                    </span>
                    {tx.type === "operator_approval" ? (
                      <span title={tx.amount}>
                        Service allowances: {tx.amount.split(",")[0].trim()}
                      </span>
                    ) : tx.type === "withdraw" ? (
                      <span>Withdrawn: {tx.amount} USDFC</span>
                    ) : (
                      <span>
                        Amount: {tx.amount}{" "}
                        {tx.type === "deposit" || tx.type === "token_approval"
                          ? "USDFC"
                          : ""}
                      </span>
                    )}
                  </div>
                )}

                {tx.txHash ? (
                  <div className="flex items-center mt-1">
                    <span className="text-xs text-gray-600 font-mono truncate max-w-[200px]">
                      {tx.txHash.substring(0, 12)}...
                      {tx.txHash.substring(tx.txHash.length - 6)}
                    </span>
                    <a
                      href={getExplorerUrl(tx.txHash)}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="ml-2 text-blue-500 hover:text-blue-700"
                      onClick={(e) => e.stopPropagation()}
                    >
                      <ExternalLink size={14} />
                    </a>
                  </div>
                ) : (
                  tx.status === "pending" && (
                    <div className="text-xs text-gray-600 animate-pulse">
                      Waiting for transaction hash...
                    </div>
                  )
                )}

                {tx.status === "failed" && tx.error && (
                  <div className="mt-1 text-xs text-red-600">
                    Error: {tx.error}
                  </div>
                )}
              </div>
            ))}
          </div>

          {hasMore && (
            <div className="mt-2 text-center">
              <button
                className="text-xs text-blue-500 flex items-center justify-center mx-auto"
                onClick={handleLoadMore}
              >
                <RotateCcw size={12} className="mr-1" />
                Load more
              </button>
            </div>
          )}
        </div>
      )}
    </div>
  );
};
</file>

<file path="examples/hotvault-demo/client/src/app/dashboard/_components/types.ts">
export interface Piece {
  id: number;
  cid: string;
  filename: string;
  size: number;
  serviceName: string;
  serviceUrl: string;
  createdAt: string;
  updatedAt: string;
  pendingRemoval?: boolean;
  removalDate?: string;
  proofSetDbId?: number;
  serviceProofSetId?: string;
  rootId?: string;
}

export interface FilesTabProps {
  isLoading: boolean;
}

export interface DownloadError extends Error {
  options?: string[];
}

export interface ProofDetails {
  pieceId: number;
  pieceFilename: string;
  serviceProofSetId: string;
  cid: string;
  rootId?: string;
}

export interface UploadProgress {
  status: string;
  progress?: number;
  message?: string;
  cid?: string;
  error?: string;
  lastUpdated?: number;
  isStalled?: boolean;
  filename?: string;
  jobId?: string;
  serviceProofSetId?: string;
}
</file>

<file path="examples/hotvault-demo/client/src/app/dashboard/_components/UploadProgress.tsx">
import { AlertTriangle, ExternalLink } from "lucide-react";
import { statusColors, getStatusText } from "@/lib/constants";

interface UploadProgressProps {
  uploadProgress: {
    status: string;
    progress?: number;
    message?: string;
    isStalled?: boolean;
    error?: string;
    filename?: string;
    serviceProofSetId?: string;
    cid?: string;
  } | null;
  onCancel?: () => void;
  hasActiveAbortController?: boolean;
}

export const UploadProgress: React.FC<UploadProgressProps> = ({
  uploadProgress,
  onCancel,
  hasActiveAbortController,
}) => {
  if (!uploadProgress) return null;

  const statusColor =
    statusColors[uploadProgress.status as keyof typeof statusColors] ||
    statusColors.uploading;

  return (
    <div className="fixed bottom-4 right-4 z-50 w-80 shadow-lg rounded-lg overflow-hidden">
      <div className={`p-4 ${statusColor}`}>
        <div className="flex justify-between items-start">
          <div className="flex-1">
            <div className="flex items-center gap-2 font-medium">
              {uploadProgress.isStalled && (
                <AlertTriangle className="h-4 w-4 text-amber-500" />
              )}
              <span>{getStatusText(uploadProgress.status)}</span>
              {uploadProgress.status !== "complete" &&
                uploadProgress.status !== "error" &&
                uploadProgress.status !== "cancelled" &&
                hasActiveAbortController && (
                  <button
                    onClick={onCancel}
                    className="ml-2 px-2 py-1 text-xs bg-red-100 text-red-600 rounded hover:bg-red-200 transition-colors"
                  >
                    Cancel
                  </button>
                )}
            </div>
            {uploadProgress.message && (
              <div className="text-sm mt-1 opacity-80 line-clamp-2">
                {uploadProgress.message}
              </div>
            )}
            {uploadProgress.isStalled && (
              <div className="text-amber-600 text-sm mt-1">
                No updates received for a while.
              </div>
            )}
            {(uploadProgress.status === "uploading" ||
              uploadProgress.status === "processing") &&
              !uploadProgress.isStalled && (
                <div className="text-gray-500 text-xs mt-1 italic">
                  <a
                    href="https://www.youtube.com/watch?v=OsU0CGZoV8E"
                    target="_blank"
                    rel="noopener noreferrer"
                    className="flex items-center text-blue-500 hover:text-blue-700 transition-colors"
                  >
                    <span>
                      Watch this important video while we get your data on FWS
                    </span>
                    <ExternalLink className="h-3 w-3 ml-1" />
                  </a>
                </div>
              )}
            {uploadProgress.error && (
              <div className="text-red-500 text-sm mt-1 line-clamp-2">
                Error: {uploadProgress.error}
              </div>
            )}
            {uploadProgress.filename && (
              <div className="text-xs text-gray-500 mt-1 truncate">
                {uploadProgress.filename}
              </div>
            )}
            {uploadProgress.serviceProofSetId && (
              <div className="text-xs mt-2 flex items-center">
                <span className="mr-2">Proof Set ID:</span>
                <a
                  href={` http://explore-pdp.xyz:5173/proofsets/${uploadProgress.serviceProofSetId}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-blue-600 hover:text-blue-800 underline flex items-center"
                >
                  {uploadProgress.serviceProofSetId}
                  <ExternalLink className="h-3 w-3 ml-1" />
                </a>
              </div>
            )}
          </div>
          {uploadProgress.progress !== undefined && (
            <div className="text-sm font-medium ml-2">
              {uploadProgress.progress}%
            </div>
          )}
        </div>

        {uploadProgress.progress !== undefined && (
          <div className="w-full bg-gray-200 rounded-full h-2.5 mt-3">
            <div
              className={`h-2.5 rounded-full ${
                uploadProgress.status === "error"
                  ? "bg-red-500"
                  : uploadProgress.status === "complete"
                  ? "bg-green-500"
                  : uploadProgress.isStalled
                  ? "bg-amber-500"
                  : "bg-blue-500"
              }`}
              style={{ width: `${uploadProgress.progress}%` }}
            ></div>
          </div>
        )}

        {uploadProgress.status === "complete" && uploadProgress.cid && (
          <div className="mt-3 pt-3 border-t border-green-200">
            <div className="flex flex-col gap-2">
              {uploadProgress.serviceProofSetId && (
                <a
                  href={` http://explore-pdp.xyz:5173/proofsets/${uploadProgress.serviceProofSetId}`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-sm flex items-center justify-between bg-green-100 text-green-800 p-2 rounded hover:bg-green-200 transition-colors"
                >
                  <span className="flex items-center">
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      className="h-4 w-4 mr-2"
                    >
                      <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                    </svg>
                    View Proof Set
                  </span>
                  <ExternalLink className="h-3 w-3" />
                </a>
              )}
            </div>
          </div>
        )}
      </div>
    </div>
  );
};
</file>

<file path="examples/hotvault-demo/client/src/app/dashboard/page.tsx">
"use client";

import { useAuth } from "@/contexts/AuthContext";
import { AnimatePresence } from "framer-motion";
import { useState, useEffect } from "react";
import { DASHBOARD_SECTIONS, DashboardSection } from "@/types/dashboard";
import { DashboardHeader } from "./_components/DashboardHeader";
import { FilesTab } from "./_components/FilesTab";
import { PaymentSetupTab } from "./_components/PaymentSetupTab";
import { usePayment } from "@/contexts/PaymentContext";

export default function Dashboard() {
  const { account, handleAccountSwitch, disconnectWallet } = useAuth();
  const { refreshPaymentSetupStatus } = usePayment();
  const [activeTab, setActiveTab] = useState<DashboardSection>(
    DASHBOARD_SECTIONS.FILES
  );
  const [isAccountMenuOpen, setIsAccountMenuOpen] = useState(false);
  const [isLoading] = useState(false);

  const handleTabChange = (tab: string) => {
    if (tab === "payment") {
      setActiveTab(DASHBOARD_SECTIONS.PAYMENTS);
    } else if (tab === "files") {
      setActiveTab(DASHBOARD_SECTIONS.FILES);
    }
  };

  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.visibilityState === "visible" && account) {
        console.log(
          "[Dashboard] Tab became visible, refreshing payment status"
        );
        refreshPaymentSetupStatus()
          .then(() => {
            console.log(
              "[Dashboard] Payment status refreshed after visibility change"
            );
          })
          .catch((error) => {
            console.error(
              "[Dashboard] Error refreshing payment status on visibility change:",
              error
            );
          });
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);

    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, [account, refreshPaymentSetupStatus]);

  if (!account) {
    return null;
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <DashboardHeader
        account={account}
        activeTab={activeTab}
        setActiveTab={setActiveTab}
        isAccountMenuOpen={isAccountMenuOpen}
        setIsAccountMenuOpen={setIsAccountMenuOpen}
        handleAccountSwitch={handleAccountSwitch}
        disconnectWallet={disconnectWallet}
      />

      <div className="pt-16">
        <main className="container mx-auto px-4 py-8">
          <div className="bg-white rounded-xl shadow-sm overflow-hidden">
            <AnimatePresence mode="wait">
              {activeTab === DASHBOARD_SECTIONS.FILES && (
                <FilesTab isLoading={isLoading} onTabChange={handleTabChange} />
              )}
              {activeTab === DASHBOARD_SECTIONS.PAYMENTS && (
                <PaymentSetupTab setActiveTab={setActiveTab} />
              )}
            </AnimatePresence>
          </div>
        </main>
      </div>
    </div>
  );
}
</file>

<file path="examples/hotvault-demo/client/src/app/globals.css">
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --animate-accordion-down: accordion-down 0.2s ease-out;
  --animate-accordion-up: accordion-up 0.2s ease-out;

  @keyframes accordion-down {
    from {
      height: 0;
    }

    to {
      height: var(--radix-accordion-content-height);
    }
  }

  @keyframes accordion-up {
    from {
      height: var(--radix-accordion-content-height);
    }

    to {
      height: 0;
    }
  }
}

#__nextjs-overlay {
  display: none !important;
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }

  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="examples/hotvault-demo/client/src/app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import { DM_Sans } from "next/font/google";
import "./globals.css";
import ClientLayout from "@/components/layout/client-layout";
import { GlobalUploadProgress } from "@/components/ui/global-upload-progress";
import { Toaster } from "sonner";

const dmSans = DM_Sans({ subsets: ["latin"] });
const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Hot Vault",
  description:
    "Hot Vault is a decentralized infrastructure for the next generation of web applications",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body
        className={`${dmSans.className} ${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <ClientLayout>
          {children}
          <GlobalUploadProgress />
        </ClientLayout>
        <Toaster richColors />
      </body>
    </html>
  );
}
</file>

<file path="examples/hotvault-demo/client/src/app/page.tsx">
"use client";
import { useAuth } from "@/contexts/AuthContext";
import { Container } from "@/theme/components";
import { Button } from "@/components/ui/button";
import { Typography } from "@/components/ui/typography";
import Image from "next/image";
import {
  Shield,
  Lock,
  Upload,
  Clock,
  Key,
  FileCheck,
  DollarSign,
} from "lucide-react";

export default function Home() {
  const { isConnecting, error, connectWallet } = useAuth();

  return (
    <div className="min-h-screen bg-white flex flex-col">
      <header className="w-full border-b border-[#E5E5E5] fixed top-0 bg-white/95 backdrop-blur-sm z-50">
        <Container className="max-w-7xl mx-auto px-6">
          <div className="flex justify-between items-center h-20">
            <div className="flex items-center gap-2">
              <div className="w-8 h-8 relative">
                <Image
                  src="/logo.png"
                  alt="Hot Vault Logo"
                  fill
                  className="object-contain"
                  priority
                />
              </div>
              <Typography
                variant="h1"
                color="black"
                className="font-mono tracking-tight text-2xl relative group cursor-pointer"
              >
                Hot Vault
                <div className="absolute -bottom-1 left-0 w-0 h-0.5 bg-blue-500 group-hover:w-full transition-all duration-300" />
              </Typography>
            </div>
            <div className="flex items-center gap-6">
              {error && (
                <Typography
                  color="black"
                  variant="small"
                  className="text-red-600 animate-fade-in"
                >
                  {error}
                </Typography>
              )}
              <Button
                size="lg"
                onClick={connectWallet}
                disabled={isConnecting}
                className="bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 text-white shadow-lg hover:shadow-xl transition-all duration-300"
              >
                {isConnecting ? (
                  <span className="flex items-center gap-2">
                    <svg className="animate-spin h-4 w-4" viewBox="0 0 24 24">
                      <circle
                        className="opacity-25"
                        cx="12"
                        cy="12"
                        r="10"
                        stroke="currentColor"
                        strokeWidth="4"
                        fill="none"
                      />
                      <path
                        className="opacity-75"
                        fill="currentColor"
                        d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                      />
                    </svg>
                    Connecting...
                  </span>
                ) : (
                  "Launch App"
                )}
              </Button>
            </div>
          </div>
        </Container>
      </header>

      <main className="flex-grow flex flex-col">
        <section className="min-h-[100vh] flex items-center relative pt-20 pb-32 border-b border-[#E5E5E5] overflow-hidden">
          {/* Background Pattern */}
          <div className="absolute inset-0 bg-[radial-gradient(#3B82F6_1px,transparent_1px)] [background-size:32px_32px] opacity-[0.03]" />
          <div className="absolute inset-0 bg-gradient-to-br from-blue-50/50 via-transparent to-purple-50/50" />

          <Container className="relative max-w-7xl mx-auto px-6">
            <div className="grid md:grid-cols-12 gap-12 lg:gap-16 items-center">
              <div className="md:col-span-7 space-y-8 animate-fade-in-up">
                <div className="space-y-6">
                  <div className="inline-flex items-center gap-2 px-4 py-2 rounded-full bg-blue-50 border border-blue-100">
                    <Key className="w-4 h-4 text-blue-500" />
                    <span className="text-sm text-blue-700">
                      Proof of Data Possession (PDP)
                    </span>
                  </div>
                  <div className="space-y-2">
                    <Typography
                      variant="h2"
                      color="black"
                      className="text-5xl md:text-7xl font-mono tracking-tight leading-[1.1] bg-clip-text text-transparent bg-gradient-to-r from-gray-900 to-gray-600"
                    >
                      Verify Your Data on FWS
                    </Typography>
                  </div>
                  <Typography
                    variant="body"
                    color="black"
                    className="text-lg md:text-2xl leading-relaxed text-gray-600 max-w-3xl"
                  >
                    Store and verify your data with cryptographic proofs. All
                    with real-time on-chain Filecoin backed stablecoin payments.
                  </Typography>

                  <div className="flex items-center gap-4 pt-6">
                    <Button
                      size="lg"
                      onClick={connectWallet}
                      className="bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 text-white shadow-lg hover:shadow-xl transition-all duration-300"
                    >
                      Get Started
                    </Button>
                    <a
                      href=" http://explore-pdp.xyz:5173"
                      target="_blank"
                      rel="noopener noreferrer"
                      className="inline-flex items-center gap-2 text-blue-600 hover:text-blue-700 transition-colors"
                    >
                      <FileCheck className="w-5 h-5" />
                      <span className="font-medium">View Proof Explorer</span>
                    </a>
                  </div>
                </div>
              </div>

              <div className="hidden md:block md:col-span-5 relative animate-fade-in">
                <div className="absolute -inset-4 bg-gradient-to-tr from-blue-500/10 to-purple-500/10 rounded-2xl blur-3xl animate-pulse" />
                <div className="relative bg-white/[0.7] backdrop-blur-xl rounded-2xl p-8 border border-white/20 shadow-[0_0_1px_1px_rgba(0,0,0,0.02)] hover:shadow-lg transition-all duration-500">
                  <div className="space-y-6">
                    <div className="flex items-center justify-between p-4 bg-blue-50/50 backdrop-blur-sm rounded-xl border border-blue-100/50">
                      <div className="flex items-center gap-3">
                        <Lock className="w-5 h-5 text-blue-600" />
                        <span className="font-medium text-blue-900">
                          Smart Contract
                        </span>
                      </div>
                      <span className="text-sm text-blue-600 bg-blue-100/50 px-2.5 py-0.5 rounded-full">
                        Active
                      </span>
                    </div>

                    <div className="space-y-3">
                      {[
                        {
                          icon: Upload,
                          title: "File Upload",
                          description: "Generate unique proof set",
                        },
                        {
                          icon: Shield,
                          title: "Data Verification",
                          description: "Cryptographic integrity checks",
                        },
                        {
                          icon: Clock,
                          title: "Automated System",
                          description: "Continuous proof validation",
                        },
                        {
                          icon: DollarSign,
                          title: "Stablecoin Payments",
                          description: "Real-time on-chain payments",
                        },
                      ].map((feature, i) => (
                        <div
                          key={i}
                          className="p-4 bg-gray-50/50 backdrop-blur-sm rounded-xl border border-gray-100/50 hover:bg-gray-50/70 transition-colors duration-200"
                        >
                          <div className="flex items-center gap-3">
                            <div className="p-2 bg-blue-100/50 rounded-lg">
                              <feature.icon className="w-4 h-4 text-blue-600" />
                            </div>
                            <div>
                              <h4 className="text-sm font-medium text-gray-900">
                                {feature.title}
                              </h4>
                              <p className="text-xs text-gray-600">
                                {feature.description}
                              </p>
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>

                    <div className="p-4 bg-gradient-to-r from-blue-50/50 to-purple-50/50 backdrop-blur-sm rounded-xl border border-blue-100/50">
                      <div className="flex items-center justify-between text-sm">
                        <span className="font-medium text-gray-700">
                          Network
                        </span>
                        <span className="font-mono text-blue-600">
                          Filecoin Calibration
                        </span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </Container>
        </section>
      </main>
    </div>
  );
}
</file>

<file path="examples/hotvault-demo/client/src/components/layout/client-layout.tsx">
"use client";
import { AuthProvider } from "@/contexts/AuthContext";
import { useAuth } from "@/contexts/AuthContext";
import { PaymentProvider } from "@/contexts/PaymentContext";
import { useRouter, usePathname } from "next/navigation";
import { useEffect, useState } from "react";

function AuthWrapper({ children }: { children: React.ReactNode }) {
  const router = useRouter();
  const pathname = usePathname();
  const { account, isLoading } = useAuth();
  const [shouldRender, setShouldRender] = useState(false);
  const [mounted, setMounted] = useState(false);

  // Handle mounting state
  useEffect(() => {
    setMounted(true);
  }, []);

  useEffect(() => {
    if (!isLoading && mounted) {
      // Handle authentication redirects
      const handleAuth = async () => {
        try {
          if (account && pathname === "/") {
            await router.replace("/dashboard");
          } else if (
            !account &&
            (pathname.startsWith("/dashboard") || pathname === "/upload")
          ) {
            await router.replace("/");
          } else {
            // Only render if we're on the correct page for the auth state
            setShouldRender(
              (account &&
                (pathname.startsWith("/dashboard") ||
                  pathname === "/upload")) ||
                (!account && pathname === "/")
            );
          }
        } catch (error) {
          console.error("Navigation error:", error);
          // Fallback to setting shouldRender even if navigation fails
          setShouldRender(true);
        }
      };

      handleAuth();
    }
  }, [account, isLoading, pathname, router, mounted]);

  // Don't render anything until mounted to prevent hydration issues
  if (!mounted || isLoading || !shouldRender) {
    return (
      <div className="min-h-screen bg-white flex items-center justify-center">
        <div className="flex flex-col items-center gap-4">
          <div className="w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full animate-spin" />
          <p className="text-gray-600 font-light">Loading...</p>
        </div>
      </div>
    );
  }

  // Conditionally wrap authenticated routes with PaymentProvider
  const isAuthenticatedRoute =
    pathname === "/dashboard" || pathname === "/upload";

  if (isAuthenticatedRoute && account) {
    return <PaymentProvider>{children}</PaymentProvider>;
  }

  return children;
}

export default function ClientLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <AuthProvider>
      <AuthWrapper>{children}</AuthWrapper>
    </AuthProvider>
  );
}
</file>

<file path="examples/hotvault-demo/client/src/components/ui/accordion.tsx">
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Accordion({
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Root>) {
  return <AccordionPrimitive.Root data-slot="accordion" {...props} />
}

function AccordionItem({
  className,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Item>) {
  return (
    <AccordionPrimitive.Item
      data-slot="accordion-item"
      className={cn("border-b last:border-b-0", className)}
      {...props}
    />
  )
}

function AccordionTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Trigger>) {
  return (
    <AccordionPrimitive.Header className="flex">
      <AccordionPrimitive.Trigger
        data-slot="accordion-trigger"
        className={cn(
          "focus-visible:border-ring focus-visible:ring-ring/50 flex flex-1 items-start justify-between gap-4 rounded-md py-4 text-left text-sm font-medium transition-all outline-none hover:underline focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&[data-state=open]>svg]:rotate-180",
          className
        )}
        {...props}
      >
        {children}
        <ChevronDownIcon className="text-muted-foreground pointer-events-none size-4 shrink-0 translate-y-0.5 transition-transform duration-200" />
      </AccordionPrimitive.Trigger>
    </AccordionPrimitive.Header>
  )
}

function AccordionContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof AccordionPrimitive.Content>) {
  return (
    <AccordionPrimitive.Content
      data-slot="accordion-content"
      className="data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down overflow-hidden text-sm"
      {...props}
    >
      <div className={cn("pt-0 pb-4", className)}>{children}</div>
    </AccordionPrimitive.Content>
  )
}

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/alert-dialog.tsx">
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

function AlertDialog({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Root>) {
  return <AlertDialogPrimitive.Root data-slot="alert-dialog" {...props} />
}

function AlertDialogTrigger({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Trigger>) {
  return (
    <AlertDialogPrimitive.Trigger data-slot="alert-dialog-trigger" {...props} />
  )
}

function AlertDialogPortal({
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Portal>) {
  return (
    <AlertDialogPrimitive.Portal data-slot="alert-dialog-portal" {...props} />
  )
}

function AlertDialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Overlay>) {
  return (
    <AlertDialogPrimitive.Overlay
      data-slot="alert-dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogContent({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Content>) {
  return (
    <AlertDialogPortal>
      <AlertDialogOverlay />
      <AlertDialogPrimitive.Content
        data-slot="alert-dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      />
    </AlertDialogPortal>
  )
}

function AlertDialogHeader({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function AlertDialogFooter({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function AlertDialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Title>) {
  return (
    <AlertDialogPrimitive.Title
      data-slot="alert-dialog-title"
      className={cn("text-lg font-semibold", className)}
      {...props}
    />
  )
}

function AlertDialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Description>) {
  return (
    <AlertDialogPrimitive.Description
      data-slot="alert-dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function AlertDialogAction({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Action>) {
  return (
    <AlertDialogPrimitive.Action
      className={cn(buttonVariants(), className)}
      {...props}
    />
  )
}

function AlertDialogCancel({
  className,
  ...props
}: React.ComponentProps<typeof AlertDialogPrimitive.Cancel>) {
  return (
    <AlertDialogPrimitive.Cancel
      className={cn(buttonVariants({ variant: "outline" }), className)}
      {...props}
    />
  )
}

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
</file>

<file path="examples/hotvault-demo/client/src/components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-card text-card-foreground",
        destructive:
          "text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        className
      )}
      {...props}
    />
  )
}

function AlertDescription({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props}
    />
  )
}

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/aspect-ratio.tsx">
"use client"

import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

function AspectRatio({
  ...props
}: React.ComponentProps<typeof AspectRatioPrimitive.Root>) {
  return <AspectRatioPrimitive.Root data-slot="aspect-ratio" {...props} />
}

export { AspectRatio }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/badge.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90",
        destructive:
          "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps<"span"> &
  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "span"

  return (
    <Comp
      data-slot="badge"
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    />
  )
}

export { Badge, badgeVariants }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/breadcrumb.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

function Breadcrumb({ ...props }: React.ComponentProps<"nav">) {
  return <nav aria-label="breadcrumb" data-slot="breadcrumb" {...props} />
}

function BreadcrumbList({ className, ...props }: React.ComponentProps<"ol">) {
  return (
    <ol
      data-slot="breadcrumb-list"
      className={cn(
        "text-muted-foreground flex flex-wrap items-center gap-1.5 text-sm break-words sm:gap-2.5",
        className
      )}
      {...props}
    />
  )
}

function BreadcrumbItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-item"
      className={cn("inline-flex items-center gap-1.5", className)}
      {...props}
    />
  )
}

function BreadcrumbLink({
  asChild,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="breadcrumb-link"
      className={cn("hover:text-foreground transition-colors", className)}
      {...props}
    />
  )
}

function BreadcrumbPage({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-page"
      role="link"
      aria-disabled="true"
      aria-current="page"
      className={cn("text-foreground font-normal", className)}
      {...props}
    />
  )
}

function BreadcrumbSeparator({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="breadcrumb-separator"
      role="presentation"
      aria-hidden="true"
      className={cn("[&>svg]:size-3.5", className)}
      {...props}
    >
      {children ?? <ChevronRight />}
    </li>
  )
}

function BreadcrumbEllipsis({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="breadcrumb-ellipsis"
      role="presentation"
      aria-hidden="true"
      className={cn("flex size-9 items-center justify-center", className)}
      {...props}
    >
      <MoreHorizontal className="size-4" />
      <span className="sr-only">More</span>
    </span>
  )
}

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}
</file>

<file path="examples/hotvault-demo/client/src/components/ui/button.tsx">
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean;
  }) {
  const Comp = asChild ? Slot : "button";

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  );
}

export { Button, buttonVariants };
</file>

<file path="examples/hotvault-demo/client/src/components/ui/calendar.tsx">
"use client"

import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: React.ComponentProps<typeof DayPicker>) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row gap-2",
        month: "flex flex-col gap-4",
        caption: "flex justify-center pt-1 relative items-center w-full",
        caption_label: "text-sm font-medium",
        nav: "flex items-center gap-1",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "size-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-x-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-8 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: cn(
          "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([aria-selected])]:bg-accent [&:has([aria-selected].day-range-end)]:rounded-r-md",
          props.mode === "range"
            ? "[&:has(>.day-range-end)]:rounded-r-md [&:has(>.day-range-start)]:rounded-l-md first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md"
            : "[&:has([aria-selected])]:rounded-md"
        ),
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "size-8 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_start:
          "day-range-start aria-selected:bg-primary aria-selected:text-primary-foreground",
        day_range_end:
          "day-range-end aria-selected:bg-primary aria-selected:text-primary-foreground",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
          <ChevronLeft className={cn("size-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
          <ChevronRight className={cn("size-4", className)} {...props} />
        ),
      }}
      {...props}
    />
  )
}

export { Calendar }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}
</file>

<file path="examples/hotvault-demo/client/src/components/ui/carousel.tsx">
"use client"

import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

function Carousel({
  orientation = "horizontal",
  opts,
  setApi,
  plugins,
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & CarouselProps) {
  const [carouselRef, api] = useEmblaCarousel(
    {
      ...opts,
      axis: orientation === "horizontal" ? "x" : "y",
    },
    plugins
  )
  const [canScrollPrev, setCanScrollPrev] = React.useState(false)
  const [canScrollNext, setCanScrollNext] = React.useState(false)

  const onSelect = React.useCallback((api: CarouselApi) => {
    if (!api) return
    setCanScrollPrev(api.canScrollPrev())
    setCanScrollNext(api.canScrollNext())
  }, [])

  const scrollPrev = React.useCallback(() => {
    api?.scrollPrev()
  }, [api])

  const scrollNext = React.useCallback(() => {
    api?.scrollNext()
  }, [api])

  const handleKeyDown = React.useCallback(
    (event: React.KeyboardEvent<HTMLDivElement>) => {
      if (event.key === "ArrowLeft") {
        event.preventDefault()
        scrollPrev()
      } else if (event.key === "ArrowRight") {
        event.preventDefault()
        scrollNext()
      }
    },
    [scrollPrev, scrollNext]
  )

  React.useEffect(() => {
    if (!api || !setApi) return
    setApi(api)
  }, [api, setApi])

  React.useEffect(() => {
    if (!api) return
    onSelect(api)
    api.on("reInit", onSelect)
    api.on("select", onSelect)

    return () => {
      api?.off("select", onSelect)
    }
  }, [api, onSelect])

  return (
    <CarouselContext.Provider
      value={{
        carouselRef,
        api: api,
        opts,
        orientation:
          orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
        scrollPrev,
        scrollNext,
        canScrollPrev,
        canScrollNext,
      }}
    >
      <div
        onKeyDownCapture={handleKeyDown}
        className={cn("relative", className)}
        role="region"
        aria-roledescription="carousel"
        data-slot="carousel"
        {...props}
      >
        {children}
      </div>
    </CarouselContext.Provider>
  )
}

function CarouselContent({ className, ...props }: React.ComponentProps<"div">) {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div
      ref={carouselRef}
      className="overflow-hidden"
      data-slot="carousel-content"
    >
      <div
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
}

function CarouselItem({ className, ...props }: React.ComponentProps<"div">) {
  const { orientation } = useCarousel()

  return (
    <div
      role="group"
      aria-roledescription="slide"
      data-slot="carousel-item"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
}

function CarouselPrevious({
  className,
  variant = "outline",
  size = "icon",
  ...props
}: React.ComponentProps<typeof Button>) {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      data-slot="carousel-previous"
      variant={variant}
      size={size}
      className={cn(
        "absolute size-8 rounded-full",
        orientation === "horizontal"
          ? "top-1/2 -left-12 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
}

function CarouselNext({
  className,
  variant = "outline",
  size = "icon",
  ...props
}: React.ComponentProps<typeof Button>) {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      data-slot="carousel-next"
      variant={variant}
      size={size}
      className={cn(
        "absolute size-8 rounded-full",
        orientation === "horizontal"
          ? "top-1/2 -right-12 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight />
      <span className="sr-only">Next slide</span>
    </Button>
  )
}

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}
</file>

<file path="examples/hotvault-demo/client/src/components/ui/chart.tsx">
"use client"

import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

function ChartContainer({
  id,
  className,
  children,
  config,
  ...props
}: React.ComponentProps<"div"> & {
  config: ChartConfig
  children: React.ComponentProps<
    typeof RechartsPrimitive.ResponsiveContainer
  >["children"]
}) {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-slot="chart"
        data-chart={chartId}
        className={cn(
          "[&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border flex aspect-video justify-center text-xs [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-hidden [&_.recharts-sector]:outline-hidden [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-surface]:outline-hidden",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
}

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

function ChartTooltipContent({
  active,
  payload,
  className,
  indicator = "dot",
  hideLabel = false,
  hideIndicator = false,
  label,
  labelFormatter,
  labelClassName,
  formatter,
  color,
  nameKey,
  labelKey,
}: React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
  React.ComponentProps<"div"> & {
    hideLabel?: boolean
    hideIndicator?: boolean
    indicator?: "line" | "dot" | "dashed"
    nameKey?: string
    labelKey?: string
  }) {
  const { config } = useChart()

  const tooltipLabel = React.useMemo(() => {
    if (hideLabel || !payload?.length) {
      return null
    }

    const [item] = payload
    const key = `${labelKey || item?.dataKey || item?.name || "value"}`
    const itemConfig = getPayloadConfigFromPayload(config, item, key)
    const value =
      !labelKey && typeof label === "string"
        ? config[label as keyof typeof config]?.label || label
        : itemConfig?.label

    if (labelFormatter) {
      return (
        <div className={cn("font-medium", labelClassName)}>
          {labelFormatter(value, payload)}
        </div>
      )
    }

    if (!value) {
      return null
    }

    return <div className={cn("font-medium", labelClassName)}>{value}</div>
  }, [
    label,
    labelFormatter,
    payload,
    hideLabel,
    labelClassName,
    config,
    labelKey,
  ])

  if (!active || !payload?.length) {
    return null
  }

  const nestLabel = payload.length === 1 && indicator !== "dot"

  return (
    <div
      className={cn(
        "border-border/50 bg-background grid min-w-[8rem] items-start gap-1.5 rounded-lg border px-2.5 py-1.5 text-xs shadow-xl",
        className
      )}
    >
      {!nestLabel ? tooltipLabel : null}
      <div className="grid gap-1.5">
        {payload.map((item, index) => {
          const key = `${nameKey || item.name || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)
          const indicatorColor = color || item.payload.fill || item.color

          return (
            <div
              key={item.dataKey}
              className={cn(
                "[&>svg]:text-muted-foreground flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5",
                indicator === "dot" && "items-center"
              )}
            >
              {formatter && item?.value !== undefined && item.name ? (
                formatter(item.value, item.name, item, index, item.payload)
              ) : (
                <>
                  {itemConfig?.icon ? (
                    <itemConfig.icon />
                  ) : (
                    !hideIndicator && (
                      <div
                        className={cn(
                          "shrink-0 rounded-[2px] border-(--color-border) bg-(--color-bg)",
                          {
                            "h-2.5 w-2.5": indicator === "dot",
                            "w-1": indicator === "line",
                            "w-0 border-[1.5px] border-dashed bg-transparent":
                              indicator === "dashed",
                            "my-0.5": nestLabel && indicator === "dashed",
                          }
                        )}
                        style={
                          {
                            "--color-bg": indicatorColor,
                            "--color-border": indicatorColor,
                          } as React.CSSProperties
                        }
                      />
                    )
                  )}
                  <div
                    className={cn(
                      "flex flex-1 justify-between leading-none",
                      nestLabel ? "items-end" : "items-center"
                    )}
                  >
                    <div className="grid gap-1.5">
                      {nestLabel ? tooltipLabel : null}
                      <span className="text-muted-foreground">
                        {itemConfig?.label || item.name}
                      </span>
                    </div>
                    {item.value && (
                      <span className="text-foreground font-mono font-medium tabular-nums">
                        {item.value.toLocaleString()}
                      </span>
                    )}
                  </div>
                </>
              )}
            </div>
          )
        })}
      </div>
    </div>
  )
}

const ChartLegend = RechartsPrimitive.Legend

function ChartLegendContent({
  className,
  hideIcon = false,
  payload,
  verticalAlign = "bottom",
  nameKey,
}: React.ComponentProps<"div"> &
  Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
    hideIcon?: boolean
    nameKey?: string
  }) {
  const { config } = useChart()

  if (!payload?.length) {
    return null
  }

  return (
    <div
      className={cn(
        "flex items-center justify-center gap-4",
        verticalAlign === "top" ? "pb-3" : "pt-3",
        className
      )}
    >
      {payload.map((item) => {
        const key = `${nameKey || item.dataKey || "value"}`
        const itemConfig = getPayloadConfigFromPayload(config, item, key)

        return (
          <div
            key={item.value}
            className={cn(
              "[&>svg]:text-muted-foreground flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3"
            )}
          >
            {itemConfig?.icon && !hideIcon ? (
              <itemConfig.icon />
            ) : (
              <div
                className="h-2 w-2 shrink-0 rounded-[2px]"
                style={{
                  backgroundColor: item.color,
                }}
              />
            )}
            {itemConfig?.label}
          </div>
        )
      })}
    </div>
  )
}

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}
</file>

<file path="examples/hotvault-demo/client/src/components/ui/checkbox.tsx">
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { CheckIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Checkbox({
  className,
  ...props
}: React.ComponentProps<typeof CheckboxPrimitive.Root>) {
  return (
    <CheckboxPrimitive.Root
      data-slot="checkbox"
      className={cn(
        "peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <CheckboxPrimitive.Indicator
        data-slot="checkbox-indicator"
        className="flex items-center justify-center text-current transition-none"
      >
        <CheckIcon className="size-3.5" />
      </CheckboxPrimitive.Indicator>
    </CheckboxPrimitive.Root>
  )
}

export { Checkbox }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/collapsible.tsx">
"use client"

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

function Collapsible({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.Root>) {
  return <CollapsiblePrimitive.Root data-slot="collapsible" {...props} />
}

function CollapsibleTrigger({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleTrigger>) {
  return (
    <CollapsiblePrimitive.CollapsibleTrigger
      data-slot="collapsible-trigger"
      {...props}
    />
  )
}

function CollapsibleContent({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleContent>) {
  return (
    <CollapsiblePrimitive.CollapsibleContent
      data-slot="collapsible-content"
      {...props}
    />
  )
}

export { Collapsible, CollapsibleTrigger, CollapsibleContent }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/command.tsx">
"use client"

import * as React from "react"
import { Command as CommandPrimitive } from "cmdk"
import { SearchIcon } from "lucide-react"

import { cn } from "@/lib/utils"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"

function Command({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive>) {
  return (
    <CommandPrimitive
      data-slot="command"
      className={cn(
        "bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md",
        className
      )}
      {...props}
    />
  )
}

function CommandDialog({
  title = "Command Palette",
  description = "Search for a command to run...",
  children,
  ...props
}: React.ComponentProps<typeof Dialog> & {
  title?: string
  description?: string
}) {
  return (
    <Dialog {...props}>
      <DialogHeader className="sr-only">
        <DialogTitle>{title}</DialogTitle>
        <DialogDescription>{description}</DialogDescription>
      </DialogHeader>
      <DialogContent className="overflow-hidden p-0">
        <Command className="[&_[cmdk-group-heading]]:text-muted-foreground **:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

function CommandInput({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Input>) {
  return (
    <div
      data-slot="command-input-wrapper"
      className="flex h-9 items-center gap-2 border-b px-3"
    >
      <SearchIcon className="size-4 shrink-0 opacity-50" />
      <CommandPrimitive.Input
        data-slot="command-input"
        className={cn(
          "placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        {...props}
      />
    </div>
  )
}

function CommandList({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.List>) {
  return (
    <CommandPrimitive.List
      data-slot="command-list"
      className={cn(
        "max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto",
        className
      )}
      {...props}
    />
  )
}

function CommandEmpty({
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Empty>) {
  return (
    <CommandPrimitive.Empty
      data-slot="command-empty"
      className="py-6 text-center text-sm"
      {...props}
    />
  )
}

function CommandGroup({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Group>) {
  return (
    <CommandPrimitive.Group
      data-slot="command-group"
      className={cn(
        "text-foreground [&_[cmdk-group-heading]]:text-muted-foreground overflow-hidden p-1 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium",
        className
      )}
      {...props}
    />
  )
}

function CommandSeparator({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Separator>) {
  return (
    <CommandPrimitive.Separator
      data-slot="command-separator"
      className={cn("bg-border -mx-1 h-px", className)}
      {...props}
    />
  )
}

function CommandItem({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Item>) {
  return (
    <CommandPrimitive.Item
      data-slot="command-item"
      className={cn(
        "data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function CommandShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="command-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}
</file>

<file path="examples/hotvault-demo/client/src/components/ui/context-menu.tsx">
"use client"

import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function ContextMenu({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Root>) {
  return <ContextMenuPrimitive.Root data-slot="context-menu" {...props} />
}

function ContextMenuTrigger({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Trigger>) {
  return (
    <ContextMenuPrimitive.Trigger data-slot="context-menu-trigger" {...props} />
  )
}

function ContextMenuGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Group>) {
  return (
    <ContextMenuPrimitive.Group data-slot="context-menu-group" {...props} />
  )
}

function ContextMenuPortal({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Portal>) {
  return (
    <ContextMenuPrimitive.Portal data-slot="context-menu-portal" {...props} />
  )
}

function ContextMenuSub({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Sub>) {
  return <ContextMenuPrimitive.Sub data-slot="context-menu-sub" {...props} />
}

function ContextMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioGroup>) {
  return (
    <ContextMenuPrimitive.RadioGroup
      data-slot="context-menu-radio-group"
      {...props}
    />
  )
}

function ContextMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <ContextMenuPrimitive.SubTrigger
      data-slot="context-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto" />
    </ContextMenuPrimitive.SubTrigger>
  )
}

function ContextMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.SubContent>) {
  return (
    <ContextMenuPrimitive.SubContent
      data-slot="context-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

function ContextMenuContent({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Content>) {
  return (
    <ContextMenuPrimitive.Portal>
      <ContextMenuPrimitive.Content
        data-slot="context-menu-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-context-menu-content-available-height) min-w-[8rem] origin-(--radix-context-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </ContextMenuPrimitive.Portal>
  )
}

function ContextMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <ContextMenuPrimitive.Item
      data-slot="context-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function ContextMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.CheckboxItem>) {
  return (
    <ContextMenuPrimitive.CheckboxItem
      data-slot="context-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.CheckboxItem>
  )
}

function ContextMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.RadioItem>) {
  return (
    <ContextMenuPrimitive.RadioItem
      data-slot="context-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <ContextMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </ContextMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </ContextMenuPrimitive.RadioItem>
  )
}

function ContextMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <ContextMenuPrimitive.Label
      data-slot="context-menu-label"
      data-inset={inset}
      className={cn(
        "text-foreground px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function ContextMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof ContextMenuPrimitive.Separator>) {
  return (
    <ContextMenuPrimitive.Separator
      data-slot="context-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function ContextMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="context-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}
</file>

<file path="examples/hotvault-demo/client/src/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}
</file>

<file path="examples/hotvault-demo/client/src/components/ui/drawer.tsx">
"use client"

import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

function Drawer({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) {
  return <DrawerPrimitive.Root data-slot="drawer" {...props} />
}

function DrawerTrigger({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Trigger>) {
  return <DrawerPrimitive.Trigger data-slot="drawer-trigger" {...props} />
}

function DrawerPortal({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Portal>) {
  return <DrawerPrimitive.Portal data-slot="drawer-portal" {...props} />
}

function DrawerClose({
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Close>) {
  return <DrawerPrimitive.Close data-slot="drawer-close" {...props} />
}

function DrawerOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Overlay>) {
  return (
    <DrawerPrimitive.Overlay
      data-slot="drawer-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DrawerContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Content>) {
  return (
    <DrawerPortal data-slot="drawer-portal">
      <DrawerOverlay />
      <DrawerPrimitive.Content
        data-slot="drawer-content"
        className={cn(
          "group/drawer-content bg-background fixed z-50 flex h-auto flex-col",
          "data-[vaul-drawer-direction=top]:inset-x-0 data-[vaul-drawer-direction=top]:top-0 data-[vaul-drawer-direction=top]:mb-24 data-[vaul-drawer-direction=top]:max-h-[80vh] data-[vaul-drawer-direction=top]:rounded-b-lg data-[vaul-drawer-direction=top]:border-b",
          "data-[vaul-drawer-direction=bottom]:inset-x-0 data-[vaul-drawer-direction=bottom]:bottom-0 data-[vaul-drawer-direction=bottom]:mt-24 data-[vaul-drawer-direction=bottom]:max-h-[80vh] data-[vaul-drawer-direction=bottom]:rounded-t-lg data-[vaul-drawer-direction=bottom]:border-t",
          "data-[vaul-drawer-direction=right]:inset-y-0 data-[vaul-drawer-direction=right]:right-0 data-[vaul-drawer-direction=right]:w-3/4 data-[vaul-drawer-direction=right]:border-l data-[vaul-drawer-direction=right]:sm:max-w-sm",
          "data-[vaul-drawer-direction=left]:inset-y-0 data-[vaul-drawer-direction=left]:left-0 data-[vaul-drawer-direction=left]:w-3/4 data-[vaul-drawer-direction=left]:border-r data-[vaul-drawer-direction=left]:sm:max-w-sm",
          className
        )}
        {...props}
      >
        <div className="bg-muted mx-auto mt-4 hidden h-2 w-[100px] shrink-0 rounded-full group-data-[vaul-drawer-direction=bottom]/drawer-content:block" />
        {children}
      </DrawerPrimitive.Content>
    </DrawerPortal>
  )
}

function DrawerHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="drawer-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function DrawerFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="drawer-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function DrawerTitle({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Title>) {
  return (
    <DrawerPrimitive.Title
      data-slot="drawer-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function DrawerDescription({
  className,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Description>) {
  return (
    <DrawerPrimitive.Description
      data-slot="drawer-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}
</file>

<file path="examples/hotvault-demo/client/src/components/ui/dropdown-menu.tsx">
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}
</file>

<file path="examples/hotvault-demo/client/src/components/ui/form.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  useFormState,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState } = useFormContext()
  const formState = useFormState({ name: fieldContext.name })
  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

function FormItem({ className, ...props }: React.ComponentProps<"div">) {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div
        data-slot="form-item"
        className={cn("grid gap-2", className)}
        {...props}
      />
    </FormItemContext.Provider>
  )
}

function FormLabel({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  const { error, formItemId } = useFormField()

  return (
    <Label
      data-slot="form-label"
      data-error={!!error}
      className={cn("data-[error=true]:text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
}

function FormControl({ ...props }: React.ComponentProps<typeof Slot>) {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      data-slot="form-control"
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
}

function FormDescription({ className, ...props }: React.ComponentProps<"p">) {
  const { formDescriptionId } = useFormField()

  return (
    <p
      data-slot="form-description"
      id={formDescriptionId}
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function FormMessage({ className, ...props }: React.ComponentProps<"p">) {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : props.children

  if (!body) {
    return null
  }

  return (
    <p
      data-slot="form-message"
      id={formMessageId}
      className={cn("text-destructive text-sm", className)}
      {...props}
    >
      {body}
    </p>
  )
}

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
</file>

<file path="examples/hotvault-demo/client/src/components/ui/global-upload-progress.tsx">
"use client";

import { useUploadStore } from "@/store/upload-store";
import { motion, AnimatePresence } from "framer-motion";
import { Button } from "./button";
import { AlertTriangle, ExternalLink, RefreshCw } from "lucide-react";
import { useEffect, useState, useRef } from "react";
import { toast } from "sonner";

// Poll interval for checking status (milliseconds)
const STATUS_POLL_INTERVAL = 5000; // 5 seconds

// Define status colors for different upload states
const statusColors = {
  uploading: "bg-blue-100 text-blue-800",
  processing: "bg-purple-100 text-purple-800",
  complete: "bg-green-100 text-green-800",
  success: "bg-green-100 text-green-800",
  error: "bg-red-100 text-red-800",
  warning: "bg-amber-100 text-amber-800",
  retry: "bg-amber-100 text-amber-800",
  adding_root: "bg-blue-100 text-blue-800",
  pending: "bg-blue-100 text-blue-800",
};

// Convert status to human-readable text
const getStatusText = (status: string): string => {
  switch (status) {
    case "uploading":
      return "Uploading...";
    case "processing":
      return "Processing...";
    case "complete":
      return "Upload Complete";
    case "success":
      return "Upload Successful";
    case "error":
      return "Upload Failed";
    case "retry":
      return "Retrying...";
    case "adding_root":
      return "Adding to Chain...";
    case "pending":
      return "Initializing Proof Set...";
    default:
      return "Upload in Progress";
  }
};

// Helper function to get more detailed message based on status and existing message
const getDetailedMessage = (status: string, message?: string): string => {
  if (!message) return "";

  // Special case for "Locating user proof set..."
  if (message.includes("Locating user proof set")) {
    return "Finding or creating a proof set for your file...";
  }

  // If message contains "Adding root to proof set" but doesn't have attempt info
  if (
    message.includes("Adding root to proof set") &&
    !message.includes("attempt")
  ) {
    return "Storing file on the Filecoin network...";
  }

  // If message has "proof set creation is still pending"
  if (
    message.includes("proof set creation is still pending") ||
    message.includes("proof set is being initialized")
  ) {
    return "Waiting for confirmation of your proof set...";
  }

  return message;
};

// Custom event for notifying upload completion
export const UPLOAD_COMPLETED_EVENT = "upload:completed";

export const GlobalUploadProgress = () => {
  const { uploadProgress, clearUploadProgress, setUploadProgress } =
    useUploadStore();
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isDuplicate, setIsDuplicate] = useState(false);
  const [hasStalled, setHasStalled] = useState(false);
  const pollTimerRef = useRef<NodeJS.Timeout | null>(null);

  // Check authentication status
  useEffect(() => {
    const checkAuth = () => {
      const token = localStorage.getItem("jwt_token");
      setIsAuthenticated(!!token);
    };

    // Check initially
    checkAuth();

    // Set up event listener for storage changes
    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === "jwt_token") {
        checkAuth();
        // If token is removed, clear any ongoing upload progress
        if (!e.newValue) {
          clearUploadProgress();
        }
      }
    };

    window.addEventListener("storage", handleStorageChange);

    // Custom event listener for logout
    const handleLogout = () => {
      setIsAuthenticated(false);
      clearUploadProgress();
    };
    window.addEventListener("logout", handleLogout);

    return () => {
      window.removeEventListener("storage", handleStorageChange);
      window.removeEventListener("logout", handleLogout);
    };
  }, [clearUploadProgress]);

  // Polling for status updates when in certain states
  useEffect(() => {
    // Clear any existing poll timer on state change
    if (pollTimerRef.current) {
      clearInterval(pollTimerRef.current);
      pollTimerRef.current = null;
    }

    if (!uploadProgress || !uploadProgress.jobId) return;

    // Set up polling for these states
    if (
      uploadProgress.status === "adding_root" ||
      uploadProgress.status === "pending" ||
      (uploadProgress.isStalled &&
        (uploadProgress.message?.includes("proof set") ||
          uploadProgress.message?.includes("Proof set")))
    ) {
      console.log("[GlobalUploadProgress] Starting status polling");

      // Set up regular polling
      pollTimerRef.current = setInterval(() => {
        const token = localStorage.getItem("jwt_token");
        if (!token || !uploadProgress.jobId) return;

        console.log("[GlobalUploadProgress] Polling for status update");

        fetch(`/api/v1/upload/status/${uploadProgress.jobId}`, {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        })
          .then((response) => {
            if (!response.ok) {
              // Specifically handle 404 Not Found
              if (response.status === 404) {
                throw new Error(
                  `Upload status not found (Job ID: ${uploadProgress.jobId}). The job may have expired or the server restarted.`
                );
              }
              throw new Error(`Failed to get status (${response.status})`);
            }
            return response.json();
          })
          .then((data) => {
            console.log("[GlobalUploadProgress] Poll response:", data);

            // Only update if there's actual change
            if (
              data &&
              (data.status !== uploadProgress.status ||
                data.message !== uploadProgress.message ||
                data.progress !== uploadProgress.progress)
            ) {
              setUploadProgress({
                ...data,
                lastUpdated: Date.now(),
                isStalled: false,
              });

              if (data.status === "complete" || data.status === "success") {
                // Dispatch event to refresh file list
                window.dispatchEvent(
                  new CustomEvent(UPLOAD_COMPLETED_EVENT, {
                    detail: {
                      cid: data.cid,
                      filename: data.filename,
                      serviceProofSetId: data.serviceProofSetId,
                    },
                  })
                );

                if (pollTimerRef.current) {
                  clearInterval(pollTimerRef.current);
                  pollTimerRef.current = null;
                }
              }
            }
          })
          .catch((error) => {
            console.error("[GlobalUploadProgress] Poll error:", error);
            // Stop polling if the job is not found (404) or on other critical errors
            if (
              error.message.includes("Upload status not found") ||
              error.message.includes("Failed to get status")
            ) {
              setUploadProgress({
                status: "error",
                error: error.message,
                lastUpdated: Date.now(),
                jobId: uploadProgress?.jobId, // Keep jobId if available
                filename: uploadProgress?.filename, // Keep filename if available
              });
              if (pollTimerRef.current) {
                clearInterval(pollTimerRef.current);
                pollTimerRef.current = null;
              }
            }
            // For other errors, we might want to let polling continue or handle differently
          });
      }, STATUS_POLL_INTERVAL);

      return () => {
        if (pollTimerRef.current) {
          clearInterval(pollTimerRef.current);
          pollTimerRef.current = null;
        }
      };
    }
  }, [uploadProgress, setUploadProgress]);

  // Auto-dismiss logic for completed/error states and trigger file list refresh
  useEffect(() => {
    if (!uploadProgress) {
      setHasStalled(false);
      return;
    }

    // Immediately clear progress if progress is 100%
    if (uploadProgress.progress === 100 || uploadProgress.progress === 100.0) {
      console.log(
        "[GlobalUploadProgress] Progress reached 100%, forcing immediate dismissal"
      );
      // Dispatch the completion event immediately
      try {
        window.dispatchEvent(
          new CustomEvent(UPLOAD_COMPLETED_EVENT, {
            detail: {
              cid: uploadProgress.cid,
              filename: uploadProgress.filename,
              serviceProofSetId: uploadProgress.serviceProofSetId,
            },
          })
        );
      } catch (err) {
        console.error("[GlobalUploadProgress] Error dispatching event:", err);
      }

      // Force clear immediately - no delay
      clearUploadProgress();
      setHasStalled(false);
      return;
    }

    // If upload is complete/successful, dispatch event to refresh file list
    if (
      uploadProgress.status === "complete" ||
      uploadProgress.status === "success"
    ) {
      console.log(
        "[GlobalUploadProgress] Upload complete, dispatching event immediately"
      );

      // Dispatch the event IMMEDIATELY to refresh the file list
      try {
        window.dispatchEvent(
          new CustomEvent(UPLOAD_COMPLETED_EVENT, {
            detail: {
              cid: uploadProgress.cid,
              filename: uploadProgress.filename,
              serviceProofSetId: uploadProgress.serviceProofSetId,
            },
          })
        );
      } catch (err) {
        console.error("[GlobalUploadProgress] Error dispatching event:", err);
      }

      // Set timer to clear the progress notification - use a SHORTER timeout
      const timer = setTimeout(() => {
        console.log("[GlobalUploadProgress] Clearing upload progress");
        clearUploadProgress();
        setHasStalled(false);
      }, 500); // Reduced from 1500 to 500 (0.5 seconds) - much faster dismissal

      return () => clearTimeout(timer);
    }

    // Handle error state
    if (uploadProgress.status === "error") {
      const timer = setTimeout(() => {
        console.log("[GlobalUploadProgress] Clearing error state");
        clearUploadProgress();
        setHasStalled(false);
      }, 5000); // Dismiss after 5 seconds

      return () => clearTimeout(timer);
    }

    // Handle stalled uploads
    if (
      uploadProgress.status === "uploading" ||
      uploadProgress.status === "processing" ||
      uploadProgress.status === "adding_root" ||
      uploadProgress.status === "retry" ||
      uploadProgress.status === "pending"
    ) {
      const lastUpdate = uploadProgress.lastUpdated;
      const currentTime = Date.now();

      // If no update for 30 seconds, consider it stalled
      if (lastUpdate && currentTime - lastUpdate > 30000) {
        setHasStalled(true);
      }
    }
  }, [uploadProgress, clearUploadProgress, setHasStalled]);

  // Add duplicate handling
  useEffect(() => {
    if (uploadProgress?.error?.includes("duplicate key value")) {
      setIsDuplicate(true);
      // Auto-clear after showing duplicate message
      const timer = setTimeout(() => {
        clearUploadProgress();
        setIsDuplicate(false);
      }, 5000);
      return () => clearTimeout(timer);
    }
  }, [uploadProgress?.error, clearUploadProgress]);

  // Handle manual refresh of stalled uploads
  const handleManualRetry = () => {
    if (!uploadProgress) return;

    // Only allow retry for certain states
    if (
      uploadProgress.status === "adding_root" ||
      uploadProgress.status === "processing" ||
      uploadProgress.status === "retry" ||
      uploadProgress.status === "pending" ||
      uploadProgress.isStalled
    ) {
      // Set the stalled flag to false
      setHasStalled(false);

      // Force a status update with new timestamp to reset the stalled timer
      setUploadProgress({
        ...uploadProgress,
        lastUpdated: Date.now(),
        message: uploadProgress.message?.includes("attempt")
          ? uploadProgress.message
          : `${uploadProgress.message} (manually refreshed)`,
        isStalled: false,
      });

      toast.info("Refreshing upload status...");

      // If we have a jobId, try to refresh the status from server
      if (uploadProgress.jobId) {
        fetch(`/api/v1/upload/status/${uploadProgress.jobId}`, {
          headers: {
            Authorization: `Bearer ${localStorage.getItem("jwt_token")}`,
          },
        })
          .then((response) => {
            if (!response.ok) {
              throw new Error("Failed to refresh status");
            }
            return response.json();
          })
          .then((data) => {
            console.log(
              "[GlobalUploadProgress] Manual refresh response:",
              data
            );
            if (data) {
              // If the status shows the same state for too long, we might need to clear and retry
              if (
                data.status === uploadProgress.status &&
                data.message === uploadProgress.message &&
                uploadProgress.isStalled
              ) {
                toast.warning(
                  "Process appears to be stuck. You may want to cancel and try again."
                );
              } else {
                setUploadProgress({
                  ...data,
                  lastUpdated: Date.now(),
                  isStalled: false,
                });
                toast.success("Status refreshed");
              }
            }
          })
          .catch((error) => {
            console.error("Error refreshing status:", error);
            toast.error("Failed to refresh status. Please try again.");
          });
      }
    }
  };

  // Don't show anything if not authenticated or no upload progress
  if (!isAuthenticated || !uploadProgress) return null;

  const statusColor =
    statusColors[uploadProgress.status as keyof typeof statusColors] ||
    statusColors.uploading;

  // Determine if we're in a retry state
  const isRetrying = uploadProgress.status === "retry";
  // Determine if we're in a state where manual retry is allowed
  const canManuallyRetry =
    hasStalled &&
    (uploadProgress.status === "adding_root" ||
      uploadProgress.status === "processing" ||
      uploadProgress.status === "retry" ||
      uploadProgress.status === "pending");

  return (
    <AnimatePresence>
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        exit={{ opacity: 0, y: 20 }}
        className="fixed bottom-4 right-4 z-50 w-80 shadow-lg rounded-lg overflow-hidden"
      >
        <div
          className={`p-4 ${isDuplicate ? statusColors.warning : statusColor}`}
        >
          <div className="flex justify-between items-start">
            <div className="flex-1">
              <div className="flex items-center gap-2 font-medium">
                {uploadProgress.isStalled && (
                  <AlertTriangle className="h-4 w-4 text-amber-500" />
                )}
                {isRetrying && (
                  <RefreshCw className="h-4 w-4 text-amber-500 animate-spin" />
                )}
                <span>
                  {isDuplicate
                    ? "Duplicate File Detected"
                    : getStatusText(uploadProgress.status)}
                </span>
              </div>
              {uploadProgress.message && (
                <div className="text-sm mt-1 opacity-80 line-clamp-2">
                  {getDetailedMessage(
                    uploadProgress.status,
                    uploadProgress.message
                  )}
                </div>
              )}
              {uploadProgress.isStalled && (
                <div className="text-amber-600 text-sm mt-1">
                  No updates received for a while.
                </div>
              )}
              {/* Easter egg for when files are being uploaded */}
              {(uploadProgress.status === "uploading" ||
                uploadProgress.status === "processing") &&
                !uploadProgress.isStalled && (
                  <div className="text-gray-500 text-xs mt-1 italic">
                    <a
                      href="https://www.youtube.com/watch?v=OsU0CGZoV8E"
                      target="_blank"
                      rel="noopener noreferrer"
                      className="flex items-center text-blue-500 hover:text-blue-700 transition-colors"
                    >
                      <span>
                        Watch this important Video while we get your data on
                        Filecoin
                      </span>
                      <ExternalLink className="h-3 w-3 ml-1" />
                    </a>
                  </div>
                )}
              {canManuallyRetry && (
                <div className="mt-2">
                  <Button
                    onClick={handleManualRetry}
                    variant="outline"
                    size="sm"
                    className="w-full flex items-center justify-center gap-2 bg-amber-50 text-amber-700 border-amber-200 hover:bg-amber-100"
                  >
                    <RefreshCw className="h-3 w-3" />
                    <span>Manual Refresh</span>
                  </Button>
                </div>
              )}
              {uploadProgress.error && (
                <div className="text-red-500 text-sm mt-1 line-clamp-2">
                  Error: {uploadProgress.error}
                </div>
              )}
              {uploadProgress.filename && (
                <div className="text-xs text-gray-500 mt-1 truncate">
                  {uploadProgress.filename}
                </div>
              )}
              {uploadProgress.serviceProofSetId && (
                <div className="text-xs mt-2 flex items-center">
                  <span className="mr-2">Proof Set ID:</span>
                  <a
                    href={` http://explore-pdp.xyz:5173/proofsets/${uploadProgress.serviceProofSetId}`}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="text-blue-600 hover:text-blue-800 underline flex items-center"
                  >
                    {uploadProgress.serviceProofSetId}
                    <ExternalLink className="h-3 w-3 ml-1" />
                  </a>
                </div>
              )}
              {isDuplicate && (
                <div className="text-amber-600 text-sm mt-1">
                  This file has already been uploaded. Please check your
                  existing files.
                </div>
              )}
            </div>
            {uploadProgress.progress !== undefined && (
              <div className="text-sm font-medium ml-2">
                {Math.min(uploadProgress.progress, 100)}%
              </div>
            )}
          </div>

          {uploadProgress.progress !== undefined && (
            <div className="w-full bg-gray-200 rounded-full h-2.5 mt-3">
              <motion.div
                initial={{ width: 0 }}
                animate={{
                  width: `${Math.min(uploadProgress.progress || 0, 100)}%`,
                }}
                transition={{ duration: 0.3 }}
                className={`h-2.5 rounded-full ${
                  uploadProgress.status === "error"
                    ? "bg-red-500"
                    : uploadProgress.status === "complete" ||
                      uploadProgress.status === "success"
                    ? "bg-green-500"
                    : uploadProgress.status === "retry"
                    ? "bg-amber-500"
                    : uploadProgress.isStalled
                    ? "bg-amber-500"
                    : "bg-blue-500"
                }`}
              />
            </div>
          )}

          {/* Display completed upload info with links */}
          {uploadProgress.status === "complete" && uploadProgress.cid && (
            <div className="mt-3 pt-3 border-t border-green-200">
              <div className="flex flex-col gap-2">
                {uploadProgress.serviceProofSetId && (
                  <a
                    href={` http://explore-pdp.xyz:5173/proofsets/${uploadProgress.serviceProofSetId}`}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="text-sm flex items-center justify-between bg-green-100 text-green-800 p-2 rounded hover:bg-green-200 transition-colors"
                  >
                    <span className="flex items-center">
                      <svg
                        xmlns="http://www.w3.org/2000/svg"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        className="h-4 w-4 mr-2"
                      >
                        <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                      </svg>
                      View Proof Set
                    </span>
                    <ExternalLink className="h-3 w-3" />
                  </a>
                )}
              </div>
            </div>
          )}
        </div>
      </motion.div>
    </AnimatePresence>
  );
};
</file>

<file path="examples/hotvault-demo/client/src/components/ui/hover-card.tsx">
"use client"

import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/lib/utils"

function HoverCard({
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Root>) {
  return <HoverCardPrimitive.Root data-slot="hover-card" {...props} />
}

function HoverCardTrigger({
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Trigger>) {
  return (
    <HoverCardPrimitive.Trigger data-slot="hover-card-trigger" {...props} />
  )
}

function HoverCardContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof HoverCardPrimitive.Content>) {
  return (
    <HoverCardPrimitive.Portal data-slot="hover-card-portal">
      <HoverCardPrimitive.Content
        data-slot="hover-card-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-64 origin-(--radix-hover-card-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </HoverCardPrimitive.Portal>
  )
}

export { HoverCard, HoverCardTrigger, HoverCardContent }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/input-otp.tsx">
"use client"

import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { MinusIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function InputOTP({
  className,
  containerClassName,
  ...props
}: React.ComponentProps<typeof OTPInput> & {
  containerClassName?: string
}) {
  return (
    <OTPInput
      data-slot="input-otp"
      containerClassName={cn(
        "flex items-center gap-2 has-disabled:opacity-50",
        containerClassName
      )}
      className={cn("disabled:cursor-not-allowed", className)}
      {...props}
    />
  )
}

function InputOTPGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="input-otp-group"
      className={cn("flex items-center", className)}
      {...props}
    />
  )
}

function InputOTPSlot({
  index,
  className,
  ...props
}: React.ComponentProps<"div"> & {
  index: number
}) {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext?.slots[index] ?? {}

  return (
    <div
      data-slot="input-otp-slot"
      data-active={isActive}
      className={cn(
        "data-[active=true]:border-ring data-[active=true]:ring-ring/50 data-[active=true]:aria-invalid:ring-destructive/20 dark:data-[active=true]:aria-invalid:ring-destructive/40 aria-invalid:border-destructive data-[active=true]:aria-invalid:border-destructive dark:bg-input/30 border-input relative flex h-9 w-9 items-center justify-center border-y border-r text-sm shadow-xs transition-all outline-none first:rounded-l-md first:border-l last:rounded-r-md data-[active=true]:z-10 data-[active=true]:ring-[3px]",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="animate-caret-blink bg-foreground h-4 w-px duration-1000" />
        </div>
      )}
    </div>
  )
}

function InputOTPSeparator({ ...props }: React.ComponentProps<"div">) {
  return (
    <div data-slot="input-otp-separator" role="separator" {...props}>
      <MinusIcon />
    </div>
  )
}

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/menubar.tsx">
"use client"

import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Menubar({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Root>) {
  return (
    <MenubarPrimitive.Root
      data-slot="menubar"
      className={cn(
        "bg-background flex h-9 items-center gap-1 rounded-md border p-1 shadow-xs",
        className
      )}
      {...props}
    />
  )
}

function MenubarMenu({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu data-slot="menubar-menu" {...props} />
}

function MenubarGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group data-slot="menubar-group" {...props} />
}

function MenubarPortal({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal data-slot="menubar-portal" {...props} />
}

function MenubarRadioGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return (
    <MenubarPrimitive.RadioGroup data-slot="menubar-radio-group" {...props} />
  )
}

function MenubarTrigger({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Trigger>) {
  return (
    <MenubarPrimitive.Trigger
      data-slot="menubar-trigger"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex items-center rounded-sm px-2 py-1 text-sm font-medium outline-hidden select-none",
        className
      )}
      {...props}
    />
  )
}

function MenubarContent({
  className,
  align = "start",
  alignOffset = -4,
  sideOffset = 8,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Content>) {
  return (
    <MenubarPortal>
      <MenubarPrimitive.Content
        data-slot="menubar-content"
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[12rem] origin-(--radix-menubar-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </MenubarPortal>
  )
}

function MenubarItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <MenubarPrimitive.Item
      data-slot="menubar-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function MenubarCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.CheckboxItem>) {
  return (
    <MenubarPrimitive.CheckboxItem
      data-slot="menubar-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <MenubarPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.CheckboxItem>
  )
}

function MenubarRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioItem>) {
  return (
    <MenubarPrimitive.RadioItem
      data-slot="menubar-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-xs py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <MenubarPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </MenubarPrimitive.ItemIndicator>
      </span>
      {children}
    </MenubarPrimitive.RadioItem>
  )
}

function MenubarLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <MenubarPrimitive.Label
      data-slot="menubar-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function MenubarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Separator>) {
  return (
    <MenubarPrimitive.Separator
      data-slot="menubar-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function MenubarShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="menubar-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function MenubarSub({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />
}

function MenubarSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <MenubarPrimitive.SubTrigger
      data-slot="menubar-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-none select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto h-4 w-4" />
    </MenubarPrimitive.SubTrigger>
  )
}

function MenubarSubContent({
  className,
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.SubContent>) {
  return (
    <MenubarPrimitive.SubContent
      data-slot="menubar-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-menubar-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  Menubar,
  MenubarPortal,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarGroup,
  MenubarSeparator,
  MenubarLabel,
  MenubarItem,
  MenubarShortcut,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarSub,
  MenubarSubTrigger,
  MenubarSubContent,
}
</file>

<file path="examples/hotvault-demo/client/src/components/ui/navigation-menu.tsx">
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDownIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function NavigationMenu({
  className,
  children,
  viewport = true,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Root> & {
  viewport?: boolean
}) {
  return (
    <NavigationMenuPrimitive.Root
      data-slot="navigation-menu"
      data-viewport={viewport}
      className={cn(
        "group/navigation-menu relative flex max-w-max flex-1 items-center justify-center",
        className
      )}
      {...props}
    >
      {children}
      {viewport && <NavigationMenuViewport />}
    </NavigationMenuPrimitive.Root>
  )
}

function NavigationMenuList({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.List>) {
  return (
    <NavigationMenuPrimitive.List
      data-slot="navigation-menu-list"
      className={cn(
        "group flex flex-1 list-none items-center justify-center gap-1",
        className
      )}
      {...props}
    />
  )
}

function NavigationMenuItem({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Item>) {
  return (
    <NavigationMenuPrimitive.Item
      data-slot="navigation-menu-item"
      className={cn("relative", className)}
      {...props}
    />
  )
}

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=open]:hover:bg-accent data-[state=open]:text-accent-foreground data-[state=open]:focus:bg-accent data-[state=open]:bg-accent/50 focus-visible:ring-ring/50 outline-none transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1"
)

function NavigationMenuTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Trigger>) {
  return (
    <NavigationMenuPrimitive.Trigger
      data-slot="navigation-menu-trigger"
      className={cn(navigationMenuTriggerStyle(), "group", className)}
      {...props}
    >
      {children}{" "}
      <ChevronDownIcon
        className="relative top-[1px] ml-1 size-3 transition duration-300 group-data-[state=open]:rotate-180"
        aria-hidden="true"
      />
    </NavigationMenuPrimitive.Trigger>
  )
}

function NavigationMenuContent({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Content>) {
  return (
    <NavigationMenuPrimitive.Content
      data-slot="navigation-menu-content"
      className={cn(
        "data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 top-0 left-0 w-full p-2 pr-2.5 md:absolute md:w-auto",
        "group-data-[viewport=false]/navigation-menu:bg-popover group-data-[viewport=false]/navigation-menu:text-popover-foreground group-data-[viewport=false]/navigation-menu:data-[state=open]:animate-in group-data-[viewport=false]/navigation-menu:data-[state=closed]:animate-out group-data-[viewport=false]/navigation-menu:data-[state=closed]:zoom-out-95 group-data-[viewport=false]/navigation-menu:data-[state=open]:zoom-in-95 group-data-[viewport=false]/navigation-menu:data-[state=open]:fade-in-0 group-data-[viewport=false]/navigation-menu:data-[state=closed]:fade-out-0 group-data-[viewport=false]/navigation-menu:top-full group-data-[viewport=false]/navigation-menu:mt-1.5 group-data-[viewport=false]/navigation-menu:overflow-hidden group-data-[viewport=false]/navigation-menu:rounded-md group-data-[viewport=false]/navigation-menu:border group-data-[viewport=false]/navigation-menu:shadow group-data-[viewport=false]/navigation-menu:duration-200 **:data-[slot=navigation-menu-link]:focus:ring-0 **:data-[slot=navigation-menu-link]:focus:outline-none",
        className
      )}
      {...props}
    />
  )
}

function NavigationMenuViewport({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Viewport>) {
  return (
    <div
      className={cn(
        "absolute top-full left-0 isolate z-50 flex justify-center"
      )}
    >
      <NavigationMenuPrimitive.Viewport
        data-slot="navigation-menu-viewport"
        className={cn(
          "origin-top-center bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border shadow md:w-[var(--radix-navigation-menu-viewport-width)]",
          className
        )}
        {...props}
      />
    </div>
  )
}

function NavigationMenuLink({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Link>) {
  return (
    <NavigationMenuPrimitive.Link
      data-slot="navigation-menu-link"
      className={cn(
        "data-[active=true]:focus:bg-accent data-[active=true]:hover:bg-accent data-[active=true]:bg-accent/50 data-[active=true]:text-accent-foreground hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus-visible:ring-ring/50 [&_svg:not([class*='text-'])]:text-muted-foreground flex flex-col gap-1 rounded-sm p-2 text-sm transition-all outline-none focus-visible:ring-[3px] focus-visible:outline-1 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function NavigationMenuIndicator({
  className,
  ...props
}: React.ComponentProps<typeof NavigationMenuPrimitive.Indicator>) {
  return (
    <NavigationMenuPrimitive.Indicator
      data-slot="navigation-menu-indicator"
      className={cn(
        "data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden",
        className
      )}
      {...props}
    >
      <div className="bg-border relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm shadow-md" />
    </NavigationMenuPrimitive.Indicator>
  )
}

export {
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
  navigationMenuTriggerStyle,
}
</file>

<file path="examples/hotvault-demo/client/src/components/ui/pagination.tsx">
import * as React from "react"
import {
  ChevronLeftIcon,
  ChevronRightIcon,
  MoreHorizontalIcon,
} from "lucide-react"

import { cn } from "@/lib/utils"
import { Button, buttonVariants } from "@/components/ui/button"

function Pagination({ className, ...props }: React.ComponentProps<"nav">) {
  return (
    <nav
      role="navigation"
      aria-label="pagination"
      data-slot="pagination"
      className={cn("mx-auto flex w-full justify-center", className)}
      {...props}
    />
  )
}

function PaginationContent({
  className,
  ...props
}: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="pagination-content"
      className={cn("flex flex-row items-center gap-1", className)}
      {...props}
    />
  )
}

function PaginationItem({ ...props }: React.ComponentProps<"li">) {
  return <li data-slot="pagination-item" {...props} />
}

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<React.ComponentProps<typeof Button>, "size"> &
  React.ComponentProps<"a">

function PaginationLink({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) {
  return (
    <a
      aria-current={isActive ? "page" : undefined}
      data-slot="pagination-link"
      data-active={isActive}
      className={cn(
        buttonVariants({
          variant: isActive ? "outline" : "ghost",
          size,
        }),
        className
      )}
      {...props}
    />
  )
}

function PaginationPrevious({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) {
  return (
    <PaginationLink
      aria-label="Go to previous page"
      size="default"
      className={cn("gap-1 px-2.5 sm:pl-2.5", className)}
      {...props}
    >
      <ChevronLeftIcon />
      <span className="hidden sm:block">Previous</span>
    </PaginationLink>
  )
}

function PaginationNext({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) {
  return (
    <PaginationLink
      aria-label="Go to next page"
      size="default"
      className={cn("gap-1 px-2.5 sm:pr-2.5", className)}
      {...props}
    >
      <span className="hidden sm:block">Next</span>
      <ChevronRightIcon />
    </PaginationLink>
  )
}

function PaginationEllipsis({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      aria-hidden
      data-slot="pagination-ellipsis"
      className={cn("flex size-9 items-center justify-center", className)}
      {...props}
    >
      <MoreHorizontalIcon className="size-4" />
      <span className="sr-only">More pages</span>
    </span>
  )
}

export {
  Pagination,
  PaginationContent,
  PaginationLink,
  PaginationItem,
  PaginationPrevious,
  PaginationNext,
  PaginationEllipsis,
}
</file>

<file path="examples/hotvault-demo/client/src/components/ui/popover.tsx">
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  )
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/progress.tsx">
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

function Progress({
  className,
  value,
  ...props
}: React.ComponentProps<typeof ProgressPrimitive.Root>) {
  return (
    <ProgressPrimitive.Root
      data-slot="progress"
      className={cn(
        "bg-primary/20 relative h-2 w-full overflow-hidden rounded-full",
        className
      )}
      {...props}
    >
      <ProgressPrimitive.Indicator
        data-slot="progress-indicator"
        className="bg-primary h-full w-full flex-1 transition-all"
        style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
      />
    </ProgressPrimitive.Root>
  )
}

export { Progress }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/proof-set-banner.tsx">
import { motion } from "framer-motion";
import { useEffect, useState } from "react";
import { API_BASE_URL } from "@/lib/constants";

export const ProofSetBanner: React.FC = () => {
  const [proofSetStatus, setProofSetStatus] = useState<
    "idle" | "pending" | "ready"
  >("idle");
  const [hasInitiated, setHasInitiated] = useState(false);

  useEffect(() => {
    // Only poll if we're in a pending state or we haven't checked yet
    if (proofSetStatus === "pending" || proofSetStatus === "idle") {
      const checkProofSetStatus = async () => {
        try {
          const response = await fetch(`${API_BASE_URL}/api/v1/auth/status`, {
            credentials: "include",
          });

          if (response.ok) {
            const data = await response.json();

            if (data.proofSetReady) {
              setProofSetStatus("ready");
              console.log("[ProofSetBanner] Proof set is ready");
            } else if (data.proofSetInitiated) {
              setHasInitiated(true);
              setProofSetStatus("pending");
              console.log("[ProofSetBanner] Proof set is pending");
            } else {
              setProofSetStatus("idle");
              console.log("[ProofSetBanner] Proof set not initiated");
            }
          }
        } catch (error) {
          console.error(
            "[ProofSetBanner] Error checking proof set status:",
            error
          );
        }
      };

      // Check immediately on mount
      checkProofSetStatus();

      // Set up polling every 15 seconds
      const interval = setInterval(checkProofSetStatus, 15000);

      return () => clearInterval(interval);
    }
  }, [proofSetStatus]);

  // Only show banner if proof set creation has been initiated and is pending
  if (!hasInitiated || proofSetStatus !== "pending") return null;

  return (
    <motion.div
      className="fixed top-16 inset-x-0 z-40"
      initial={{ opacity: 0, y: -20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: -20 }}
    >
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="p-3 bg-blue-50 border border-blue-200 shadow-md rounded-md text-blue-700 flex items-center gap-3">
          <div className="flex-shrink-0 bg-blue-100 p-2 rounded-full">
            <div className="animate-spin h-5 w-5 border-2 border-blue-500 rounded-full border-t-transparent"></div>
          </div>
          <div className="flex-1">
            <p className="text-sm font-medium">
              Proof Set Creation in Progress
            </p>
            <p className="text-xs">
              Your proof set is being created on FWS. This process typically
              takes few minutes to complete.{" "}
              <span className="font-semibold">
                File uploads are temporarily disabled
              </span>{" "}
              and will become available once the proof set is ready.
            </p>
          </div>
        </div>
      </div>
    </motion.div>
  );
};
</file>

<file path="examples/hotvault-demo/client/src/components/ui/radio-group.tsx">
"use client"

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function RadioGroup({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Root>) {
  return (
    <RadioGroupPrimitive.Root
      data-slot="radio-group"
      className={cn("grid gap-3", className)}
      {...props}
    />
  )
}

function RadioGroupItem({
  className,
  ...props
}: React.ComponentProps<typeof RadioGroupPrimitive.Item>) {
  return (
    <RadioGroupPrimitive.Item
      data-slot="radio-group-item"
      className={cn(
        "border-input text-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 aspect-square size-4 shrink-0 rounded-full border shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator
        data-slot="radio-group-indicator"
        className="relative flex items-center justify-center"
      >
        <CircleIcon className="fill-primary absolute top-1/2 left-1/2 size-2 -translate-x-1/2 -translate-y-1/2" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
}

export { RadioGroup, RadioGroupItem }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/resizable.tsx">
"use client"

import * as React from "react"
import { GripVerticalIcon } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

function ResizablePanelGroup({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) {
  return (
    <ResizablePrimitive.PanelGroup
      data-slot="resizable-panel-group"
      className={cn(
        "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
        className
      )}
      {...props}
    />
  )
}

function ResizablePanel({
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.Panel>) {
  return <ResizablePrimitive.Panel data-slot="resizable-panel" {...props} />
}

function ResizableHandle({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) {
  return (
    <ResizablePrimitive.PanelResizeHandle
      data-slot="resizable-handle"
      className={cn(
        "bg-border focus-visible:ring-ring relative flex w-px items-center justify-center after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:ring-1 focus-visible:ring-offset-1 focus-visible:outline-hidden data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
        className
      )}
      {...props}
    >
      {withHandle && (
        <div className="bg-border z-10 flex h-4 w-3 items-center justify-center rounded-xs border">
          <GripVerticalIcon className="size-2.5" />
        </div>
      )}
    </ResizablePrimitive.PanelResizeHandle>
  )
}

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/scroll-area.tsx">
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}
</file>

<file path="examples/hotvault-demo/client/src/components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/sheet.tsx">
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
</file>

<file path="examples/hotvault-demo/client/src/components/ui/sidebar.tsx">
"use client"

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeftIcon } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

function SidebarProvider({
  defaultOpen = true,
  open: openProp,
  onOpenChange: setOpenProp,
  className,
  style,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  defaultOpen?: boolean
  open?: boolean
  onOpenChange?: (open: boolean) => void
}) {
  const isMobile = useIsMobile()
  const [openMobile, setOpenMobile] = React.useState(false)

  // This is the internal state of the sidebar.
  // We use openProp and setOpenProp for control from outside the component.
  const [_open, _setOpen] = React.useState(defaultOpen)
  const open = openProp ?? _open
  const setOpen = React.useCallback(
    (value: boolean | ((value: boolean) => boolean)) => {
      const openState = typeof value === "function" ? value(open) : value
      if (setOpenProp) {
        setOpenProp(openState)
      } else {
        _setOpen(openState)
      }

      // This sets the cookie to keep the sidebar state.
      document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
    },
    [setOpenProp, open]
  )

  // Helper to toggle the sidebar.
  const toggleSidebar = React.useCallback(() => {
    return isMobile ? setOpenMobile((open) => !open) : setOpen((open) => !open)
  }, [isMobile, setOpen, setOpenMobile])

  // Adds a keyboard shortcut to toggle the sidebar.
  React.useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (
        event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
        (event.metaKey || event.ctrlKey)
      ) {
        event.preventDefault()
        toggleSidebar()
      }
    }

    window.addEventListener("keydown", handleKeyDown)
    return () => window.removeEventListener("keydown", handleKeyDown)
  }, [toggleSidebar])

  // We add a state so that we can do data-state="expanded" or "collapsed".
  // This makes it easier to style the sidebar with Tailwind classes.
  const state = open ? "expanded" : "collapsed"

  const contextValue = React.useMemo<SidebarContextProps>(
    () => ({
      state,
      open,
      setOpen,
      isMobile,
      openMobile,
      setOpenMobile,
      toggleSidebar,
    }),
    [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
  )

  return (
    <SidebarContext.Provider value={contextValue}>
      <TooltipProvider delayDuration={0}>
        <div
          data-slot="sidebar-wrapper"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH,
              "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
              ...style,
            } as React.CSSProperties
          }
          className={cn(
            "group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full",
            className
          )}
          {...props}
        >
          {children}
        </div>
      </TooltipProvider>
    </SidebarContext.Provider>
  )
}

function Sidebar({
  side = "left",
  variant = "sidebar",
  collapsible = "offcanvas",
  className,
  children,
  ...props
}: React.ComponentProps<"div"> & {
  side?: "left" | "right"
  variant?: "sidebar" | "floating" | "inset"
  collapsible?: "offcanvas" | "icon" | "none"
}) {
  const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

  if (collapsible === "none") {
    return (
      <div
        data-slot="sidebar"
        className={cn(
          "bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col",
          className
        )}
        {...props}
      >
        {children}
      </div>
    )
  }

  if (isMobile) {
    return (
      <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
        <SheetContent
          data-sidebar="sidebar"
          data-slot="sidebar"
          data-mobile="true"
          className="bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden"
          style={
            {
              "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
            } as React.CSSProperties
          }
          side={side}
        >
          <SheetHeader className="sr-only">
            <SheetTitle>Sidebar</SheetTitle>
            <SheetDescription>Displays the mobile sidebar.</SheetDescription>
          </SheetHeader>
          <div className="flex h-full w-full flex-col">{children}</div>
        </SheetContent>
      </Sheet>
    )
  }

  return (
    <div
      className="group peer text-sidebar-foreground hidden md:block"
      data-state={state}
      data-collapsible={state === "collapsed" ? collapsible : ""}
      data-variant={variant}
      data-side={side}
      data-slot="sidebar"
    >
      {/* This is what handles the sidebar gap on desktop */}
      <div
        data-slot="sidebar-gap"
        className={cn(
          "relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear",
          "group-data-[collapsible=offcanvas]:w-0",
          "group-data-[side=right]:rotate-180",
          variant === "floating" || variant === "inset"
            ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)"
        )}
      />
      <div
        data-slot="sidebar-container"
        className={cn(
          "fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex",
          side === "left"
            ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
            : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
          // Adjust the padding for floating and inset variants.
          variant === "floating" || variant === "inset"
            ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]"
            : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l",
          className
        )}
        {...props}
      >
        <div
          data-sidebar="sidebar"
          data-slot="sidebar-inner"
          className="bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm"
        >
          {children}
        </div>
      </div>
    </div>
  )
}

function SidebarTrigger({
  className,
  onClick,
  ...props
}: React.ComponentProps<typeof Button>) {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      data-sidebar="trigger"
      data-slot="sidebar-trigger"
      variant="ghost"
      size="icon"
      className={cn("size-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeftIcon />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
}

function SidebarRail({ className, ...props }: React.ComponentProps<"button">) {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      data-sidebar="rail"
      data-slot="sidebar-rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "hover:after:bg-sidebar-border absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear group-data-[side=left]:-right-4 group-data-[side=right]:left-0 after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] sm:flex",
        "in-data-[side=left]:cursor-w-resize in-data-[side=right]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "hover:group-data-[collapsible=offcanvas]:bg-sidebar group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInset({ className, ...props }: React.ComponentProps<"main">) {
  return (
    <main
      data-slot="sidebar-inset"
      className={cn(
        "bg-background relative flex w-full flex-1 flex-col",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow-sm md:peer-data-[variant=inset]:peer-data-[state=collapsed]:ml-2",
        className
      )}
      {...props}
    />
  )
}

function SidebarInput({
  className,
  ...props
}: React.ComponentProps<typeof Input>) {
  return (
    <Input
      data-slot="sidebar-input"
      data-sidebar="input"
      className={cn("bg-background h-8 w-full shadow-none", className)}
      {...props}
    />
  )
}

function SidebarHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-header"
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-footer"
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
}

function SidebarSeparator({
  className,
  ...props
}: React.ComponentProps<typeof Separator>) {
  return (
    <Separator
      data-slot="sidebar-separator"
      data-sidebar="separator"
      className={cn("bg-sidebar-border mx-2 w-auto", className)}
      {...props}
    />
  )
}

function SidebarContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-content"
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group"
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
}

function SidebarGroupLabel({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"div"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      data-slot="sidebar-group-label"
      data-sidebar="group-label"
      className={cn(
        "text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupAction({
  className,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> & { asChild?: boolean }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-group-action"
      data-sidebar="group-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground absolute top-3.5 right-3 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarGroupContent({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-group-content"
      data-sidebar="group-content"
      className={cn("w-full text-sm", className)}
      {...props}
    />
  )
}

function SidebarMenu({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu"
      data-sidebar="menu"
      className={cn("flex w-full min-w-0 flex-col gap-1", className)}
      {...props}
    />
  )
}

function SidebarMenuItem({ className, ...props }: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-item"
      data-sidebar="menu-item"
      className={cn("group/menu-item relative", className)}
      {...props}
    />
  )
}

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function SidebarMenuButton({
  asChild = false,
  isActive = false,
  variant = "default",
  size = "default",
  tooltip,
  className,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  isActive?: boolean
  tooltip?: string | React.ComponentProps<typeof TooltipContent>
} & VariantProps<typeof sidebarMenuButtonVariants>) {
  const Comp = asChild ? Slot : "button"
  const { isMobile, state } = useSidebar()

  const button = (
    <Comp
      data-slot="sidebar-menu-button"
      data-sidebar="menu-button"
      data-size={size}
      data-active={isActive}
      className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
      {...props}
    />
  )

  if (!tooltip) {
    return button
  }

  if (typeof tooltip === "string") {
    tooltip = {
      children: tooltip,
    }
  }

  return (
    <Tooltip>
      <TooltipTrigger asChild>{button}</TooltipTrigger>
      <TooltipContent
        side="right"
        align="center"
        hidden={state !== "collapsed" || isMobile}
        {...tooltip}
      />
    </Tooltip>
  )
}

function SidebarMenuAction({
  className,
  asChild = false,
  showOnHover = false,
  ...props
}: React.ComponentProps<"button"> & {
  asChild?: boolean
  showOnHover?: boolean
}) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="sidebar-menu-action"
      data-sidebar="menu-action"
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground peer-hover/menu-button:text-sidebar-accent-foreground absolute top-1.5 right-1 flex aspect-square w-5 items-center justify-center rounded-md p-0 outline-hidden transition-transform focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 md:after:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "peer-data-[active=true]/menu-button:text-sidebar-accent-foreground group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 md:opacity-0",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuBadge({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sidebar-menu-badge"
      data-sidebar="menu-badge"
      className={cn(
        "text-sidebar-foreground pointer-events-none absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums select-none",
        "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSkeleton({
  className,
  showIcon = false,
  ...props
}: React.ComponentProps<"div"> & {
  showIcon?: boolean
}) {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      data-slot="sidebar-menu-skeleton"
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-(--skeleton-width) flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
}

function SidebarMenuSub({ className, ...props }: React.ComponentProps<"ul">) {
  return (
    <ul
      data-slot="sidebar-menu-sub"
      data-sidebar="menu-sub"
      className={cn(
        "border-sidebar-border mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l px-2.5 py-0.5",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

function SidebarMenuSubItem({
  className,
  ...props
}: React.ComponentProps<"li">) {
  return (
    <li
      data-slot="sidebar-menu-sub-item"
      data-sidebar="menu-sub-item"
      className={cn("group/menu-sub-item relative", className)}
      {...props}
    />
  )
}

function SidebarMenuSubButton({
  asChild = false,
  size = "md",
  isActive = false,
  className,
  ...props
}: React.ComponentProps<"a"> & {
  asChild?: boolean
  size?: "sm" | "md"
  isActive?: boolean
}) {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      data-slot="sidebar-menu-sub-button"
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "text-sidebar-foreground ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground active:bg-sidebar-accent active:text-sidebar-accent-foreground [&>svg]:text-sidebar-accent-foreground flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 outline-hidden focus-visible:ring-2 disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
}

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}
</file>

<file path="examples/hotvault-demo/client/src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/slider.tsx">
"use client"

import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

function Slider({
  className,
  defaultValue,
  value,
  min = 0,
  max = 100,
  ...props
}: React.ComponentProps<typeof SliderPrimitive.Root>) {
  const _values = React.useMemo(
    () =>
      Array.isArray(value)
        ? value
        : Array.isArray(defaultValue)
          ? defaultValue
          : [min, max],
    [value, defaultValue, min, max]
  )

  return (
    <SliderPrimitive.Root
      data-slot="slider"
      defaultValue={defaultValue}
      value={value}
      min={min}
      max={max}
      className={cn(
        "relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col",
        className
      )}
      {...props}
    >
      <SliderPrimitive.Track
        data-slot="slider-track"
        className={cn(
          "bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-1.5 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5"
        )}
      >
        <SliderPrimitive.Range
          data-slot="slider-range"
          className={cn(
            "bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full"
          )}
        />
      </SliderPrimitive.Track>
      {Array.from({ length: _values.length }, (_, index) => (
        <SliderPrimitive.Thumb
          data-slot="slider-thumb"
          key={index}
          className="border-primary bg-background ring-ring/50 block size-4 shrink-0 rounded-full border shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50"
        />
      ))}
    </SliderPrimitive.Root>
  )
}

export { Slider }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/sonner.tsx">
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/switch.tsx">
"use client"

import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/table.tsx">
"use client"

import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="examples/hotvault-demo/client/src/components/ui/tabs.tsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/toggle-group.tsx">
"use client"

import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

function ToggleGroup({
  className,
  variant,
  size,
  children,
  ...props
}: React.ComponentProps<typeof ToggleGroupPrimitive.Root> &
  VariantProps<typeof toggleVariants>) {
  return (
    <ToggleGroupPrimitive.Root
      data-slot="toggle-group"
      data-variant={variant}
      data-size={size}
      className={cn(
        "group/toggle-group flex w-fit items-center rounded-md data-[variant=outline]:shadow-xs",
        className
      )}
      {...props}
    >
      <ToggleGroupContext.Provider value={{ variant, size }}>
        {children}
      </ToggleGroupContext.Provider>
    </ToggleGroupPrimitive.Root>
  )
}

function ToggleGroupItem({
  className,
  children,
  variant,
  size,
  ...props
}: React.ComponentProps<typeof ToggleGroupPrimitive.Item> &
  VariantProps<typeof toggleVariants>) {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      data-slot="toggle-group-item"
      data-variant={context.variant || variant}
      data-size={context.size || size}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        "min-w-0 flex-1 shrink-0 rounded-none shadow-none first:rounded-l-md last:rounded-r-md focus:z-10 focus-visible:z-10 data-[variant=outline]:border-l-0 data-[variant=outline]:first:border-l",
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
}

export { ToggleGroup, ToggleGroupItem }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/toggle.tsx">
"use client"

import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium hover:bg-muted hover:text-muted-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:shrink-0 focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] outline-none transition-[color,box-shadow] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive whitespace-nowrap",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent shadow-xs hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-9 px-2 min-w-9",
        sm: "h-8 px-1.5 min-w-8",
        lg: "h-10 px-2.5 min-w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Toggle({
  className,
  variant,
  size,
  ...props
}: React.ComponentProps<typeof TogglePrimitive.Root> &
  VariantProps<typeof toggleVariants>) {
  return (
    <TogglePrimitive.Root
      data-slot="toggle"
      className={cn(toggleVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Toggle, toggleVariants }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/tooltip.tsx">
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="examples/hotvault-demo/client/src/components/ui/typography.tsx">
import { HTMLAttributes } from "react";
import { cn } from "@/lib/utils";

type TypographyVariant =
  | "h1"
  | "h2"
  | "h3"
  | "h4"
  | "body"
  | "small"
  | "blockquote"
  | "list"
  | "inlineCode"
  | "lead"
  | "large"
  | "muted";

type TypographyElement =
  | "h1"
  | "h2"
  | "h3"
  | "h4"
  | "p"
  | "blockquote"
  | "ul"
  | "code"
  | "div"
  | "small";

interface TypographyProps extends HTMLAttributes<HTMLElement> {
  variant: TypographyVariant;
  as?: TypographyElement;
  children: React.ReactNode;
}

const variantStyles: Record<TypographyVariant, string> = {
  h1: "text-lg font-light tracking-widest uppercase",
  h2: "text-4xl md:text-5xl font-light tracking-tight",
  h3: "text-base font-light uppercase tracking-widest",
  h4: "text-xs uppercase tracking-widest font-light",
  body: "font-light leading-relaxed",
  small: "text-sm font-light",
  blockquote: "mt-6 border-l-2 pl-6 italic [&>*]:text-muted-foreground",
  list: "my-6 ml-6 list-disc [&>li]:mt-2",
  inlineCode:
    "relative rounded bg-muted px-[0.3rem] py-[0.2rem] font-mono text-sm font-semibold",
  lead: "text-xl text-muted-foreground",
  large: "text-lg font-semibold",
  muted: "text-sm text-muted-foreground",
};

const defaultElements: Record<TypographyVariant, TypographyElement> = {
  h1: "h1",
  h2: "h2",
  h3: "h3",
  h4: "h4",
  body: "p",
  small: "p",
  blockquote: "blockquote",
  list: "ul",
  inlineCode: "code",
  lead: "p",
  large: "div",
  muted: "p",
};

export function Typography({
  variant = "body", // default variant
  as,
  children,
  className,
  ...props
}: TypographyProps) {
  const Component = as || defaultElements[variant];

  return (
    <Component className={cn(variantStyles[variant], className)} {...props}>
      {children}
    </Component>
  );
}
</file>

<file path="examples/hotvault-demo/client/src/components/ui/upload-progress.tsx">
"use client";

import { UploadProgress as UploadProgressType } from "@/store/upload-store";
import { AlertTriangle, ExternalLink, X } from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";
import { Button } from "./button";

interface UploadProgressProps {
  uploadProgress: UploadProgressType | null;
  onCancel: () => void;
  hasActiveAbortController: boolean; // Keeping this for API compatibility even if unused
}

export const UploadProgress = ({
  uploadProgress,
  onCancel,
}: UploadProgressProps) => {
  if (!uploadProgress) return null;

  // Common status color mapping
  const statusColors = {
    error: "text-red-500 bg-red-50 border-red-200",
    warning: "text-amber-500 bg-amber-50 border-amber-200",
    complete: "text-green-500 bg-green-50 border-green-200",
    uploading: "text-blue-500 bg-blue-50 border-blue-200",
    preparing: "text-indigo-500 bg-indigo-50 border-indigo-200",
    starting: "text-gray-500 bg-gray-50 border-gray-200",
    cancelled: "text-gray-500 bg-gray-50 border-gray-200",
    finalizing: "text-emerald-500 bg-emerald-50 border-emerald-200",
    adding_root: "text-purple-500 bg-purple-50 border-purple-200",
  };

  const statusColor =
    statusColors[uploadProgress.status as keyof typeof statusColors] ||
    statusColors.uploading;

  const getStatusText = () => {
    switch (uploadProgress.status) {
      case "starting":
        return "Starting upload...";
      case "preparing":
        return "Preparing file...";
      case "uploading":
        return "Uploading...";
      case "finalizing":
        return "Finalizing...";
      case "adding_root":
        return "Adding to proof set...";
      case "complete":
        return "Upload complete!";
      case "error":
        return "Upload failed";
      case "warning":
        return "Warning";
      case "cancelled":
        return "Upload cancelled";
      default:
        return uploadProgress.status;
    }
  };

  return (
    <AnimatePresence>
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        exit={{ opacity: 0, y: 20 }}
        className="fixed bottom-4 right-4 z-50 w-80 shadow-lg rounded-lg overflow-hidden"
      >
        <div className={`p-4 ${statusColor}`}>
          <div className="flex justify-between items-start">
            <div className="flex-1">
              <div className="flex items-center gap-2 font-medium">
                {uploadProgress.isStalled && (
                  <AlertTriangle className="h-4 w-4 text-amber-500" />
                )}
                <span>{getStatusText()}</span>
              </div>
              {uploadProgress.message && (
                <div className="text-sm mt-1 opacity-80 line-clamp-2">
                  {uploadProgress.message}
                </div>
              )}
              {uploadProgress.isStalled && (
                <div className="text-amber-600 text-sm mt-1">
                  No updates received for a while.
                </div>
              )}
              {uploadProgress.error && (
                <div className="text-red-500 text-sm mt-1 line-clamp-2">
                  Error: {uploadProgress.error}
                </div>
              )}
              {uploadProgress.filename && (
                <div className="text-xs text-gray-500 mt-1 truncate">
                  {uploadProgress.filename}
                </div>
              )}
              {uploadProgress.serviceProofSetId && (
                <div className="text-xs mt-2 flex items-center">
                  <span className="mr-2">Proof Set ID:</span>
                  <a
                    href={` http://explore-pdp.xyz:5173/proofsets/${uploadProgress.serviceProofSetId}`}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="text-blue-600 hover:text-blue-800 underline flex items-center"
                  >
                    {uploadProgress.serviceProofSetId}
                    <ExternalLink className="h-3 w-3 ml-1" />
                  </a>
                </div>
              )}
            </div>
            <div className="flex items-center gap-2">
              {uploadProgress.progress !== undefined && (
                <div className="text-sm font-medium">
                  {Math.min(uploadProgress.progress, 100)}%
                </div>
              )}
              {uploadProgress.status !== "complete" && (
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6"
                  onClick={onCancel}
                >
                  <X className="h-4 w-4" />
                </Button>
              )}
            </div>
          </div>

          {uploadProgress.progress !== undefined && (
            <div className="w-full bg-gray-200 rounded-full h-2.5 mt-3">
              <div
                className={`h-2.5 rounded-full ${
                  uploadProgress.status === "error"
                    ? "bg-red-500"
                    : uploadProgress.status === "complete"
                    ? "bg-green-500"
                    : uploadProgress.isStalled
                    ? "bg-amber-500"
                    : "bg-blue-500"
                }`}
                style={{ width: `${Math.min(uploadProgress.progress, 100)}%` }}
              ></div>
            </div>
          )}
        </div>
      </motion.div>
    </AnimatePresence>
  );
};
</file>

<file path="examples/hotvault-demo/client/src/components/ChunkedUploader.tsx">
import React, { useState, useCallback, useRef } from "react";
import { API_BASE_URL } from "@/lib/constants";
import { formatFileSize } from "@/lib/utils";
import { toast } from "sonner";
import { AlertTriangle, XCircle, CheckCircle, Upload } from "lucide-react";
import { Button } from "@/components/ui/button";

interface ChunkedUploaderProps {
  onUploadSuccess: (jobId: string) => void;
  maxFileSize?: number;
  chunkSize?: number;
  accept?: string;
  maxConcurrentChunks?: number;
}

interface ChunkStatus {
  index: number;
  state: "pending" | "uploading" | "complete" | "error";
  progress: number;
  error?: string;
  retries: number;
}

interface UploadSession {
  uploadId: string;
  filename: string;
  fileSize: number;
  fileType: string;
  totalChunks: number;
  chunkSize: number;
  chunks: ChunkStatus[];
  uploadedChunks: number;
  startTime: number;
  bytesUploaded: number;
  averageSpeed: number;
  status:
    | "initializing"
    | "uploading"
    | "paused"
    | "finalizing"
    | "complete"
    | "error";
  jobId?: string;
  errorMessage?: string;
}

function getOptimalChunkSize(fileSize: number): number {
  if (fileSize > 1024 * 1024 * 1024) {
    return 20 * 1024 * 1024;
  } else if (fileSize > 500 * 1024 * 1024) {
    return 10 * 1024 * 1024;
  } else if (fileSize > 100 * 1024 * 1024) {
    return 5 * 1024 * 1024;
  } else {
    return 2 * 1024 * 1024;
  }
}

const ChunkedUploader: React.FC<ChunkedUploaderProps> = ({
  onUploadSuccess,
  maxFileSize = 10 * 1024 * 1024 * 1024,
  chunkSize: propChunkSize,
  accept = "*",
  maxConcurrentChunks = 3,
}) => {
  const [file, setFile] = useState<File | null>(null);
  const [uploadSession, setUploadSession] = useState<UploadSession | null>(
    null
  );
  const [isDragActive, setIsDragActive] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const abortControllerRef = useRef<AbortController | null>(null);
  const uploadIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const activeUploadsRef = useRef<number>(0);
  const pendingChunksRef = useRef<number[]>([]);

  const resetUpload = () => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }

    if (uploadIntervalRef.current) {
      clearInterval(uploadIntervalRef.current);
      uploadIntervalRef.current = null;
    }

    setFile(null);
    setUploadSession(null);
    activeUploadsRef.current = 0;
    pendingChunksRef.current = [];
  };

  const handleFileSelect = (selectedFile: File) => {
    // if (selectedFile.size > maxFileSize) {
    //   toast.error(
    //     `File is too large. Maximum size is ${formatFileSize(
    //       maxFileSize
    //     )}. Selected file size: ${formatFileSize(selectedFile.size)}`
    //   );
    //   return;
    // }

    setFile(selectedFile);

    const optimalChunkSize =
      propChunkSize || getOptimalChunkSize(selectedFile.size);

    const totalChunks = Math.ceil(selectedFile.size / optimalChunkSize);
    const chunks: ChunkStatus[] = Array.from(
      { length: totalChunks },
      (_, index) => ({
        index,
        state: "pending",
        progress: 0,
        retries: 0,
      })
    );

    pendingChunksRef.current = Array.from({ length: totalChunks }, (_, i) => i);

    setUploadSession({
      uploadId: "",
      filename: selectedFile.name,
      fileSize: selectedFile.size,
      fileType: selectedFile.type,
      totalChunks,
      chunkSize: optimalChunkSize,
      chunks,
      uploadedChunks: 0,
      startTime: Date.now(),
      bytesUploaded: 0,
      averageSpeed: 0,
      status: "initializing",
    });

    initializeUpload(selectedFile, totalChunks, optimalChunkSize);
  };

  const initializeUpload = async (
    selectedFile: File,
    totalChunks: number,
    chunkSize: number
  ) => {
    const token = localStorage.getItem("jwt_token");
    if (!token) {
      toast.error("Authentication required. Please login again.");
      resetUpload();
      return;
    }

    try {
      console.log(
        `[ChunkedUploader] Initializing upload with ${totalChunks} chunks of ${formatFileSize(
          chunkSize
        )} each`
      );

      const response = await fetch(
        `${API_BASE_URL}/api/v1/chunked-upload/init`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify({
            filename: selectedFile.name,
            totalSize: selectedFile.size,
            chunkSize,
            totalChunks,
            fileType: selectedFile.type,
          }),
        }
      );

      if (!response.ok) {
        let errorMessage = "Failed to initialize upload";
        try {
          const errorData = await response.json();
          errorMessage = errorData.error || errorMessage;
        } catch {
          // If response is not JSON, use status text
          errorMessage = response.statusText || errorMessage;
        }

        setUploadSession((prev) =>
          prev ? { ...prev, status: "error", errorMessage } : null
        );
        toast.error(`Upload initialization failed: ${errorMessage}`);
        return;
      }

      const data = (await response.json()) as {
        uploadId: string;
        totalChunks: number;
      };
      console.log("[ChunkedUploader] Upload initialized:", data);

      setUploadSession((prev) =>
        prev
          ? {
              ...prev,
              uploadId: data.uploadId,
              status: "uploading",
            }
          : null
      );

      startChunkedUpload(selectedFile, data.uploadId);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error";
      setUploadSession((prev) =>
        prev ? { ...prev, status: "error", errorMessage } : null
      );
      toast.error(`Upload initialization failed: ${errorMessage}`);
    }
  };

  const startChunkedUpload = (selectedFile: File, uploadId: string) => {
    if (!uploadSession) return;

    abortControllerRef.current = new AbortController();

    uploadIntervalRef.current = setInterval(() => {
      setUploadSession((prev) => {
        if (!prev) return null;

        const elapsedTimeMs = Date.now() - prev.startTime;
        const elapsedTimeSec = elapsedTimeMs / 1000;
        const averageSpeed =
          elapsedTimeSec > 0 ? prev.bytesUploaded / elapsedTimeSec : 0;

        return {
          ...prev,
          averageSpeed,
        };
      });
    }, 1000);

    activeUploadsRef.current = 0;

    const processNextChunk = () => {
      if (!uploadSession) return;

      if (
        pendingChunksRef.current.length === 0 &&
        activeUploadsRef.current === 0
      ) {
        if (uploadIntervalRef.current) {
          clearInterval(uploadIntervalRef.current);
          uploadIntervalRef.current = null;
        }

        console.log("[ChunkedUploader] All chunks uploaded, finalizing");
        finalizeUpload(uploadId);
        return;
      }

      while (
        activeUploadsRef.current < maxConcurrentChunks &&
        pendingChunksRef.current.length > 0
      ) {
        const nextChunkIndex = pendingChunksRef.current.shift();
        if (nextChunkIndex !== undefined) {
          activeUploadsRef.current++;
          uploadChunk(selectedFile, uploadId, nextChunkIndex)
            .then(() => {
              activeUploadsRef.current--;
              processNextChunk();
            })
            .catch((error) => {
              console.error(
                `[ChunkedUploader] Chunk ${nextChunkIndex} upload failed:`,
                error
              );
              activeUploadsRef.current--;

              // Check if the chunk was marked for retry or error
              const chunkState = uploadSession.chunks[nextChunkIndex].state;
              if (chunkState === "pending") {
                // Re-add to pending queue if it's marked for retry
                pendingChunksRef.current.push(nextChunkIndex);
              }

              processNextChunk();
            });
        }
      }
    };

    processNextChunk();
  };

  const uploadChunk = async (
    selectedFile: File,
    uploadId: string,
    chunkIndex: number
  ): Promise<void> => {
    if (!uploadSession || abortControllerRef.current?.signal.aborted) {
      return Promise.reject("Upload aborted");
    }

    setUploadSession((prev) => {
      if (!prev) return null;

      const updatedChunks = [...prev.chunks];
      updatedChunks[chunkIndex] = {
        ...updatedChunks[chunkIndex],
        state: "uploading",
        progress: 0,
      };

      return {
        ...prev,
        chunks: updatedChunks,
      };
    });

    const token = localStorage.getItem("jwt_token");
    if (!token) {
      toast.error("Authentication required. Please login again.");
      resetUpload();
      return Promise.reject("Authentication required");
    }

    const start = chunkIndex * uploadSession.chunkSize;
    const end = Math.min(start + uploadSession.chunkSize, selectedFile.size);
    const chunk = selectedFile.slice(start, end);

    try {
      const formData = new FormData();
      formData.append("chunk", chunk);

      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();

        xhr.upload.onprogress = (event) => {
          if (event.lengthComputable) {
            const percentComplete = Math.round(
              (event.loaded / event.total) * 100
            );

            setUploadSession((prev) => {
              if (!prev) return null;

              const updatedChunks = [...prev.chunks];
              updatedChunks[chunkIndex] = {
                ...updatedChunks[chunkIndex],
                progress: percentComplete,
              };

              const chunkBytesUploaded =
                (event.loaded / event.total) * (end - start);
              const totalBytesCompleted = prev.bytesUploaded;
              const bytesFromCurrentChunk =
                prev.chunks[chunkIndex].state === "complete"
                  ? 0
                  : chunkBytesUploaded;

              return {
                ...prev,
                bytesUploaded: totalBytesCompleted + bytesFromCurrentChunk,
                chunks: updatedChunks,
              };
            });
          }
        };

        xhr.onload = function () {
          if (xhr.status >= 200 && xhr.status < 300) {
            try {
              const responseData = JSON.parse(xhr.responseText) as {
                uploadId: string;
                chunkIndex: number;
                uploadedChunks: number;
                totalChunks: number;
                allChunksReceived: boolean;
              };

              setUploadSession((prev) => {
                if (!prev) return null;

                const updatedChunks = [...prev.chunks];
                updatedChunks[chunkIndex] = {
                  ...updatedChunks[chunkIndex],
                  state: "complete",
                  progress: 100,
                };

                const chunkSize = end - start;

                return {
                  ...prev,
                  uploadedChunks: responseData.uploadedChunks,
                  bytesUploaded: prev.bytesUploaded + chunkSize,
                  chunks: updatedChunks,
                };
              });

              resolve();
            } catch (error) {
              console.error(
                "[ChunkedUploader] Error parsing chunk upload response:",
                error
              );
              reject(new Error("Invalid response from server"));
            }
          } else {
            setUploadSession((prev) => {
              if (!prev) return null;

              const updatedChunks = [...prev.chunks];
              const currentChunk = updatedChunks[chunkIndex];

              const newRetries = currentChunk.retries + 1;

              if (newRetries >= 3) {
                updatedChunks[chunkIndex] = {
                  ...currentChunk,
                  state: "error",
                  error: `Failed with status ${xhr.status}`,
                  retries: newRetries,
                };
              } else {
                updatedChunks[chunkIndex] = {
                  ...currentChunk,
                  state: "pending",
                  error: `Retrying (${newRetries}/3)...`,
                  retries: newRetries,
                };
              }

              return {
                ...prev,
                chunks: updatedChunks,
              };
            });

            let errorMessage = `Chunk ${chunkIndex} upload failed with status ${xhr.status}`;
            try {
              const errorData = JSON.parse(xhr.responseText);
              errorMessage = errorData.error || errorMessage;
            } catch {
              errorMessage = xhr.responseText || errorMessage;
            }

            reject(new Error(errorMessage));
          }
        };

        xhr.onerror = () => {
          setUploadSession((prev) => {
            if (!prev) return null;

            const updatedChunks = [...prev.chunks];
            const currentChunk = updatedChunks[chunkIndex];

            const newRetries = currentChunk.retries + 1;

            if (newRetries >= 3) {
              updatedChunks[chunkIndex] = {
                ...currentChunk,
                state: "error",
                error: "Network error",
                retries: newRetries,
              };
            } else {
              updatedChunks[chunkIndex] = {
                ...currentChunk,
                state: "pending",
                error: `Retrying (${newRetries}/3)...`,
                retries: newRetries,
              };
            }

            return {
              ...prev,
              chunks: updatedChunks,
            };
          });

          reject(new Error("Network error during chunk upload"));
        };

        xhr.onabort = () => {
          reject(new Error("Upload aborted"));
        };

        xhr.timeout = 120000;
        xhr.ontimeout = () => {
          setUploadSession((prev) => {
            if (!prev) return null;

            const updatedChunks = [...prev.chunks];
            const currentChunk = updatedChunks[chunkIndex];

            const newRetries = currentChunk.retries + 1;

            if (newRetries >= 3) {
              updatedChunks[chunkIndex] = {
                ...currentChunk,
                state: "error",
                error: "Timeout error",
                retries: newRetries,
              };
            } else {
              updatedChunks[chunkIndex] = {
                ...currentChunk,
                state: "pending",
                error: `Timeout - Retrying (${newRetries}/3)...`,
                retries: newRetries,
              };
            }

            return {
              ...prev,
              chunks: updatedChunks,
            };
          });

          reject(new Error("Chunk upload timed out"));
        };

        xhr.open(
          "POST",
          `${API_BASE_URL}/api/v1/chunked-upload/chunk?uploadId=${uploadId}&chunkIndex=${chunkIndex}`
        );
        xhr.setRequestHeader("Authorization", `Bearer ${token}`);
        xhr.send(formData);
      });
    } catch (error) {
      setUploadSession((prev) => {
        if (!prev) return null;

        const updatedChunks = [...prev.chunks];
        updatedChunks[chunkIndex] = {
          ...updatedChunks[chunkIndex],
          state: "error",
          error: error instanceof Error ? error.message : "Unknown error",
        };

        return {
          ...prev,
          chunks: updatedChunks,
        };
      });

      return Promise.reject(error);
    }
  };

  const finalizeUpload = async (uploadId: string) => {
    if (!uploadSession) return;

    try {
      setUploadSession((prev) =>
        prev ? { ...prev, status: "finalizing" } : null
      );

      const token = localStorage.getItem("jwt_token");
      if (!token) {
        toast.error("Authentication required. Please login again.");
        resetUpload();
        return;
      }

      console.log("[ChunkedUploader] Finalizing upload:", uploadId);

      const response = await fetch(
        `${API_BASE_URL}/api/v1/chunked-upload/complete`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify({
            uploadId,
          }),
        }
      );

      if (!response.ok) {
        let errorMessage = "Failed to finalize upload";
        try {
          const errorData = await response.json();
          errorMessage = errorData.error || errorMessage;
        } catch {
          errorMessage = response.statusText || errorMessage;
        }

        setUploadSession((prev) =>
          prev ? { ...prev, status: "error", errorMessage } : null
        );
        toast.error(`Upload finalization failed: ${errorMessage}`);
        return;
      }

      const data = (await response.json()) as { jobId: string; status: string };
      console.log("[ChunkedUploader] Upload finalized, job ID:", data.jobId);

      setUploadSession((prev) =>
        prev
          ? {
              ...prev,
              status: "complete",
              jobId: data.jobId,
            }
          : null
      );

      toast.success(
        "File uploaded successfully! Processing will continue in the background."
      );
      onUploadSuccess(data.jobId);
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error";
      setUploadSession((prev) =>
        prev ? { ...prev, status: "error", errorMessage } : null
      );
      toast.error(`Upload finalization failed: ${errorMessage}`);
    }
  };

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files;
    if (files && files.length > 0) {
      handleFileSelect(files[0]);
    }
  };

  const handleDrop = useCallback(
    (event: React.DragEvent<HTMLDivElement>) => {
      event.preventDefault();
      setIsDragActive(false);

      if (event.dataTransfer.files && event.dataTransfer.files.length > 0) {
        handleFileSelect(event.dataTransfer.files[0]);
      }
    },
    [setIsDragActive]
  );

  const handleDragOver = useCallback(
    (event: React.DragEvent<HTMLDivElement>) => {
      event.preventDefault();
      setIsDragActive(true);
    },
    []
  );

  const handleDragLeave = useCallback(
    (event: React.DragEvent<HTMLDivElement>) => {
      event.preventDefault();
      setIsDragActive(false);
    },
    []
  );

  const formatSpeed = (bytesPerSecond: number): string => {
    if (bytesPerSecond < 1024) {
      return `${bytesPerSecond.toFixed(1)} B/s`;
    } else if (bytesPerSecond < 1024 * 1024) {
      return `${(bytesPerSecond / 1024).toFixed(1)} KB/s`;
    } else {
      return `${(bytesPerSecond / (1024 * 1024)).toFixed(1)} MB/s`;
    }
  };

  const getEstimatedTimeRemaining = (): string => {
    if (!uploadSession || uploadSession.averageSpeed <= 0) {
      return "Calculating...";
    }

    const remainingBytes = uploadSession.fileSize - uploadSession.bytesUploaded;
    const remainingSeconds = remainingBytes / uploadSession.averageSpeed;

    if (remainingSeconds < 60) {
      return `${Math.ceil(remainingSeconds)} seconds`;
    } else if (remainingSeconds < 3600) {
      return `${Math.ceil(remainingSeconds / 60)} minutes`;
    } else {
      const hours = Math.floor(remainingSeconds / 3600);
      const minutes = Math.ceil((remainingSeconds % 3600) / 60);
      return `${hours} hour${hours > 1 ? "s" : ""} ${minutes} min`;
    }
  };

  const renderProgressBar = () => {
    if (!uploadSession) return null;

    const {
      status,
      uploadedChunks,
      totalChunks,
      bytesUploaded,
      fileSize,
      averageSpeed,
    } = uploadSession;

    const progressPercent = Math.round((bytesUploaded / fileSize) * 100);

    let statusText = "";
    let statusColor = "bg-blue-500";

    switch (status) {
      case "initializing":
        statusText = "Initializing upload...";
        break;
      case "uploading":
        statusText = `Uploading: ${uploadedChunks}/${totalChunks} chunks (${progressPercent}%)`;
        break;
      case "paused":
        statusText = "Upload paused";
        statusColor = "bg-amber-500";
        break;
      case "finalizing":
        statusText = "Finalizing upload...";
        break;
      case "complete":
        statusText = "Upload complete!";
        statusColor = "bg-green-500";
        break;
      case "error":
        statusText = `Error: ${uploadSession.errorMessage || "Unknown error"}`;
        statusColor = "bg-red-500";
        break;
    }

    return (
      <div className="w-full mt-4">
        <div className="flex justify-between mb-1 text-sm">
          <span>{statusText}</span>
          <span>
            {formatFileSize(bytesUploaded)} / {formatFileSize(fileSize)}
          </span>
        </div>

        <div className="w-full bg-gray-200 rounded-full h-2.5 mb-2">
          <div
            className={`h-2.5 rounded-full ${statusColor} transition-all duration-300`}
            style={{ width: `${progressPercent}%` }}
          ></div>
        </div>

        {status === "uploading" && (
          <div className="flex justify-between text-xs text-gray-500">
            <span>Speed: {formatSpeed(averageSpeed)}</span>
            <span>Time remaining: {getEstimatedTimeRemaining()}</span>
          </div>
        )}
      </div>
    );
  };

  return (
    <div className="w-full">
      <div
        className={`border-2 border-dashed rounded-lg p-6 flex flex-col items-center justify-center cursor-pointer transition-all duration-200 
          ${
            isDragActive
              ? "border-blue-500 bg-blue-50"
              : "border-gray-300 hover:border-blue-400 hover:bg-gray-50"
          }
          ${uploadSession ? "bg-gray-50" : ""}`}
        onDrop={handleDrop}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onClick={() => fileInputRef.current?.click()}
      >
        <input
          type="file"
          className="hidden"
          ref={fileInputRef}
          onChange={handleFileChange}
          accept={accept}
        />

        {!file && !uploadSession ? (
          <>
            <Upload className="h-12 w-12 text-gray-400 mb-3" />
            <h3 className="text-lg font-medium mb-1">Upload Large Files</h3>
            <p className="text-sm text-gray-500 text-center mb-2">
              Drag and drop files here or click to browse
            </p>
            <p className="text-xs text-gray-400">
              Supports files up to {formatFileSize(maxFileSize)} with chunked
              uploading
            </p>
          </>
        ) : (
          <div className="w-full">
            <div className="flex items-center mb-2">
              {uploadSession?.status === "error" ? (
                <AlertTriangle className="h-6 w-6 text-red-500 mr-2" />
              ) : uploadSession?.status === "complete" ? (
                <CheckCircle className="h-6 w-6 text-green-500 mr-2" />
              ) : (
                <div className="h-6 w-6 border-2 border-t-blue-500 border-r-transparent border-b-transparent border-l-transparent rounded-full animate-spin mr-2"></div>
              )}
              <h3 className="text-lg font-medium flex-1 truncate">
                {file?.name || "Unknown file"}
              </h3>
              {uploadSession?.status !== "complete" && (
                <Button
                  size="sm"
                  variant="outline"
                  className="ml-2"
                  onClick={(e) => {
                    e.stopPropagation();
                    resetUpload();
                  }}
                >
                  <XCircle className="h-4 w-4 mr-1" />
                  Cancel
                </Button>
              )}
            </div>

            <div className="text-sm text-gray-600 mb-2">
              {formatFileSize(file?.size || 0)}
            </div>

            {renderProgressBar()}
          </div>
        )}
      </div>

      {uploadSession && uploadSession.status === "uploading" && (
        <div className="mt-4">
          <h4 className="text-sm font-medium mb-2">Chunk Status</h4>
          <div className="grid grid-cols-10 gap-1">
            {uploadSession.chunks.map((chunk) => (
              <div
                key={chunk.index}
                className={`h-2 rounded-sm ${
                  chunk.state === "complete"
                    ? "bg-green-500"
                    : chunk.state === "uploading"
                    ? "bg-blue-500"
                    : chunk.state === "error"
                    ? "bg-red-500"
                    : "bg-gray-200"
                }`}
                title={`Chunk ${chunk.index + 1}: ${chunk.state}${
                  chunk.error ? ` (${chunk.error})` : ""
                }`}
              ></div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};

export default ChunkedUploader;
</file>

<file path="examples/hotvault-demo/client/src/components/icons.tsx">
import React from "react";

export const TokenIcon: React.FC = () => (
  <svg
    className="w-4 h-4"
    fill="none"
    viewBox="0 0 24 24"
    stroke="currentColor"
  >
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
    />
  </svg>
);

export const RailIcon: React.FC = () => (
  <svg
    className="w-4 h-4"
    fill="none"
    viewBox="0 0 24 24"
    stroke="currentColor"
  >
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M13 10V3L4 14h7v7l9-11h-7z"
    />
  </svg>
);

export const ActivityIcon: React.FC = () => (
  <svg
    className="w-4 h-4"
    fill="none"
    viewBox="0 0 24 24"
    stroke="currentColor"
  >
    <path
      strokeLinecap="round"
      strokeLinejoin="round"
      strokeWidth={2}
      d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"
    />
  </svg>
);
</file>

<file path="examples/hotvault-demo/client/src/contexts/AuthContext.tsx">
import {
  createContext,
  useContext,
  useEffect,
  useState,
  useCallback,
} from "react";
import { useRouter } from "next/navigation";
import { API_BASE_URL } from "@/lib/constants";
import type { EthereumProvider } from "@/types/window";
import { toast } from "react-hot-toast";

declare global {
  interface Window {
    ethereum?: EthereumProvider;
  }
}

export type AuthContextType = {
  account: string | null;
  isConnected: boolean;
  isConnecting: boolean;
  isLoading: boolean;
  error: string;
  proofSetReady: boolean;
  proofSetId: string | null;
  userProofSetId: string | null;
  connectWallet: () => Promise<void>;
  disconnectWallet: () => void;
  updateUserProofSetId: (id: string) => void;
  handleAccountSwitch: () => Promise<void>;
};

const AuthContext = createContext<AuthContextType | undefined>(undefined);

const STORAGE_KEY = "fws_wallet_connected";
const JWT_STORAGE_KEY = "jwt_token";

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [account, setAccount] = useState<string>("");
  const [isConnecting, setIsConnecting] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string>("");
  const [proofSetReady, setProofSetReady] = useState<boolean>(false);
  const [userProofSetId, setUserProofSetId] = useState<string | null>(null);
  const router = useRouter();

  const [isConnectionLocked, setIsConnectionLocked] = useState(false);

  const authenticateWithBackend = useCallback(async (address: string) => {
    try {
      console.log("üîê Authenticating with backend for address:", address);

      const nonceResponse = await fetch(`${API_BASE_URL}/api/v1/auth/nonce`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ address }),
        credentials: "include",
      });

      if (!nonceResponse.ok) {
        throw new Error(`Failed to get nonce: ${nonceResponse.statusText}`);
      }

      const { nonce } = await nonceResponse.json();
      console.log("üìù Received nonce from backend:", nonce);

      if (!window.ethereum) {
        throw new Error("MetaMask not available");
      }

      console.log("üñäÔ∏è Requesting signature...");

      const message = `Sign this message to login to Hot Vault (No funds will be transferred in this step): ${nonce}`;
      console.log("Message to sign:", message);

      const signature = await window.ethereum.request({
        method: "personal_sign",
        params: [message, address],
      });

      console.log("‚úçÔ∏è Signature:", signature);

      const verifyResponse = await fetch(`${API_BASE_URL}/api/v1/auth/verify`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          address,
          signature,
          message,
        }),
        credentials: "include",
      });

      if (!verifyResponse.ok) {
        throw new Error(
          `Failed to verify signature: ${verifyResponse.statusText}`
        );
      }

      const { token } = await verifyResponse.json();

      if (token) {
        localStorage.setItem(JWT_STORAGE_KEY, token);
        console.log("üîë JWT token stored");
      } else {
        console.log("‚ö†Ô∏è No JWT token received, but cookie should be set");
      }

      localStorage.setItem(STORAGE_KEY, "true");

      try {
        const statusResponse = await fetch(
          `${API_BASE_URL}/api/v1/auth/status`,
          {
            method: "GET",
            credentials: "include",
          }
        );
        if (statusResponse.ok) {
          const data = await statusResponse.json();
          setProofSetReady(data.proofSetReady);
          if (data.proofSetId) {
            console.log("üîí Setting proof set ID:", data.proofSetId);
            setUserProofSetId(data.proofSetId);
          }
          console.log(
            "üîí Updated proofSetReady status after auth:",
            data.proofSetReady
          );
        } else {
          console.warn(
            "‚ö†Ô∏è Could not fetch status after authentication to update proofSetReady"
          );
          setProofSetReady(false); // Assume not ready if status check fails
        }
      } catch (statusError) {
        console.error(
          "üö® Error fetching status after authentication:",
          statusError
        );
        setProofSetReady(false);
      }

      return token;
    } catch (error) {
      console.error("‚ùå Authentication error:", error);
      throw error;
    }
  }, []);

  const handleAccountsChanged = useCallback(
    async (newAccounts: string[]) => {
      console.log(
        "[AuthContext.tsx:handleAccountsChanged] üëõ Account change detected:",
        newAccounts
      );
      const newAccount = newAccounts[0] || "";

      if (!newAccount) {
        console.log(
          "[AuthContext.tsx:handleAccountsChanged] üîì No account found, clearing storage and redirecting to home"
        );
        localStorage.removeItem(STORAGE_KEY);
        localStorage.removeItem(JWT_STORAGE_KEY);
        await fetch(`${API_BASE_URL}/api/v1/auth/logout`, {
          method: "POST",
          credentials: "include",
        });
        setError("");
        setAccount("");
        router.push("/");
        return;
      }

      try {
        const statusResponse = await fetch(
          `${API_BASE_URL}/api/v1/auth/status`,
          {
            method: "GET",
            credentials: "include",
          }
        );

        if (statusResponse.ok) {
          const data = await statusResponse.json();

          if (
            data.authenticated &&
            data.address.toLowerCase() === newAccount.toLowerCase()
          ) {
            console.log("‚úÖ Already authenticated with this account");
            setProofSetReady(data.proofSetReady);
            setAccount(newAccount);
            localStorage.setItem(STORAGE_KEY, "true");
            setIsLoading(false);
            router.push("/dashboard");
            return;
          }
        }
      } catch (error) {
        console.error("Error checking auth status:", error);
        // Continue with authentication process
      }

      try {
        console.log(
          "[AuthContext.tsx:handleAccountsChanged] üîí New account connected, starting authentication"
        );
        await authenticateWithBackend(newAccount);
        setAccount(newAccount);
        localStorage.setItem(STORAGE_KEY, "true");
        console.log(
          "[AuthContext.tsx:handleAccountsChanged] ‚úÖ Authentication successful, redirecting to dashboard"
        );
        router.push("/dashboard");
      } catch (error) {
        console.error(
          "[AuthContext.tsx:handleAccountsChanged] ‚ùå Authentication failed:",
          error
        );
        setError("Failed to authenticate with the backend");
        setAccount("");
        localStorage.removeItem(STORAGE_KEY);
        localStorage.removeItem(JWT_STORAGE_KEY);
        await fetch(`${API_BASE_URL}/api/v1/auth/logout`, {
          method: "POST",
          credentials: "include",
        });
      }
    },
    [authenticateWithBackend, router]
  );

  const handleDisconnect = useCallback(() => {
    console.log("üîå Wallet disconnected");
    setAccount("");
    setProofSetReady(false);
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(JWT_STORAGE_KEY);
    fetch(`${API_BASE_URL}/api/v1/auth/logout`, {
      method: "POST",
      credentials: "include",
    }).catch((err) => console.error("Error logging out:", err));
    setError("");
    router.push("/");
  }, [router]);

  const checkConnection = useCallback(async () => {
    console.log("‚è≥ Checking connection status...");
    if (account === "") {
      setIsLoading(true);
    }

    try {
      const response = await fetch(`${API_BASE_URL}/api/v1/auth/status`, {
        method: "GET",
        credentials: "include",
      });

      if (response.ok) {
        const data = await response.json();
        setAccount(data.address);
        localStorage.setItem(STORAGE_KEY, "true");
        setProofSetReady(data.proofSetReady);
        if (data.proofSetId) {
          console.log("‚úÖ Setting proof set ID:", data.proofSetId);
          setUserProofSetId(data.proofSetId);
        }
        console.log(
          "‚úÖ Authenticated via cookie session for address:",
          data.address,
          "Proof Set Ready:",
          data.proofSetReady,
          "Proof Set ID:",
          data.proofSetId
        );
        setIsLoading(false);
        return true;
      }

      console.log("Cookie authentication failed, checking alternatives...");

      // If cookie auth failed but we have MetaMask, check if accounts exist
      if (window.ethereum) {
        const accounts = (await window.ethereum.request({
          method: "eth_accounts",
        })) as string[];

        if (accounts && accounts.length > 0) {
          const currentAddress = accounts[0];
          console.log("üì± Found existing MetaMask account:", currentAddress);

          // Check if we have marked this account as connected in localStorage
          const isStoredConnected =
            localStorage.getItem(STORAGE_KEY) === "true";

          if (isStoredConnected) {
            console.log("üîÑ Attempting to re-authenticate with the backend");
            try {
              await authenticateWithBackend(currentAddress);
              setAccount(currentAddress);
              console.log("‚úÖ Re-authenticated successfully");
              setIsLoading(false);
              return true;
            } catch (error) {
              console.error("‚ùå Re-authentication failed:", error);
              // If re-authentication fails, continue with the flow
            }
          }
        }
      }

      // If we get here, we're not authenticated
      console.log("‚ùå No valid authentication found");
      setAccount("");
      localStorage.removeItem(STORAGE_KEY);
      localStorage.removeItem(JWT_STORAGE_KEY);
    } catch (error) {
      console.error("üö® Error checking connection:", error);
      setAccount("");
      localStorage.removeItem(STORAGE_KEY);
      localStorage.removeItem(JWT_STORAGE_KEY);
    }

    setIsLoading(false);
    return false;
  }, [authenticateWithBackend, account]);

  useEffect(() => {
    const initialCheck = async () => {
      await checkConnection();
    };

    initialCheck();

    if (window.ethereum) {
      const accountsChangedHandler = (accounts: string[]) => {
        if (!isConnectionLocked) {
          handleAccountsChanged(accounts);
        }
      };

      const disconnectHandler = () => {
        handleDisconnect();
      };

      window.ethereum.on("accountsChanged", accountsChangedHandler);
      window.ethereum.on("disconnect", disconnectHandler);

      return () => {
        if (window.ethereum) {
          window.ethereum.removeListener(
            "accountsChanged",
            accountsChangedHandler
          );
          window.ethereum.removeListener("disconnect", disconnectHandler);
        }
      };
    }
  }, [
    isConnectionLocked,
    checkConnection,
    handleAccountsChanged,
    handleDisconnect,
  ]);

  const connectWallet = async () => {
    if (isConnectionLocked) {
      console.log("üîí Connection locked, please wait...");
      toast.error("Please complete the pending wallet connection request.");
      return;
    }

    setIsConnectionLocked(true);
    setIsConnecting(true);
    setError("");

    if (!window.ethereum) {
      setError("MetaMask not found! Please install MetaMask to use this app.");
      setIsConnecting(false);
      setIsConnectionLocked(false);
      return;
    }

    const isMetaMask = window.ethereum.isMetaMask;
    if (!isMetaMask) {
      setError("Please use MetaMask as your wallet provider.");
      setIsConnecting(false);
      setIsConnectionLocked(false);
      return;
    }

    const providers = window.ethereum.providers;
    if (providers && providers.length > 1) {
      const metaMaskProvider = providers.find(
        (p: EthereumProvider) => p.isMetaMask
      );
      if (!metaMaskProvider) {
        setError("Please use MetaMask as your wallet provider.");
        setIsConnecting(false);
        setIsConnectionLocked(false);
        return;
      }
      window.ethereum = metaMaskProvider;
    }

    try {
      console.log("ü¶ä Requesting MetaMask accounts...");
      const accounts = (await window.ethereum.request({
        method: "eth_requestAccounts",
      })) as string[];

      if (accounts.length === 0) {
        throw new Error("No accounts returned from MetaMask");
      }

      try {
        const statusResponse = await fetch(
          `${API_BASE_URL}/api/v1/auth/status`,
          {
            method: "GET",
            credentials: "include",
          }
        );

        if (statusResponse.ok) {
          const data = await statusResponse.json();

          if (
            data.authenticated &&
            data.address.toLowerCase() === accounts[0].toLowerCase()
          ) {
            setProofSetReady(data.proofSetReady);
            setAccount(accounts[0]);
            localStorage.setItem(STORAGE_KEY, "true");
            setIsLoading(false);
            router.push("/dashboard");
            return;
          }
        }
      } catch (error) {
        console.error("Error checking status:", error);
      }

      await authenticateWithBackend(accounts[0]);
      setAccount(accounts[0]);
      localStorage.setItem(STORAGE_KEY, "true");
      router.push("/dashboard");
    } catch (error: unknown) {
      console.error("‚ùå Connection error:", error);

      // Handle specific MetaMask errors
      if (error && typeof error === "object" && "code" in error) {
        const metamaskError = error as { code: number };
        if (metamaskError.code === -32002) {
          toast.error(
            "MetaMask is already processing a connection request. Please check your MetaMask popup."
          );
          setError(
            "Please check your MetaMask popup to complete the connection."
          );
        } else if (metamaskError.code === 4001) {
          toast.error("You rejected the connection request.");
          setError("Connection request was rejected. Please try again.");
        } else {
          toast.error("Failed to connect wallet. Please try again.");
          setError("Failed to connect wallet. Please try again.");
        }
      } else {
        toast.error("Failed to connect wallet. Please try again.");
        setError("Failed to connect wallet. Please try again.");
      }

      localStorage.removeItem(STORAGE_KEY);
      localStorage.removeItem(JWT_STORAGE_KEY);
    } finally {
      setIsConnecting(false);
      setTimeout(() => {
        setIsConnectionLocked(false);
      }, 1000);
    }
  };

  const disconnectWallet = async () => {
    console.log("üîå Disconnecting wallet");
    setAccount("");
    setProofSetReady(false);
    setUserProofSetId(null);
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(JWT_STORAGE_KEY);
    try {
      await fetch(`${API_BASE_URL}/api/v1/auth/logout`, {
        method: "POST",
        credentials: "include",
      });
    } catch (err) {
      console.error("Error logging out:", err);
    }
    setError("");
    router.push("/");
  };

  const handleAccountSwitch = async () => {
    if (!window.ethereum) {
      toast.error(
        "MetaMask not found! Please install MetaMask to use this app."
      );
      return;
    }

    try {
      await window.ethereum.request({
        method: "wallet_requestPermissions",
        params: [{ eth_accounts: {} }],
      });

      console.log("üîÑ Account switch requested");
    } catch (error) {
      console.error("Error switching account:", error);
      toast.error("Failed to switch account. Please try again.");
    }
  };

  return (
    <AuthContext.Provider
      value={{
        account: account || null,
        isConnected: !!account,
        isConnecting,
        isLoading,
        error,
        proofSetReady,
        proofSetId: userProofSetId,
        userProofSetId,
        connectWallet,
        disconnectWallet,
        updateUserProofSetId: setUserProofSetId,
        handleAccountSwitch,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
}
</file>

<file path="examples/hotvault-demo/client/src/contexts/PaymentContext.tsx">
import {
  createContext,
  useContext,
  useState,
  useEffect,
  useCallback,
  ReactNode,
} from "react";
import { ethers } from "ethers";
import { useAuth } from "./AuthContext";
import {
  getUSDFCBalance,
  approveUSDFCSpending,
  depositUSDFC,
  approveOperator,
  getAccountStatus,
  getOperatorApproval,
  withdrawUSDFC,
} from "@/lib/contracts";
import * as Constants from "@/lib/constants";

export const BALANCE_UPDATED_EVENT = "BALANCE_UPDATED";

export interface TransactionRecord {
  id: string;
  type: "token_approval" | "deposit" | "operator_approval" | "withdraw";
  txHash: string;
  amount?: string;
  timestamp: number;
  status: "pending" | "success" | "failed";
  error?: string;
}

export type PaymentStatus = {
  isTokenApproved: boolean;
  isDeposited: boolean;
  isOperatorApproved: boolean;
  isCreatingProofSet: boolean;
  proofSetReady: boolean;
  proofSetId: string | null;
  hasMinimumBalance: boolean;
  usdcBalance: string;
  accountFunds: string;
  error: string | null;
  isLoading: boolean;
  lastApprovalTimestamp: number;
  operatorApproval: {
    rateAllowance: string;
    lockupAllowance: string;
  } | null;
  lockedFunds: {
    current: string;
  };
};

interface PaymentContextType {
  paymentStatus: PaymentStatus;
  refreshBalance: () => Promise<void>;
  refreshPaymentSetupStatus: () => Promise<void>;
  approveToken: (amount: string) => Promise<boolean>;
  depositFunds: (amount: string) => Promise<boolean>;
  withdrawFunds: (amount: string) => Promise<boolean>;
  approveServiceOperator: (
    rateAllowance: string,
    lockupAllowance: string
  ) => Promise<boolean>;
  initiateProofSetCreation: () => Promise<boolean>;
  transactions: TransactionRecord[];
  clearTransactionHistory: () => void;
}

const PaymentContext = createContext<PaymentContextType | undefined>(undefined);

const generateId = () =>
  `tx_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

const initialState: PaymentStatus = {
  isTokenApproved: false,
  isDeposited: false,
  isOperatorApproved: false,
  isCreatingProofSet: false,
  proofSetReady: false,
  proofSetId: null,
  hasMinimumBalance: false,
  usdcBalance: "0",
  accountFunds: "0",
  error: null,
  isLoading: false,
  lastApprovalTimestamp: 0,
  operatorApproval: null,
  lockedFunds: {
    current: "0",
  },
};

export const PaymentProvider: React.FC<{ children: ReactNode }> = ({
  children,
}) => {
  const { account } = useAuth();
  const [paymentStatus, setPaymentStatus] =
    useState<PaymentStatus>(initialState);
  const [transactions, setTransactions] = useState<TransactionRecord[]>([]);
  const [pollingInterval, setPollingInterval] = useState<NodeJS.Timeout | null>(
    null
  );

  const addTransaction = (transaction: Omit<TransactionRecord, "id">) => {
    const newTransaction = {
      ...transaction,
      id: generateId(),
    };
    setTransactions((prev) => [newTransaction, ...prev]);
    return newTransaction.id;
  };

  const updateTransaction = (
    id: string,
    updates: Partial<TransactionRecord>
  ) => {
    setTransactions((prev) =>
      prev.map((tx) => (tx.id === id ? { ...tx, ...updates } : tx))
    );
  };

  const clearTransactionHistory = () => {
    setTransactions([]);
  };

  const refreshBalance = useCallback(async () => {
    if (!account) {
      setPaymentStatus((prev) => ({
        ...prev,
        usdcBalance: "0",
        hasMinimumBalance: false,
        error: null,
        isLoading: false,
      }));
      return;
    }

    setPaymentStatus((prev) => ({ ...prev, isLoading: true, error: null }));

    try {
      if (!window.ethereum) {
        throw new Error("Ethereum provider not found");
      }

      const provider = new ethers.BrowserProvider(
        window.ethereum as ethers.Eip1193Provider
      );

      const balanceResult = await getUSDFCBalance(
        provider,
        Constants.USDFC_TOKEN_ADDRESS,
        account
      );

      setPaymentStatus((prev) => ({
        ...prev,
        usdcBalance: balanceResult.formattedBalance,
        hasMinimumBalance: balanceResult.hasMinimumBalance,
        isLoading: false,
      }));
    } catch (error) {
      console.error("Error checking USDFC balance:", error);
      setPaymentStatus((prev) => ({
        ...prev,
        error: "Failed to check USDFC balance",
        isLoading: false,
      }));
    }
  }, [account]);

  const startPolling = useCallback(() => {
    if (pollingInterval) {
      clearInterval(pollingInterval);
    }

    const interval = setInterval(async () => {
      try {
        const response = await fetch(
          `${Constants.API_BASE_URL}/api/v1/auth/status`,
          {
            method: "GET",
            credentials: "include",
          }
        );

        if (response.ok) {
          const data = await response.json();

          setPaymentStatus((prev) => ({
            ...prev,
            proofSetReady: data.proofSetReady,
            isCreatingProofSet: data.proofSetInitiated && !data.proofSetReady,
          }));

          if (data.proofSetReady) {
            clearInterval(interval);
            setPollingInterval(null);
            refreshPaymentSetupStatus();
          }
        }
      } catch (error) {
        console.error("Error polling for proof set status:", error);
      }
    }, 30000);

    setPollingInterval(interval);

    return () => {
      clearInterval(interval);
      setPollingInterval(null);
    };
  }, []);

  useEffect(() => {
    return () => {
      if (pollingInterval) {
        clearInterval(pollingInterval);
      }
    };
  }, [pollingInterval]);

  const refreshPaymentSetupStatus = useCallback(async () => {
    if (!account) return;

    setPaymentStatus((prev) => ({ ...prev, isLoading: true, error: null }));

    try {
      if (!window.ethereum) {
        throw new Error("Ethereum provider not found");
      }

      const provider = new ethers.BrowserProvider(
        window.ethereum as ethers.Eip1193Provider
      );

      let fetchedProofSetReady = false;
      let fetchedProofSetInitiated = false;
      let fetchedProofSetId = null;
      try {
        const statusResponse = await fetch(
          `${Constants.API_BASE_URL}/api/v1/auth/status`,
          {
            method: "GET",
            credentials: "include",
          }
        );
        if (statusResponse.ok) {
          const statusData = await statusResponse.json();
          fetchedProofSetReady = statusData.proofSetReady;
          fetchedProofSetInitiated = statusData.proofSetInitiated;
          fetchedProofSetId = statusData.proofSetId;

          if (
            fetchedProofSetInitiated &&
            !fetchedProofSetReady &&
            !pollingInterval
          ) {
            startPolling();
          }
        }
      } catch (authStatusError) {
        console.error(
          "Error fetching auth status for proofSetReady:",
          authStatusError
        );
      }

      try {
        const accountStatus = await getAccountStatus(
          provider,
          Constants.PAYMENT_PROXY_ADDRESS,
          Constants.USDFC_TOKEN_ADDRESS,
          account
        );

        const operatorStatus = await getOperatorApproval(
          provider,
          Constants.PAYMENT_PROXY_ADDRESS,
          Constants.USDFC_TOKEN_ADDRESS,
          account,
          Constants.PDP_SERVICE_ADDRESS
        );

        const minDepositAmount = parseFloat(Constants.PROOF_SET_FEE);
        const isDeposited = parseFloat(accountStatus.funds) >= minDepositAmount;

        setPaymentStatus((prev) => ({
          ...prev,
          isDeposited,
          isOperatorApproved: operatorStatus.isApproved,
          accountFunds: accountStatus.funds,
          lockedFunds: {
            ...prev.lockedFunds,
            current: accountStatus.lockupCurrent,
            rate: accountStatus.lockupRate,
            lastSettledAt: accountStatus.lockupLastSettledAt,
          },
          proofSetReady: fetchedProofSetReady,
          proofSetId: fetchedProofSetId,
          isCreatingProofSet: fetchedProofSetInitiated && !fetchedProofSetReady,
          isLoading: false,
          hasMinimumBalance: prev.hasMinimumBalance,
        }));

        console.log(`Payment setup status for ${account}:`, {
          isDeposited,
          funds: accountStatus.funds,
          lockedFunds: {
            current: accountStatus.lockupCurrent,
            rate: accountStatus.lockupRate,
            lastSettledAt: accountStatus.lockupLastSettledAt,
          },
          isOperatorApproved: operatorStatus.isApproved,
        });

        // Notify any listening components of the updated balance
        window.dispatchEvent(
          new CustomEvent(BALANCE_UPDATED_EVENT, {
            detail: {
              newBalance: accountStatus.funds,
              newLockedFunds: accountStatus.lockupCurrent,
            },
          })
        );
      } catch (error) {
        console.error("Error fetching account status:", error);
        console.log("User hasn't interacted with the Payments contract yet");
        setPaymentStatus((prev) => ({
          ...prev,
          isDeposited: false,
          isOperatorApproved: false,
          accountFunds: "0",
          lockedFunds: {
            current: "0",
            rate: "0",
            lastSettledAt: "0",
          },
          proofSetReady: fetchedProofSetReady,
          proofSetId: fetchedProofSetId,
          isCreatingProofSet: fetchedProofSetInitiated && !fetchedProofSetReady,
        }));
      }

      const tokenContract = new ethers.Contract(
        Constants.USDFC_TOKEN_ADDRESS,
        [
          "function allowance(address owner, address spender) view returns (uint256)",
        ],
        provider
      );

      const tokenAllowance = await tokenContract.allowance(
        account,
        Constants.PAYMENT_PROXY_ADDRESS
      );

      const minimumAllowance = ethers.parseUnits(Constants.PROOF_SET_FEE, 6);
      const isTokenApproved = tokenAllowance >= minimumAllowance;

      setPaymentStatus((prev) => ({
        ...prev,
        isTokenApproved,
      }));

      const paymentContract = new ethers.Contract(
        Constants.PAYMENT_PROXY_ADDRESS,
        [
          "function operatorApprovals(address token, address client, address operator) view returns (bool isApproved, uint256 rateAllowance, uint256 lockupAllowance, uint256 rateUsage, uint256 lockupUsage)",
        ],
        provider
      );

      try {
        const approval = await paymentContract.operatorApprovals(
          Constants.USDFC_TOKEN_ADDRESS,
          account,
          Constants.PDP_SERVICE_ADDRESS
        );

        setPaymentStatus((prev) => ({
          ...prev,
          operatorApproval: {
            rateAllowance: ethers.formatUnits(approval.rateAllowance, 18),
            lockupAllowance: ethers.formatUnits(approval.lockupAllowance, 18),
            rateUsage: ethers.formatUnits(approval.rateUsage, 18),
            lockupUsage: ethers.formatUnits(approval.lockupUsage, 18),
          },
        }));
      } catch (error) {
        console.error("Error fetching operator approval details:", error);
      }
    } catch (error) {
      console.error("Error checking payment setup status:", error);
      setPaymentStatus((prev) => ({
        ...prev,
        error: "Failed to check payment setup status",
        isLoading: false,
        proofSetReady: false,
        proofSetId: null,
        isCreatingProofSet: false,
        operatorApproval: null,
      }));
    }
  }, [account, startPolling, pollingInterval]);

  const refreshAfterTransaction = async () => {
    try {
      await refreshBalance();
      await refreshPaymentSetupStatus();

      setTimeout(async () => {
        await refreshBalance();
        await refreshPaymentSetupStatus();

        setTimeout(async () => {
          await refreshBalance();
          await refreshPaymentSetupStatus();

          setTimeout(async () => {
            await refreshBalance();
            await refreshPaymentSetupStatus();
          }, 1500);
        }, 1000);
      }, 500);
    } catch (error) {
      console.error("Error during refresh sequence:", error);
    }
  };

  const approveToken = async (amount: string): Promise<boolean> => {
    if (!account) return false;

    setPaymentStatus((prev) => ({ ...prev, isLoading: true, error: null }));

    const txId = addTransaction({
      type: "token_approval",
      txHash: "",
      amount,
      timestamp: Date.now(),
      status: "pending",
    });

    try {
      if (!window.ethereum) {
        throw new Error("Ethereum provider not found");
      }

      const provider = new ethers.BrowserProvider(
        window.ethereum as ethers.Eip1193Provider
      );
      const signer = await provider.getSigner();

      const txResponse = await approveUSDFCSpending(
        signer,
        Constants.USDFC_TOKEN_ADDRESS,
        Constants.PAYMENT_PROXY_ADDRESS,
        amount
      );

      updateTransaction(txId, {
        txHash: txResponse.hash,
        status: "success",
      });

      const now = Date.now();

      // Update state to indicate we're waiting for blockchain confirmation
      setPaymentStatus((prev) => ({
        ...prev,
        isLoading: true,
        error: "Waiting for blockchain confirmation...",
      }));

      // Wait 5 seconds for blockchain to sync before showing success
      await new Promise((resolve) => setTimeout(resolve, 5000));

      setPaymentStatus((prev) => ({
        ...prev,
        isTokenApproved: true,
        isLoading: false,
        error: null,
        lastApprovalTimestamp: now,
      }));

      return true;
    } catch (error) {
      console.error("Error approving token spending:", error);

      updateTransaction(txId, {
        status: "failed",
        error: error instanceof Error ? error.message : "Unknown error",
      });

      setPaymentStatus((prev) => ({
        ...prev,
        error: "Failed to approve token spending",
        isLoading: false,
      }));
      return false;
    }
  };

  const updateBalanceAndNotify = (updates: {
    newBalance: string;
    newLockedFunds?: string;
  }) => {
    setPaymentStatus((prev) => ({
      ...prev,
      accountFunds: updates.newBalance,
      lockedFunds: {
        ...prev.lockedFunds,
        current: updates.newLockedFunds || prev.lockedFunds.current,
      },
      isLoading: false,
      error: null,
    }));

    // Dispatch event to notify all components
    window.dispatchEvent(
      new CustomEvent(BALANCE_UPDATED_EVENT, {
        detail: {
          newBalance: updates.newBalance,
          newLockedFunds: updates.newLockedFunds,
        },
      })
    );
  };

  const depositFunds = async (amount: string): Promise<boolean> => {
    if (!account) return false;

    const now = Date.now();
    const lastApproval = paymentStatus.lastApprovalTimestamp;
    const minDelay = 5000;
    const timeSinceApproval = now - lastApproval;

    if (lastApproval > 0 && timeSinceApproval < minDelay) {
      console.warn(
        `Deposit attempted too soon after approval (${timeSinceApproval}ms). Waiting for confirmation...`
      );

      const remainingTime = minDelay - timeSinceApproval;

      setPaymentStatus((prev) => ({
        ...prev,
        isLoading: true,
        error: `Waiting ${Math.ceil(
          remainingTime / 1000
        )} seconds for approval confirmation...`,
      }));

      await new Promise((resolve) => setTimeout(resolve, remainingTime + 500));

      setPaymentStatus((prev) => ({ ...prev, error: null }));
    }

    setPaymentStatus((prev) => ({ ...prev, isLoading: true, error: null }));

    const txId = addTransaction({
      type: "deposit",
      txHash: "",
      amount,
      timestamp: Date.now(),
      status: "pending",
    });

    try {
      if (!window.ethereum) {
        throw new Error("Ethereum provider not found");
      }

      const provider = new ethers.BrowserProvider(
        window.ethereum as ethers.Eip1193Provider
      );
      const signer = await provider.getSigner();

      const txResponse = await depositUSDFC(
        signer,
        Constants.PAYMENT_PROXY_ADDRESS,
        Constants.USDFC_TOKEN_ADDRESS,
        amount
      );

      updateTransaction(txId, {
        txHash: txResponse.hash,
        status: "success",
      });

      // Update state to indicate we're waiting for blockchain confirmation
      setPaymentStatus((prev) => ({
        ...prev,
        isLoading: true,
        error: "Waiting for blockchain confirmation...",
      }));

      // Immediately update UI with anticipated new values
      const newBalance = (
        parseFloat(paymentStatus.accountFunds) + parseFloat(amount)
      ).toString();

      // Also update wallet balance
      const newWalletBalance = Math.max(
        0,
        parseFloat(paymentStatus.usdcBalance) - parseFloat(amount)
      ).toFixed(6);

      setPaymentStatus((prev) => ({
        ...prev,
        accountFunds: newBalance,
        usdcBalance: newWalletBalance,
        isDeposited:
          parseFloat(newBalance) >= parseFloat(Constants.PROOF_SET_FEE),
        isLoading: true,
      }));

      // Notify all components about the balance update
      window.dispatchEvent(
        new CustomEvent(BALANCE_UPDATED_EVENT, {
          detail: {
            newBalance,
            newWalletBalance,
          },
        })
      );

      // Wait a bit for the transaction to propagate
      await new Promise((resolve) => setTimeout(resolve, 1000));

      // Start aggressive refresh sequence
      refreshAfterTransaction();

      setPaymentStatus((prev) => ({ ...prev, isLoading: false }));
      return true;
    } catch (error) {
      console.error("Error depositing funds:", error);

      updateTransaction(txId, {
        status: "failed",
        error: error instanceof Error ? error.message : "Unknown error",
      });

      setPaymentStatus((prev) => ({
        ...prev,
        error: "Failed to deposit funds",
        isLoading: false,
      }));
      return false;
    }
  };

  const withdrawFunds = async (amount: string): Promise<boolean> => {
    if (!account) return false;

    setPaymentStatus((prev) => ({ ...prev, isLoading: true, error: null }));

    try {
      if (!window.ethereum) {
        throw new Error("Ethereum provider not found");
      }

      const provider = new ethers.BrowserProvider(
        window.ethereum as ethers.Eip1193Provider
      );

      const txId = addTransaction({
        type: "withdraw",
        txHash: "",
        amount,
        timestamp: Date.now(),
        status: "pending",
      });

      const signer = await provider.getSigner();

      const txResponse = await withdrawUSDFC(
        signer,
        Constants.PAYMENT_PROXY_ADDRESS,
        Constants.USDFC_TOKEN_ADDRESS,
        amount
      );

      updateTransaction(txId, {
        txHash: txResponse.hash,
        status: "success",
      });

      // Update state to indicate we're waiting for blockchain confirmation
      setPaymentStatus((prev) => ({
        ...prev,
        isLoading: true,
        error: "Waiting for blockchain confirmation..",
      }));

      // Wait 5 seconds for blockchain to sync before showing success
      await new Promise((resolve) => setTimeout(resolve, 5000));

      // Update balance immediately
      const newBalance = (
        parseFloat(paymentStatus.accountFunds) - parseFloat(amount)
      ).toString();
      const newLockedFunds = paymentStatus.lockedFunds.current; // Locked funds remain unchanged on withdrawal
      updateBalanceAndNotify({
        newBalance,
        newLockedFunds,
      });

      // Refresh in background
      await Promise.all([refreshBalance(), refreshPaymentSetupStatus()]);

      return true;
    } catch (error) {
      console.error("Error withdrawing funds:", error);

      if (error instanceof Error) {
        setPaymentStatus((prev) => ({
          ...prev,
          error: error.message,
          isLoading: false,
        }));
      } else {
        setPaymentStatus((prev) => ({
          ...prev,
          error: "Failed to withdraw funds",
          isLoading: false,
        }));
      }
      return false;
    }
  };

  const approveServiceOperator = async (
    rateAllowance: string,
    lockupAllowance: string
  ): Promise<boolean> => {
    if (!account) return false;

    setPaymentStatus((prev) => ({ ...prev, isLoading: true, error: null }));

    const txId = addTransaction({
      type: "operator_approval",
      txHash: "",
      amount: `Rate: ${rateAllowance}, Lockup: ${lockupAllowance}`,
      timestamp: Date.now(),
      status: "pending",
    });

    try {
      if (!window.ethereum) {
        throw new Error("Ethereum provider not found");
      }

      const provider = new ethers.BrowserProvider(
        window.ethereum as ethers.Eip1193Provider
      );
      const signer = await provider.getSigner();

      const txResponse = await approveOperator(
        signer,
        Constants.PAYMENT_PROXY_ADDRESS,
        Constants.USDFC_TOKEN_ADDRESS,
        Constants.PDP_SERVICE_ADDRESS,
        rateAllowance,
        lockupAllowance
      );

      updateTransaction(txId, {
        txHash: txResponse.hash,
        status: "success",
      });

      // Update state to indicate we're waiting for blockchain confirmation
      setPaymentStatus((prev) => ({
        ...prev,
        isLoading: true,
        error: "Waiting for blockchain confirmation...",
      }));

      // Wait 5 seconds for blockchain to sync before showing success
      await new Promise((resolve) => setTimeout(resolve, 5000));

      setPaymentStatus((prev) => ({
        ...prev,
        isOperatorApproved: true,
        isLoading: false,
        error: null,
      }));

      return true;
    } catch (error) {
      console.error("Error approving service operator:", error);

      updateTransaction(txId, {
        status: "failed",
        error: error instanceof Error ? error.message : "Unknown error",
      });

      setPaymentStatus((prev) => ({
        ...prev,
        error: "Failed to approve service operator",
        isLoading: false,
      }));
      return false;
    }
  };

  const initiateProofSetCreation = async (): Promise<boolean> => {
    if (!account) return false;

    try {
      // Check if the account has sufficient funds for creating a proof set
      if (
        parseFloat(paymentStatus.accountFunds) <
        parseFloat(Constants.PROOF_SET_FEE)
      ) {
        throw new Error(
          `Insufficient funds in FWS. You need at least ${Constants.PROOF_SET_FEE} USDFC in your FWS funds.`
        );
      }

      setPaymentStatus((prev) => ({
        ...prev,
        isCreatingProofSet: true,
        error: null,
      }));

      const response = await fetch(
        `${Constants.API_BASE_URL}/api/v1/proof-set/create`,
        {
          method: "POST",
          credentials: "include",
        }
      );

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to create proof set");
      }

      startPolling();

      setPaymentStatus((prev) => ({
        ...prev,
        isCreatingProofSet: true,
        isLoading: false,
      }));

      return true;
    } catch (error) {
      console.error("Failed to create proof set:", error);
      setPaymentStatus((prev) => ({
        ...prev,
        isCreatingProofSet: false,
        isLoading: false,
        error:
          error instanceof Error
            ? error.message
            : "Failed to create proof set. Please try again.",
      }));
      return false;
    }
  };

  useEffect(() => {
    refreshBalance();
    refreshPaymentSetupStatus();
  }, [account, refreshBalance, refreshPaymentSetupStatus]);

  // Add visibility change handler to refresh data when tab becomes visible
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.visibilityState === "visible" && account) {
        console.log(
          "[PaymentContext] Tab became visible, refreshing payment status and balance"
        );

        // Create a sequence of refreshes to ensure data is up-to-date
        Promise.all([refreshBalance(), refreshPaymentSetupStatus()])
          .then(() => {
            console.log(
              "[PaymentContext] Initial refresh after visibility change completed"
            );

            // Dispatch event to notify components
            window.dispatchEvent(
              new CustomEvent(BALANCE_UPDATED_EVENT, {
                detail: {
                  timestamp: Date.now(),
                  action: "visibility_change",
                },
              })
            );

            // Do a follow-up refresh after a short delay
            setTimeout(() => {
              Promise.all([refreshBalance(), refreshPaymentSetupStatus()])
                .then(() => {
                  console.log("[PaymentContext] Follow-up refresh completed");

                  // Dispatch another event
                  window.dispatchEvent(
                    new CustomEvent(BALANCE_UPDATED_EVENT, {
                      detail: {
                        timestamp: Date.now(),
                        action: "visibility_change_followup",
                      },
                    })
                  );
                })
                .catch((error) => {
                  console.error(
                    "[PaymentContext] Error in follow-up refresh:",
                    error
                  );
                });
            }, 1500);
          })
          .catch((error) => {
            console.error(
              "[PaymentContext] Error refreshing on visibility change:",
              error
            );
          });
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);

    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, [account, refreshBalance, refreshPaymentSetupStatus]);

  return (
    <PaymentContext.Provider
      value={{
        paymentStatus,
        refreshBalance,
        refreshPaymentSetupStatus,
        approveToken,
        depositFunds,
        withdrawFunds,
        approveServiceOperator,
        initiateProofSetCreation,
        transactions,
        clearTransactionHistory,
      }}
    >
      {children}
    </PaymentContext.Provider>
  );
};

export function usePayment() {
  const context = useContext(PaymentContext);
  if (context === undefined) {
    throw new Error("usePayment must be used within a PaymentProvider");
  }
  return context;
}
</file>

<file path="examples/hotvault-demo/client/src/hooks/use-mobile.ts">
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}
</file>

<file path="examples/hotvault-demo/client/src/hooks/useBlockNumber.ts">
import { useState, useEffect } from "react";
import { BrowserProvider } from "ethers";
import { useAuth } from "@/contexts/AuthContext";

export const useBlockNumber = () => {
  const { account } = useAuth();
  const [currentBlockNumber, setCurrentBlockNumber] = useState<number | null>(
    null
  );
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    if (!window.ethereum || !account) {
      setIsLoading(false);
      return;
    }

    const getBlockNumber = async () => {
      try {
        if (window.ethereum) {
          const provider = new BrowserProvider(window.ethereum);
          const blockNumber = await provider.getBlockNumber();
          setCurrentBlockNumber(blockNumber);
        }
      } catch (error) {
        console.error("Error getting current block number:", error);
      } finally {
        setIsLoading(false);
      }
    };

    getBlockNumber();

    const intervalId = setInterval(getBlockNumber, 15000);
    return () => {
      clearInterval(intervalId);
    };
  }, [account]);

  return { currentBlockNumber, isLoading };
};
</file>

<file path="examples/hotvault-demo/client/src/hooks/useUpload.ts">
import { useCallback, useRef } from "react";
import { useUploadStore } from "@/store/upload-store";
import { API_BASE_URL } from "@/lib/constants";

export const useUpload = (onSuccess?: () => void) => {
  const { setUploadProgress, clearUploadProgress } = useUploadStore();
  const abortControllerRef = useRef<AbortController | null>(null);
  const pollIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const uploadStartTimeRef = useRef<number | null>(null);

  const handleCancelUpload = useCallback(() => {
    const currentAbortController = abortControllerRef.current;
    const currentPollInterval = pollIntervalRef.current;

    if (currentAbortController) {
      currentAbortController.abort();
      abortControllerRef.current = null;
    }

    if (currentPollInterval) {
      clearInterval(currentPollInterval);
      pollIntervalRef.current = null;
    }

    uploadStartTimeRef.current = null;

    setUploadProgress({
      status: "cancelled",
      message: "Upload cancelled by user",
      error: "Upload cancelled",
      progress: 0,
    });

    setTimeout(() => {
      clearUploadProgress();
    }, 2000);
  }, [setUploadProgress, clearUploadProgress]);

  const uploadFile = useCallback(
    async (file: File) => {
      const formData = new FormData();
      formData.append("file", file);

      try {
        const token = localStorage.getItem("jwt_token");
        if (!token) {
          throw new Error("Authentication required");
        }

        if (abortControllerRef.current) {
          abortControllerRef.current.abort();
        }
        abortControllerRef.current = new AbortController();
        const signal = abortControllerRef.current.signal;

        uploadStartTimeRef.current = Date.now();

        setUploadProgress({
          status: "starting",
          progress: 0,
          message: "Initiating upload...",
          lastUpdated: Date.now(),
          isStalled: false,
          filename: file.name,
        });

        const response = await fetch(`${API_BASE_URL}/api/v1/upload`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${token}`,
          },
          body: formData,
          signal,
        });

        if (!response.ok) {
          const errorText = await response.text();
          let errorMessage = `Upload failed (${response.status})`;
          try {
            const errorData = JSON.parse(errorText);
            errorMessage = errorData.error || errorData.message || errorMessage;
          } catch {
            console.error("[useUpload] Raw error response:", errorText);
          }
          throw new Error(errorMessage);
        }

        const data = await response.json();
        console.log("[useUpload] Upload initiated:", data);

        if (data.jobId) {
          setUploadProgress((prev) => ({
            ...prev,
            ...data,
            lastUpdated: Date.now(),
            isStalled: false,
          }));

          setTimeout(() => {
            pollStatus(data.jobId, token);
          }, 1000);

          return data;
        } else {
          throw new Error("No job ID received from server");
        }
      } catch (error) {
        abortControllerRef.current = null;
        uploadStartTimeRef.current = null;

        if (error instanceof DOMException && error.name === "AbortError") {
          console.log("[useUpload] Upload was cancelled by user");
          return;
        }

        console.error("[useUpload] Error in uploadFile:", error);
        setUploadProgress({
          status: "error",
          error: error instanceof Error ? error.message : "Upload failed",
          lastUpdated: Date.now(),
        });

        throw error;
      }
    },
    [setUploadProgress, clearUploadProgress, onSuccess, handleCancelUpload]
  );

  const pollStatus = useCallback(
    async (jobId: string, token: string) => {
      try {
        const response = await fetch(
          `${API_BASE_URL}/api/v1/upload/status/${jobId}`,
          {
            headers: {
              Authorization: `Bearer ${token}`,
            },
          }
        );

        if (!response.ok) {
          throw new Error("Failed to get upload status");
        }

        const data = await response.json();
        console.log("[useUpload] Got status update:", data);

        if (
          (data.status === "complete" || data.status === "success") &&
          data.progress === 100
        ) {
          console.log(
            "[useUpload] Upload complete with 100% progress. Immediately cleaning up."
          );

          if (pollIntervalRef.current) {
            clearInterval(pollIntervalRef.current);
            pollIntervalRef.current = null;
          }

          onSuccess?.();

          setTimeout(() => {
            clearUploadProgress();
          }, 100);

          return;
        }

        setUploadProgress((prev) => ({
          ...prev,
          ...data,
          lastUpdated: Date.now(),
          isStalled: false,
        }));

        if (data.status === "complete" || data.status === "error") {
          if (pollIntervalRef.current) {
            clearInterval(pollIntervalRef.current);
            pollIntervalRef.current = null;
          }

          if (data.status === "complete") {
            onSuccess?.();
          }
        } else {
          if (!pollIntervalRef.current) {
            pollIntervalRef.current = setInterval(() => {
              pollStatus(jobId, token);
            }, 2000);
          }
        }
      } catch (error) {
        console.error("[useUpload] Error polling for status:", error);
      }
    },
    [setUploadProgress, clearUploadProgress, onSuccess]
  );

  return {
    uploadFile,
    handleCancelUpload,
    hasActiveUpload: !!abortControllerRef.current,
  };
};
</file>

<file path="examples/hotvault-demo/client/src/lib/constants.ts">
export const API_BASE_URL =
  process.env.NEXT_PUBLIC_API_BASE_URL || "http://localhost:8008";

export const USDFC_TOKEN_ADDRESS =
  process.env.NEXT_PUBLIC_USDFC_TOKEN_ADDRESS ||
  "0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0";
export const PAYMENT_PROXY_ADDRESS =
  process.env.NEXT_PUBLIC_PAYMENT_PROXY_ADDRESS ||
  "0x0E690D3e60B0576D01352AB03b258115eb84A047";
export const PDP_SERVICE_ADDRESS =
  process.env.NEXT_PUBLIC_PDP_SERVICE_ADDRESS ||
  "0xdbE4bEF3F313dAC36257b0621e4a3BC8Dc9679a1";

export const MINIMUM_USDFC_BALANCE = "10";
export const PROOF_SET_FEE = "0.1";
export const STORAGE_RATE_PER_GB = 2; // 2 USDFC per GB per month
export const LOCK_PERIOD_DAYS = 10; // 10 days lock period

export const statusColors = {
  uploading: "bg-blue-100 text-blue-800",
  processing: "bg-blue-100 text-blue-800",
  complete: "bg-green-100 text-green-800",
  error: "bg-red-100 text-red-800",
  cancelled: "bg-gray-100 text-gray-800",
} as const;

export const getStatusText = (status: string): string => {
  const statusMap: Record<string, string> = {
    uploading: "Uploading...",
    processing: "Processing...",
    complete: "Upload Complete",
    error: "Upload Failed",
    cancelled: "Upload Cancelled",
  };
  return statusMap[status] || status;
};
</file>

<file path="examples/hotvault-demo/client/src/lib/contracts.ts">
import { ethers } from "ethers";

const ERC20_ABI = [
  // Read-only functions
  "function balanceOf(address owner) view returns (uint256)",
  "function decimals() view returns (uint8)",
  "function symbol() view returns (string)",
  // Write functions
  "function approve(address spender, uint256 value) returns (bool)",
  // Events
  "event Transfer(address indexed from, address indexed to, uint256 value)",
  "event Approval(address indexed owner, address indexed spender, uint256 value)",
];

/**
 * Gets the balance of USDFC tokens for a specific address
 * @param provider - Ethereum provider
 * @param tokenAddress - USDFC token address
 * @param walletAddress - Wallet address to check balance for
 * @returns Balance as a formatted string with 6 decimals
 */
export async function getUSDFCBalance(
  provider: ethers.Provider,
  tokenAddress: string,
  walletAddress: string
): Promise<{
  rawBalance: bigint;
  formattedBalance: string;
  hasMinimumBalance: boolean;
}> {
  try {
    const tokenContract = new ethers.Contract(
      tokenAddress,
      ERC20_ABI,
      provider
    );

    const decimals = await tokenContract.decimals();

    const rawBalance = await tokenContract.balanceOf(walletAddress);

    const formattedBalance = ethers.formatUnits(rawBalance, decimals);

    const minimumBalance = ethers.parseUnits("10", decimals);
    const hasMinimumBalance = rawBalance >= minimumBalance;

    console.log(
      `getUSDFCBalance check: rawBalance=${rawBalance.toString()}, decimals=${decimals}, minimumBalance=${minimumBalance.toString()}, hasMinimumBalance=${hasMinimumBalance}`
    );

    return {
      rawBalance,
      formattedBalance,
      hasMinimumBalance,
    };
  } catch (error) {
    console.error("Error getting USDFC balance:", error);
    throw error;
  }
}

/**
 * Approves the Payment contract to spend USDFC tokens
 * @param signer - Connected wallet signer
 * @param tokenAddress - USDFC token address
 * @param spenderAddress - Payment contract address
 * @param amount - Amount to approve (in USDFC)
 * @returns Transaction response
 */
export async function approveUSDFCSpending(
  signer: ethers.Signer,
  tokenAddress: string,
  spenderAddress: string,
  amount: string
) {
  try {
    const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
    const decimals = await tokenContract.decimals();

    const amountInWei = ethers.parseUnits(amount, decimals);

    const tx = await tokenContract.approve(spenderAddress, amountInWei);
    const receipt = await tx.wait();

    return {
      hash: tx.hash,
      receipt,
    };
  } catch (error) {
    console.error("Error approving USDFC spending:", error);
    throw error;
  }
}

const PAYMENTS_ABI = [
  "function accounts(address token, address owner) view returns (uint256 funds, uint256 lockupCurrent, uint256 lockupRate, uint256 lockupLastSettledAt)",
  "function operatorApprovals(address token, address client, address operator) view returns (bool isApproved, uint256 rateAllowance, uint256 lockupAllowance, uint256 rateUsage, uint256 lockupUsage)",
  // Write functions
  "function deposit(address token, address to, uint256 amount)",
  "function setOperatorApproval(address token, address operator, bool approved, uint256 rateAllowance, uint256 lockupAllowance)",
];

/**
 * Deposits USDFC tokens into the Payments contract
 * @param signer - Connected wallet signer
 * @param paymentsAddress - Payments contract address
 * @param tokenAddress - USDFC token address
 * @param amount - Amount to deposit (in USDFC)
 * @returns Transaction response
 */
export async function depositUSDFC(
  signer: ethers.Signer,
  paymentsAddress: string,
  tokenAddress: string,
  amount: string
) {
  try {
    const paymentsContract = new ethers.Contract(
      paymentsAddress,
      PAYMENTS_ABI,
      signer
    );

    const signerAddress = await signer.getAddress();

    const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
    const decimals = await tokenContract.decimals();

    const amountInWei = ethers.parseUnits(amount, decimals);

    const tx = await paymentsContract.deposit(
      tokenAddress,
      signerAddress,
      amountInWei
    );

    const receipt = await tx.wait();

    return {
      hash: tx.hash,
      receipt,
    };
  } catch (error) {
    console.error("Error depositing USDFC:", error);
    throw error;
  }
}

/**
 * Approve the PDP Service as an operator in the Payments contract
 * @param signer - Connected wallet signer
 * @param paymentsAddress - Payments contract address
 * @param tokenAddress - USDFC token address
 * @param operatorAddress - PDP Service operator address
 * @param rateAllowance - Maximum rate allowance (in USDFC)
 * @param lockupAllowance - Maximum lockup allowance (in USDFC)
 * @returns Transaction response
 */
export async function approveOperator(
  signer: ethers.Signer,
  paymentsAddress: string,
  tokenAddress: string,
  operatorAddress: string,
  rateAllowance: string,
  lockupAllowance: string
) {
  try {
    const paymentsContract = new ethers.Contract(
      paymentsAddress,
      PAYMENTS_ABI,
      signer
    );

    const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
    const decimals = await tokenContract.decimals();

    const rateInWei = ethers.parseUnits(rateAllowance, decimals);
    const lockupInWei = ethers.parseUnits(lockupAllowance, decimals);

    const tx = await paymentsContract.setOperatorApproval(
      tokenAddress,
      operatorAddress,
      true, // approved
      rateInWei,
      lockupInWei
    );

    const receipt = await tx.wait();

    return {
      hash: tx.hash,
      receipt,
    };
  } catch (error) {
    console.error("Error approving operator:", error);
    throw error;
  }
}

/**
 * Gets the account status from the Payments contract
 * @param provider - Ethereum provider
 * @param paymentsAddress - Payments contract address
 * @param tokenAddress - USDFC token address
 * @param walletAddress - Wallet address to check
 * @returns Account status with fund values
 */
export async function getAccountStatus(
  provider: ethers.Provider,
  paymentsAddress: string,
  tokenAddress: string,
  walletAddress: string
) {
  try {
    const paymentsContract = new ethers.Contract(
      paymentsAddress,
      PAYMENTS_ABI,
      provider
    );

    const tokenContract = new ethers.Contract(
      tokenAddress,
      ERC20_ABI,
      provider
    );
    const decimals = await tokenContract.decimals();

    console.log("decimals", decimals);

    const account = await paymentsContract.accounts(
      tokenAddress,
      walletAddress
    );

    return {
      funds: ethers.formatUnits(account.funds, decimals),
      lockupCurrent: ethers.formatUnits(account.lockupCurrent, decimals),
      lockupRate: ethers.formatUnits(account.lockupRate, decimals),
      lockupLastSettledAt: account.lockupLastSettledAt.toString(),
    };
  } catch (error) {
    console.error("Error getting account status:", error);
    throw error;
  }
}

/**
 * Gets the operator approval status from the Payments contract
 * @param provider - Ethereum provider
 * @param paymentsAddress - Payments contract address
 * @param tokenAddress - USDFC token address
 * @param walletAddress - Wallet address (client)
 * @param operatorAddress - Operator address to check
 * @returns Operator approval status
 */
export async function getOperatorApproval(
  provider: ethers.Provider,
  paymentsAddress: string,
  tokenAddress: string,
  walletAddress: string,
  operatorAddress: string
) {
  try {
    const paymentsContract = new ethers.Contract(
      paymentsAddress,
      PAYMENTS_ABI,
      provider
    );

    const tokenContract = new ethers.Contract(
      tokenAddress,
      ERC20_ABI,
      provider
    );
    const decimals = await tokenContract.decimals();

    const approval = await paymentsContract.operatorApprovals(
      tokenAddress,
      walletAddress,
      operatorAddress
    );

    return {
      isApproved: approval.isApproved,
      rateAllowance: ethers.formatUnits(approval.rateAllowance, decimals),
      lockupAllowance: ethers.formatUnits(approval.lockupAllowance, decimals),
      rateUsage: ethers.formatUnits(approval.rateUsage, decimals),
      lockupUsage: ethers.formatUnits(approval.lockupUsage, decimals),
    };
  } catch (error) {
    console.error("Error getting operator approval:", error);
    throw error;
  }
}

/**
 * Withdraws tokens from the Payments contract to the caller's address
 * @param signer - Connected wallet signer
 * @param paymentsAddress - Payments contract address
 * @param tokenAddress - USDFC token address
 * @param amount - Amount to withdraw (in USDFC)
 * @returns Transaction response
 */
export async function withdrawUSDFC(
  signer: ethers.Signer,
  paymentsAddress: string,
  tokenAddress: string,
  amount: string
) {
  try {
    const paymentsContract = new ethers.Contract(
      paymentsAddress,
      [...PAYMENTS_ABI, "function withdraw(address token, uint256 amount)"],
      signer
    );

    const tokenContract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
    const decimals = await tokenContract.decimals();

    const amountInWei = ethers.parseUnits(amount, decimals);

    const tx = await paymentsContract.withdraw(tokenAddress, amountInWei);

    const receipt = await tx.wait();

    return {
      hash: tx.hash,
      receipt,
    };
  } catch (error) {
    console.error("Error withdrawing USDFC:", error);
    throw error;
  }
}
</file>

<file path="examples/hotvault-demo/client/src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export const formatFileSize = (bytes: number) => {
  if (bytes === 0) return "0 Bytes";
  const k = 1024;
  const sizes = ["Bytes", "KB", "MB", "GB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
};

export const getFilePreviewType = (
  filename: string
):
  | "image"
  | "document"
  | "spreadsheet"
  | "code"
  | "archive"
  | "video"
  | "audio"
  | "generic" => {
  const extension = filename.split(".").pop()?.toLowerCase() || "";

  if (["jpg", "jpeg", "png", "gif", "bmp", "svg", "webp"].includes(extension)) {
    return "image";
  }

  if (["pdf", "doc", "docx", "txt", "rtf", "odt"].includes(extension)) {
    return "document";
  }

  if (["xls", "xlsx", "csv", "ods"].includes(extension)) {
    return "spreadsheet";
  }

  if (
    [
      "js",
      "ts",
      "jsx",
      "tsx",
      "html",
      "css",
      "java",
      "py",
      "c",
      "cpp",
      "rb",
      "php",
      "go",
      "swift",
      "kotlin",
      "scala",
      "rust",
      "haskell",
      "erlang",
      "elixir",
      "dart",
      "typescript",
      "javascript",
      "ruby",
      "python",
      "csharp",
    ].includes(extension)
  ) {
    return "code";
  }

  if (["zip", "rar", "tar", "gz", "7z"].includes(extension)) {
    return "archive";
  }

  if (["mp4", "mov", "avi", "mkv", "wmv", "flv", "webm"].includes(extension)) {
    return "video";
  }

  if (["mp3", "wav", "ogg", "flac", "aac", "m4a"].includes(extension)) {
    return "audio";
  }

  return "generic";
};

/**
 * Gets the appropriate block explorer URL for a transaction hash based on the current network
 * @param txHash - Transaction hash
 * @returns Full URL to the transaction on the block explorer
 */
export function getExplorerUrl(txHash: string): string {
  const network = process.env.NEXT_PUBLIC_NETWORK || "calibration";

  switch (network.toLowerCase()) {
    case "mainnet":
      return `https://filfox.info/en/message/${txHash}`;
    case "calibration":
    default:
      return `https://calibration.filfox.info/en/message/${txHash}`;
  }
}

/**
 * Formats a currency amount with configurable decimal places
 * @param amount - Amount as a string or number
 * @param decimals - Number of decimal places (default: 2)
 * @param trimZeros - Whether to trim trailing zeros (default: true)
 * @returns Formatted string
 */
export const formatCurrency = (
  amount: string | number,
  decimals: number = 2,
  trimZeros: boolean = true
): string => {
  const numAmount = typeof amount === "string" ? parseFloat(amount) : amount;

  if (
    Math.abs(numAmount) >= 1e15 ||
    (Math.abs(numAmount) > 0 && Math.abs(numAmount) < 0.001)
  ) {
    return numAmount.toExponential(4);
  }

  const formatted = numAmount.toFixed(decimals);

  return trimZeros ? formatted.replace(/\.?0+$/, "") : formatted;
};

/**
 * Formats a currency amount showing full precision with no rounding
 * @param amount - Amount as a string or number
 * @param maxDecimals - Maximum number of decimal places to display (default: 18)
 * @returns Formatted string with full precision
 */
export const formatCurrencyPrecise = (
  amount: string | number,
  maxDecimals: number = 18
): string => {
  const strAmount = typeof amount === "string" ? amount : amount.toString();

  const numAmount = parseFloat(strAmount);

  let formatted = numAmount.toFixed(maxDecimals);

  formatted = formatted.replace(/\.?0+$/, "");

  if (!formatted.includes(".")) {
    formatted = `${formatted}.0`;
  }

  return formatted;
};
</file>

<file path="examples/hotvault-demo/client/src/store/upload-store.ts">
import { create } from "zustand";
import { persist } from "zustand/middleware";

export interface UploadProgress {
  status:
    | "starting"
    | "preparing"
    | "uploading"
    | "processing"
    | "success"
    | "finalizing"
    | "adding_root"
    | "complete"
    | "error"
    | "warning"
    | "cancelled"
    | "retry"
    | "pending";
  progress?: number;
  message?: string;
  cid?: string;
  error?: string;
  lastUpdated?: number;
  isStalled?: boolean;
  filename?: string;
  jobId?: string;
  serviceProofSetId?: string;
}

interface UploadStore {
  uploadProgress: UploadProgress | null;
  setUploadProgress: (
    progress: UploadProgress | ((prev: UploadProgress | null) => UploadProgress)
  ) => void;
  clearUploadProgress: () => void;
}

export const useUploadStore = create<UploadStore>()(
  persist(
    (set, get) => ({
      uploadProgress: null,
      setUploadProgress: (progress) => {
        const newProgress =
          typeof progress === "function"
            ? progress(get().uploadProgress)
            : progress;
        console.log("[UploadStore] Setting progress:", newProgress);

        if (
          newProgress &&
          (newProgress.status === "complete" ||
            newProgress.status === "success") &&
          newProgress.progress === 100
        ) {
          console.log(
            "[UploadStore] Complete status with 100% detected, forcing cleanup soon"
          );

          set({ uploadProgress: newProgress });
          setTimeout(() => {
            console.log(
              "[UploadStore] Force clearing progress after complete status"
            );
            if (typeof window !== "undefined") {
              localStorage.removeItem("upload-storage");
            }
            set({ uploadProgress: null });
          }, 250);
          return;
        }

        if (newProgress.lastUpdated) {
          const timeSinceLastUpdate = Date.now() - newProgress.lastUpdated;
          if (timeSinceLastUpdate > 10000) {
            newProgress.isStalled = true;
          }
        }

        set({ uploadProgress: newProgress });
      },
      clearUploadProgress: () => {
        console.log("[UploadStore] Clearing progress");
        if (typeof window !== "undefined") {
          const storageKey = "upload-storage";
          try {
            const storageData = localStorage.getItem(storageKey);
            if (storageData) {
              console.log("[UploadStore] Found data in localStorage, removing");
              localStorage.removeItem(storageKey);
            }
          } catch (e) {
            console.error("[UploadStore] Error clearing localStorage:", e);
          }
        }
        set({ uploadProgress: null });
      },
    }),
    {
      name: "upload-storage",
      partialize: (state) => ({ uploadProgress: state.uploadProgress }),
      merge: (persistedState, currentState) => {
        const uploadProgressCleared =
          currentState.uploadProgress === null &&
          JSON.stringify(persistedState) !== "{}";

        if (uploadProgressCleared) {
          console.log(
            "[UploadStore] Upload progress was cleared in memory, not restoring from storage"
          );
          return currentState;
        }
        return {
          ...currentState,
          ...(persistedState as Partial<UploadStore>),
        };
      },
    }
  )
);
</file>

<file path="examples/hotvault-demo/client/src/theme/components.tsx">
import { ReactNode } from "react";
import { theme } from "./config";

interface ButtonProps {
  children: ReactNode;
  variant?: "primary" | "secondary" | "blue";
  size?: "sm" | "md" | "lg";
  disabled?: boolean;
  onClick?: () => void;
  className?: string;
}

export const Button = ({
  children,
  variant = "primary",
  size = "md",
  disabled = false,
  onClick,
  className = "",
}: ButtonProps) => {
  const baseStyles =
    "inline-flex items-center justify-center rounded-none font-light transition-colors";

  const variantStyles = {
    primary: "bg-black text-white hover:bg-gray-900 disabled:opacity-50",
    secondary: "border border-black text-black hover:bg-gray-50",
    blue: "bg-[#0090FF] text-white hover:opacity-90 disabled:opacity-50",
  };

  const sizeStyles = {
    sm: "h-9 px-4 text-sm",
    md: "h-10 px-6 text-sm",
    lg: "h-12 px-8 text-base",
  };

  return (
    <button
      onClick={onClick}
      disabled={disabled}
      className={`${baseStyles} ${variantStyles[variant]} ${sizeStyles[size]} ${className}`}
    >
      {children}
    </button>
  );
};

interface TextProps {
  children: ReactNode;
  variant?: "h1" | "h2" | "h3" | "h4" | "body" | "small";
  color?: "black" | "blue" | "white";
  className?: string;
}

export const Text = ({
  children,
  variant = "body",
  color = "black",
  className = "",
}: TextProps) => {
  const styles = {
    h1: "text-lg font-light tracking-widest uppercase",
    h2: "text-4xl md:text-5xl font-light tracking-tight",
    h3: "text-base font-light uppercase tracking-widest",
    h4: "text-xs uppercase tracking-widest font-light",
    body: "font-light leading-relaxed",
    small: "text-sm font-light",
  };

  const colorStyles = {
    black: "text-black",
    blue: "text-[#0090FF]",
    white: "text-white",
  };

  const Component = variant.startsWith("h") ? variant : "p";

  return (
    <Component
      className={`${styles[variant]} ${colorStyles[color]} ${className}`}
    >
      {children}
    </Component>
  );
};

interface ContainerProps {
  children: ReactNode;
  size?: keyof typeof theme.containers;
  background?: "white" | "black" | "light";
  className?: string;
}

export const Container = ({
  children,
  size = "xl",
  background = "white",
  className = "",
}: ContainerProps) => {
  const bgStyles = {
    white: "bg-white",
    black: "bg-black",
    light: "bg-[#F8F8F8]",
  };

  return (
    <div
      className={`max-w-${size} mx-auto px-6 ${bgStyles[background]} ${className}`}
    >
      {children}
    </div>
  );
};

interface InputProps {
  value: string;
  onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
  placeholder?: string;
  type?: string;
  variant?: "default" | "blue";
  className?: string;
}

export const Input = ({
  value,
  onChange,
  placeholder,
  type = "text",
  variant = "default",
  className = "",
}: InputProps) => {
  const variantStyles = {
    default: "border-gray-200 focus:ring-black",
    blue: "border-[#0090FF] focus:ring-[#0090FF]",
  };

  return (
    <input
      type={type}
      value={value}
      onChange={onChange}
      placeholder={placeholder}
      className={`px-4 py-2 border focus:outline-none focus:ring-1 ${variantStyles[variant]} ${className}`}
    />
  );
};
</file>

<file path="examples/hotvault-demo/client/src/theme/config.ts">
export const theme = {
  colors: {
    primary: {
      blue: "#0090FF", // Filecoin blue
      black: "#000000", // Pure black
      white: "#FFFFFF", // Pure white
    },
    error: {
      600: "#DC2626", // red for error messages
    },
    text: {
      primary: "#000000", // Black for primary text
      secondary: "#0090FF", // Filecoin blue for secondary text
      disabled: "#9E9E9E",
      white: "#FFFFFF", // White for text on dark backgrounds
    },
    background: {
      primary: "#FFFFFF", // White background
      secondary: "#F8F8F8", // Slightly off-white for secondary backgrounds
      dark: "#000000", // Black background
    },
    border: {
      light: "#E5E5E5", // Light border
      dark: "#000000", // Dark border
      blue: "#0090FF", // Filecoin blue border
    },
  },
  typography: {
    fontFamily: {
      sans: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif",
    },
    fontWeight: {
      light: "300",
      regular: "400",
      medium: "500",
      bold: "700",
    },
    fontSize: {
      xs: "0.75rem", // 12px
      sm: "0.875rem", // 14px
      base: "1rem", // 16px
      lg: "1.125rem", // 18px
      xl: "1.25rem", // 20px
      "2xl": "1.5rem", // 24px
      "3xl": "1.875rem", // 30px
      "4xl": "2.25rem", // 36px
      "5xl": "3rem", // 48px
    },
    letterSpacing: {
      tight: "-0.025em",
      normal: "0",
      wide: "0.025em",
      wider: "0.05em",
      widest: "0.25em",
    },
  },
  spacing: {
    0: "0",
    1: "0.25rem",
    2: "0.5rem",
    3: "0.75rem",
    4: "1rem",
    6: "1.5rem",
    8: "2rem",
    12: "3rem",
    16: "4rem",
    20: "5rem",
  },
  borderRadius: {
    none: "0",
    sm: "0.125rem",
    default: "0.25rem",
    lg: "0.5rem",
    full: "9999px",
  },
  borderWidth: {
    default: "1px",
    0: "0",
    2: "2px",
    4: "4px",
  },
  shadows: {
    none: "none",
    sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
    default: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
    lg: "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
  },
  transitions: {
    default: "all 0.2s ease-in-out",
    fast: "all 0.1s ease-in-out",
    slow: "all 0.3s ease-in-out",
  },
  containers: {
    sm: "640px",
    md: "768px",
    lg: "1024px",
    xl: "1280px",
    "2xl": "1536px",
  },
} as const;

// Type definitions for theme
export type Theme = typeof theme;
export type ThemeColors = typeof theme.colors;
export type ThemeTypography = typeof theme.typography;
export type ThemeSpacing = typeof theme.spacing;

// Helper functions
export const getColor = (path: keyof ThemeColors) => theme.colors[path];
export const getFontSize = (size: keyof typeof theme.typography.fontSize) =>
  theme.typography.fontSize[size];
export const getSpacing = (space: keyof ThemeSpacing) => theme.spacing[space];
</file>

<file path="examples/hotvault-demo/client/src/theme/ThemeProvider.tsx">
import { createContext, useContext, ReactNode } from "react";
import { theme, Theme } from "./config";

const ThemeContext = createContext<Theme>(theme);

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error("useTheme must be used within a ThemeProvider");
  }
  return context;
};

interface ThemeProviderProps {
  children: ReactNode;
}

export const ThemeProvider = ({ children }: ThemeProviderProps) => {
  return (
    <ThemeContext.Provider value={theme}>{children}</ThemeContext.Provider>
  );
};
</file>

<file path="examples/hotvault-demo/client/src/types/dashboard.ts">
export interface Piece {
  id: number;
  cid: string;
  filename: string;
  size: number;
  serviceName: string;
  serviceUrl: string;
  createdAt: string;
  updatedAt: string;
}

export const DASHBOARD_SECTIONS = {
  FILES: "files",
  ACTIVITY: "activity",
  PAYMENTS: "payments",
} as const;

export type DashboardSection =
  (typeof DASHBOARD_SECTIONS)[keyof typeof DASHBOARD_SECTIONS];

export const BUTTON_STYLES = {
  primary:
    "bg-blue-500 hover:bg-blue-600 text-white shadow-sm disabled:bg-blue-300",
  secondary:
    "bg-white hover:bg-gray-50 text-gray-900 border-gray-300 shadow-sm",
  danger: "bg-red-50 hover:bg-red-100 text-red-600 border-red-200 shadow-sm",
  base: "px-3 py-2 rounded-md text-sm font-medium transition-all border disabled:cursor-not-allowed flex items-center justify-center gap-2",
} as const;

export const INPUT_STYLES = {
  base: "w-full px-3 py-2 bg-white border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-sm text-gray-900 placeholder:text-gray-500 shadow-sm hover:border-gray-400 transition-all disabled:bg-gray-50 disabled:text-gray-500",
} as const;
</file>

<file path="examples/hotvault-demo/client/src/types/window.d.ts">
export interface EthereumProvider {
  request: (args: { method: string; params?: unknown[] }) => Promise<unknown>;
  on: (
    eventName: "accountsChanged" | "disconnect",
    handler: (accounts: string[]) => void
  ) => void;
  removeListener: (
    eventName: "accountsChanged" | "disconnect",
    handler: (accounts: string[]) => void
  ) => void;
  isMetaMask?: boolean;
  providers?: EthereumProvider[];
}

declare global {
  interface Window {
    ethereum?: EthereumProvider;
  }
}

export {};
</file>

<file path="examples/hotvault-demo/client/.env.example">
# Network Configuration
NETWORK_NAME=
NETWORK_CHAIN_ID=
NETWORK_RPC_URL=
NETWORK_BLOCK_EXPLORER=
NETWORK_CURRENCY_NAME=
NETWORK_CURRENCY_SYMBOL=
NETWORK_CURRENCY_DECIMALS=

# Contract Addresses
CONTRACT_PAYMENTS=
CONTRACT_PAYMENTS_PROXY=

# Token Addresses
TOKEN_WFIL=
TOKEN_USDC=
</file>

<file path="examples/hotvault-demo/client/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

bun.lock
yarn.lock

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env
.env.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="examples/hotvault-demo/client/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="examples/hotvault-demo/client/eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="examples/hotvault-demo/client/next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  devIndicators: false,
};

export default nextConfig;
</file>

<file path="examples/hotvault-demo/client/package.json">
{
  "name": "hotvault-client",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@hookform/resolvers": "^5.0.1",
    "@radix-ui/react-accordion": "^1.2.4",
    "@radix-ui/react-alert-dialog": "^1.1.7",
    "@radix-ui/react-aspect-ratio": "^1.1.3",
    "@radix-ui/react-avatar": "^1.1.4",
    "@radix-ui/react-checkbox": "^1.1.5",
    "@radix-ui/react-collapsible": "^1.1.4",
    "@radix-ui/react-context-menu": "^2.2.7",
    "@radix-ui/react-dialog": "^1.1.7",
    "@radix-ui/react-dropdown-menu": "^2.1.7",
    "@radix-ui/react-hover-card": "^1.1.7",
    "@radix-ui/react-label": "^2.1.3",
    "@radix-ui/react-menubar": "^1.1.7",
    "@radix-ui/react-navigation-menu": "^1.2.6",
    "@radix-ui/react-popover": "^1.1.7",
    "@radix-ui/react-progress": "^1.1.3",
    "@radix-ui/react-radio-group": "^1.2.4",
    "@radix-ui/react-scroll-area": "^1.2.4",
    "@radix-ui/react-select": "^2.1.7",
    "@radix-ui/react-separator": "^1.1.3",
    "@radix-ui/react-slider": "^1.2.4",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.1.4",
    "@radix-ui/react-tabs": "^1.1.4",
    "@radix-ui/react-toggle": "^1.1.3",
    "@radix-ui/react-toggle-group": "^1.1.3",
    "@radix-ui/react-tooltip": "^1.2.0",
    "@types/uuid": "^10.0.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "date-fns": "^4.1.0",
    "dotenv": "^16.5.0",
    "embla-carousel-react": "^8.6.0",
    "ethers": "^6.13.5",
    "framer-motion": "^12.6.5",
    "input-otp": "^1.4.2",
    "lucide-react": "^0.487.0",
    "next": "15.3.0",
    "next-themes": "^0.4.6",
    "react": "^19.1.0",
    "react-day-picker": "8.10.1",
    "react-dom": "^19.1.0",
    "react-dropzone": "^14.3.8",
    "react-hook-form": "^7.55.0",
    "react-hot-toast": "^2.5.2",
    "react-loading-skeleton": "^3.5.0",
    "react-resizable-panels": "^2.1.7",
    "recharts": "^2.15.2",
    "sonner": "^2.0.3",
    "tailwind-merge": "^3.2.0",
    "tw-animate-css": "^1.2.5",
    "uuid": "^11.1.0",
    "vaul": "^1.1.2",
    "zod": "^3.24.2",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^22",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.3.0",
    "tailwindcss": "^4",
    "typescript": "^5"
  },
  "packageManager": "yarn@1.22.22+sha512.a6b2f7906b721bba3d67d4aff083df04dad64c399707841b7acf00f6b133b7ac24255f2652fa22ae3534329dc6180534e98d17432037ff6fd140556e2bb3137e"
}
</file>

<file path="examples/hotvault-demo/client/postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="examples/hotvault-demo/client/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts", "src/lib/constants.tsx"],
  "exclude": ["node_modules"]
}
</file>

<file path="examples/hotvault-demo/server/cmd/api/main.go">
package main

import (
	"fmt"
	"os"

	"github.com/gin-gonic/gin"
	"github.com/hotvault/backend/config"
	"github.com/hotvault/backend/internal/api/routes"
	"github.com/hotvault/backend/internal/database"
	"github.com/hotvault/backend/pkg/logger"
	"github.com/joho/godotenv"
)

func main() {

	log := logger.NewLogger()

	if err := godotenv.Load(); err != nil {
		log.Warning("No .env file found, using environment variables")
	}

	log.Info("Loading configuration...")
	cfg := config.LoadConfig()

	loggingConfig := logger.GetLoggingConfig()

	if loggingConfig.DisableGINLogging || loggingConfig.ProductionMode {
		gin.SetMode(gin.ReleaseMode)
	} else if ginMode := os.Getenv("GIN_MODE"); ginMode != "" {
		gin.SetMode(ginMode)
	}

	log.Info("Attempting to connect to database...")
	db, err := database.NewPostgresConnection(cfg.Database)
	if err != nil {
		log.Fatal(fmt.Sprintf("Failed to connect to database: %v", err))
	}
	log.Info("Successfully connected to database.")

	log.Info("Attempting to run database migrations...")
	if err := database.MigrateDB(db); err != nil {
		log.Fatal(fmt.Sprintf("Failed to migrate database: %v", err))
	}
	log.Info("Database migrations completed successfully.")

	router := gin.Default()

	routes.SetupRoutes(router, db, cfg)

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	serverAddr := fmt.Sprintf(":%s", port)
	log.Info("Server starting on " + serverAddr)
	if err := router.Run(serverAddr); err != nil {
		log.Fatal(fmt.Sprintf("Failed to start server: %v", err))
	}
}
</file>

<file path="examples/hotvault-demo/server/config/config.go">
package config

import (
	"os"
	"strconv"
	"time"
)

type Config struct {
	Server       ServerConfig
	Database     DatabaseConfig
	JWT          JWTConfig
	Ethereum     EthereumConfig
	PdptoolPath  string
	ServiceName  string
	ServiceURL   string
	RecordKeeper string
}

type ServerConfig struct {
	Port string
	Env  string
}

type DatabaseConfig struct {
	Host     string
	Port     string
	User     string
	Password string
	DBName   string
	SSLMode  string
}

type JWTConfig struct {
	Secret     string
	Expiration time.Duration
}

type EthereumConfig struct {
	RPCURL          string
	ChainID         int64
	ContractAddress string
}

func LoadConfig() *Config {
	expirationStr := os.Getenv("JWT_EXPIRATION")
	expiration, err := time.ParseDuration(expirationStr)
	if err != nil {
		expiration = 24 * time.Hour
	}

	chainID, err := strconv.ParseInt(os.Getenv("ETH_CHAIN_ID"), 10, 64)
	if err != nil {
		chainID = 1
	}

	return &Config{
		Server: ServerConfig{
			Port: os.Getenv("PORT"),
			Env:  os.Getenv("ENV"),
		},
		Database: DatabaseConfig{
			Host:     os.Getenv("DB_HOST"),
			Port:     os.Getenv("DB_PORT"),
			User:     os.Getenv("DB_USER"),
			Password: os.Getenv("DB_PASSWORD"),
			DBName:   os.Getenv("DB_NAME"),
			SSLMode:  os.Getenv("DB_SSLMODE"),
		},
		JWT: JWTConfig{
			Secret:     os.Getenv("JWT_SECRET"),
			Expiration: expiration,
		},
		Ethereum: EthereumConfig{
			RPCURL:          os.Getenv("ETH_RPC_URL"),
			ChainID:         chainID,
			ContractAddress: os.Getenv("CONTRACT_ADDRESS"),
		},
		PdptoolPath:  os.Getenv("PDPTOOL_PATH"),
		ServiceName:  os.Getenv("SERVICE_NAME"),
		ServiceURL:   os.Getenv("SERVICE_URL"),
		RecordKeeper: os.Getenv("RECORD_KEEPER"),
	}
}
</file>

<file path="examples/hotvault-demo/server/docs/docs.go">
// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/404": {
            "get": {
                "description": "Returns 404 Not Found error",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Error"
                ],
                "summary": "Not Found",
                "responses": {
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/download/{cid}": {
            "get": {
                "description": "Download a file from the PDP service using its CID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/octet-stream"
                ],
                "tags": [
                    "download"
                ],
                "summary": "Download a file from PDP service",
                "parameters": [
                    {
                        "type": "string",
                        "description": "CID of the file to download",
                        "name": "cid",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "File content",
                        "schema": {
                            "type": "file"
                        }
                    }
                }
            }
        },
        "/api/v1/pieces": {
            "get": {
                "description": "Get all pieces uploaded by the authenticated user, including service proof set ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "pieces"
                ],
                "summary": "Get user's pieces",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/internal_api_handlers.PieceResponse"
                            }
                        }
                    }
                }
            }
        },
        "/api/v1/pieces/cid/{cid}": {
            "get": {
                "description": "Get a specific piece by its CID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "pieces"
                ],
                "summary": "Get piece by CID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Piece CID",
                        "name": "cid",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_fws_backend_internal_models.Piece"
                        }
                    }
                }
            }
        },
        "/api/v1/pieces/proof-sets": {
            "get": {
                "description": "Get all proof sets and their pieces for the authenticated user",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "pieces"
                ],
                "summary": "Get user's proof sets",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handlers.ProofSetsResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/pieces/proofs": {
            "get": {
                "description": "(DEPRECATED - Use /api/v1/pieces instead) Get all pieces with proof information",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "pieces"
                ],
                "summary": "Get user's pieces with proof data (DEPRECATED)",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/github_com_fws_backend_internal_models.Piece"
                            }
                        }
                    }
                }
            }
        },
        "/api/v1/pieces/{id}": {
            "get": {
                "description": "Get a specific piece by its ID",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "pieces"
                ],
                "summary": "Get piece by ID",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Piece ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/github_com_fws_backend_internal_models.Piece"
                        }
                    }
                }
            }
        },
        "/api/v1/roots/remove": {
            "post": {
                "description": "Remove a specific root from the PDP service",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "roots"
                ],
                "summary": "Remove roots using pdptool",
                "parameters": [
                    {
                        "description": "Remove root request data",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_api_handlers.RemoveRootRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/api/v1/upload": {
            "post": {
                "description": "Upload a file to the PDP service with piece preparation and returns a job ID for status polling",
                "consumes": [
                    "multipart/form-data"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "upload"
                ],
                "summary": "Upload a file to PDP service",
                "parameters": [
                    {
                        "type": "file",
                        "description": "File to upload",
                        "name": "file",
                        "in": "formData",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handlers.UploadProgress"
                        }
                    }
                }
            }
        },
        "/api/v1/upload/status/{jobId}": {
            "get": {
                "description": "Get the status of an upload job",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "upload"
                ],
                "summary": "Get upload status",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Job ID",
                        "name": "jobId",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handlers.UploadProgress"
                        }
                    }
                }
            }
        },
        "/auth/logout": {
            "post": {
                "description": "Logs out the user by clearing the JWT cookie",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Logout User",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/auth/nonce": {
            "post": {
                "description": "Generates a nonce for wallet signature authentication",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Generate Authentication Nonce",
                "parameters": [
                    {
                        "description": "Wallet address",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_api_handlers.NonceRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handlers.NonceResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/auth/status": {
            "get": {
                "description": "Checks if the user is authenticated via cookie and if their proof set is ready",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Check Authentication Status",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handlers.StatusResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/auth/verify": {
            "post": {
                "description": "Verifies the signature and issues a JWT token",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Verify Signature",
                "parameters": [
                    {
                        "description": "Address and signature",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/internal_api_handlers.VerifyRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handlers.VerifyResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handlers.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handlers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/health": {
            "get": {
                "description": "Returns the health status of the API",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Health"
                ],
                "summary": "Health Check",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handlers.HealthResponse"
                        }
                    }
                }
            }
        },
        "/proof-set/create": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Manually initiates the creation of a proof set for the authenticated user if one doesn't exist.",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Proof Set"
                ],
                "summary": "Create Proof Set",
                "responses": {
                    "200": {
                        "description": "message:Proof set creation initiated successfully",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handlers.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handlers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/internal_api_handlers.ErrorResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "github_com_fws_backend_internal_models.Piece": {
            "type": "object",
            "properties": {
                "cid": {
                    "type": "string"
                },
                "createdAt": {
                    "type": "string"
                },
                "filename": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "pendingRemoval": {
                    "type": "boolean"
                },
                "proofSetId": {
                    "type": "integer"
                },
                "removalDate": {
                    "type": "string"
                },
                "rootId": {
                    "type": "string"
                },
                "serviceName": {
                    "type": "string"
                },
                "serviceUrl": {
                    "type": "string"
                },
                "size": {
                    "type": "integer"
                },
                "updatedAt": {
                    "type": "string"
                },
                "user": {
                    "$ref": "#/definitions/github_com_fws_backend_internal_models.User"
                },
                "userId": {
                    "type": "integer"
                }
            }
        },
        "github_com_fws_backend_internal_models.Transaction": {
            "type": "object",
            "properties": {
                "blockHash": {
                    "type": "string"
                },
                "blockNumber": {
                    "type": "integer"
                },
                "createdAt": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "method": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "txHash": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                },
                "userId": {
                    "type": "integer"
                },
                "value": {
                    "type": "string"
                },
                "walletAddress": {
                    "type": "string"
                }
            }
        },
        "github_com_fws_backend_internal_models.User": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "nonce": {
                    "type": "string"
                },
                "transactions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/github_com_fws_backend_internal_models.Transaction"
                    }
                },
                "updatedAt": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                },
                "walletAddress": {
                    "type": "string"
                },
                "wallets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/github_com_fws_backend_internal_models.Wallet"
                    }
                }
            }
        },
        "github_com_fws_backend_internal_models.Wallet": {
            "type": "object",
            "properties": {
                "address": {
                    "type": "string"
                },
                "createdAt": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "isPrimary": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                },
                "userId": {
                    "type": "integer"
                }
            }
        },
        "internal_api_handlers.ErrorResponse": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string",
                    "example": "Invalid request"
                }
            }
        },
        "internal_api_handlers.HealthResponse": {
            "type": "object",
            "properties": {
                "status": {
                    "type": "string",
                    "example": "ok"
                }
            }
        },
        "internal_api_handlers.NonceRequest": {
            "description": "Request body for generating a nonce",
            "type": "object",
            "required": [
                "address"
            ],
            "properties": {
                "address": {
                    "type": "string",
                    "example": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
                }
            }
        },
        "internal_api_handlers.NonceResponse": {
            "description": "Response containing the generated nonce",
            "type": "object",
            "properties": {
                "nonce": {
                    "type": "string",
                    "example": "7a39f642c2608fd2bded0c35b1612d8716757326f870b6bd3f6cb7824f2b5c6d"
                }
            }
        },
        "internal_api_handlers.PieceResponse": {
            "type": "object",
            "properties": {
                "cid": {
                    "type": "string"
                },
                "createdAt": {
                    "type": "string"
                },
                "filename": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "pendingRemoval": {
                    "type": "boolean"
                },
                "proofSetDbId": {
                    "type": "integer"
                },
                "removalDate": {
                    "type": "string"
                },
                "rootId": {
                    "type": "string"
                },
                "serviceName": {
                    "type": "string"
                },
                "serviceProofSetId": {
                    "type": "string"
                },
                "serviceUrl": {
                    "type": "string"
                },
                "size": {
                    "type": "integer"
                },
                "updatedAt": {
                    "type": "string"
                },
                "userId": {
                    "type": "integer"
                }
            }
        },
        "internal_api_handlers.ProofSetWithPieces": {
            "type": "object",
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "pieceIds": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "proofSetId": {
                    "type": "string"
                },
                "serviceName": {
                    "type": "string"
                },
                "serviceUrl": {
                    "type": "string"
                },
                "transactionHash": {
                    "type": "string"
                },
                "updatedAt": {
                    "type": "string"
                }
            }
        },
        "internal_api_handlers.ProofSetsResponse": {
            "type": "object",
            "properties": {
                "pieces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/internal_api_handlers.PieceResponse"
                    }
                },
                "proofSets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/internal_api_handlers.ProofSetWithPieces"
                    }
                }
            }
        },
        "internal_api_handlers.RemoveRootRequest": {
            "type": "object",
            "required": [
                "pieceId"
            ],
            "properties": {
                "pieceId": {
                    "type": "integer"
                },
                "proofSetId": {
                    "type": "integer"
                },
                "rootId": {
                    "type": "string"
                },
                "serviceName": {
                    "type": "string"
                },
                "serviceUrl": {
                    "type": "string"
                }
            }
        },
        "internal_api_handlers.StatusResponse": {
            "description": "Response containing authentication status",
            "type": "object",
            "properties": {
                "address": {
                    "type": "string",
                    "example": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
                },
                "authenticated": {
                    "type": "boolean",
                    "example": true
                },
                "proofSetInitiated": {
                    "type": "boolean",
                    "example": true
                },
                "proofSetReady": {
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "internal_api_handlers.UploadProgress": {
            "type": "object",
            "properties": {
                "cid": {
                    "type": "string"
                },
                "error": {
                    "type": "string"
                },
                "filename": {
                    "type": "string"
                },
                "jobId": {
                    "type": "string"
                },
                "message": {
                    "type": "string"
                },
                "progress": {
                    "type": "integer"
                },
                "proofSetId": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "totalSize": {
                    "type": "integer"
                }
            }
        },
        "internal_api_handlers.VerifyRequest": {
            "description": "Request body for verifying a signature",
            "type": "object",
            "required": [
                "address",
                "signature"
            ],
            "properties": {
                "address": {
                    "type": "string",
                    "example": "0x742d35Cc6634C0532925a3b844Bc454e4438f44e"
                },
                "message": {
                    "type": "string",
                    "example": "Sign this message to login to Hot Vault (No funds will be transferred in this step): 7a39f642c2608fd2"
                },
                "signature": {
                    "type": "string",
                    "example": "0x1234567890abcdef"
                }
            }
        },
        "internal_api_handlers.VerifyResponse": {
            "description": "Response containing the JWT token and expiration",
            "type": "object",
            "properties": {
                "expires": {
                    "type": "integer",
                    "example": 1679529600
                },
                "token": {
                    "type": "string",
                    "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &swag.Spec{
	Version:          "1.0",
	Host:             "localhost:8080",
	BasePath:         "/api/v1",
	Schemes:          []string{},
	Title:            "Hot Vault Backend API",
	Description:      "API Server for Hot Vault Backend Application",
	InfoInstanceName: "swagger",
	SwaggerTemplate:  docTemplate,
	LeftDelim:        "{{",
	RightDelim:       "}}",
}

func init() {
	swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}
</file>

<file path="examples/hotvault-demo/server/internal/api/handlers/auth.go">
package handlers

import (
	"bytes"
	"crypto/rand"
	"encoding/hex"
	"errors"
	"fmt"
	"net/http"
	"os"
	"os/exec"
	"regexp"
	"strings"
	"time"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	"github.com/hotvault/backend/config"
	"github.com/hotvault/backend/internal/models"
	"github.com/hotvault/backend/internal/services"
	"github.com/sirupsen/logrus"
	"gorm.io/gorm"
)

var authLog = logrus.New()

type ErrorResponse struct {
	Error string `json:"error" example:"Invalid request"`
}

type AuthHandler struct {
	db         *gorm.DB
	cfg        *config.Config
	ethService *services.EthereumService
}

func NewAuthHandler(db *gorm.DB, cfg *config.Config) *AuthHandler {
	ethService := services.NewEthereumService(cfg.Ethereum)
	return &AuthHandler{
		db:         db,
		cfg:        cfg,
		ethService: ethService,
	}
}

// NonceRequest represents the request for generating a nonce
// @Description Request body for generating a nonce
type NonceRequest struct {
	Address string `json:"address" binding:"required,hexadecimal" example:"0x742d35Cc6634C0532925a3b844Bc454e4438f44e"`
}

// NonceResponse represents the response containing the generated nonce
// @Description Response containing the generated nonce
type NonceResponse struct {
	Nonce string `json:"nonce" example:"7a39f642c2608fd2bded0c35b1612d8716757326f870b6bd3f6cb7824f2b5c6d"`
}

// StatusResponse represents the response for checking authentication status
// @Description Response containing authentication status
type StatusResponse struct {
	Authenticated     bool   `json:"authenticated" example:"true"`
	Address           string `json:"address,omitempty" example:"0x742d35Cc6634C0532925a3b844Bc454e4438f44e"`
	ProofSetReady     bool   `json:"proofSetReady" example:"true"`
	ProofSetInitiated bool   `json:"proofSetInitiated" example:"true"`
}

// VerifyRequest represents the request for verifying a signature
// @Description Request body for verifying a signature
type VerifyRequest struct {
	Address   string `json:"address" binding:"required,hexadecimal" example:"0x742d35Cc6634C0532925a3b844Bc454e4438f44e"`
	Signature string `json:"signature" binding:"required,hexadecimal" example:"0x1234567890abcdef"`
	Message   string `json:"message,omitempty" example:"Sign this message to login to Hot Vault (No funds will be transferred in this step): 7a39f642c2608fd2"`
}

// VerifyResponse represents the response for a verification request
// @Description Response containing the JWT token and expiration
type VerifyResponse struct {
	Token   string `json:"token" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."`
	Expires int64  `json:"expires" example:"1679529600"`
}

// GenerateNonce godoc
// @Summary Generate Authentication Nonce
// @Description Generates a nonce for wallet signature authentication
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body NonceRequest true "Wallet address"
// @Success 200 {object} NonceResponse
// @Failure 400 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/nonce [post]
func (h *AuthHandler) GenerateNonce(c *gin.Context) {
	var req NonceRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, ErrorResponse{Error: "Invalid request: " + err.Error()})
		return
	}

	nonceBytes := make([]byte, 32)
	if _, err := rand.Read(nonceBytes); err != nil {
		c.JSON(http.StatusInternalServerError, ErrorResponse{Error: "Failed to generate nonce"})
		return
	}
	nonce := hex.EncodeToString(nonceBytes)

	var user models.User
	if err := h.db.Where("wallet_address = ?", req.Address).First(&user).Error; err != nil {
		user = models.User{
			WalletAddress: req.Address,
			Nonce:         nonce,
		}
		if err := h.db.Create(&user).Error; err != nil {
			c.JSON(http.StatusInternalServerError, ErrorResponse{Error: "Failed to create user"})
			return
		}
	} else {
		if err := h.db.Model(&user).Update("nonce", nonce).Error; err != nil {
			c.JSON(http.StatusInternalServerError, ErrorResponse{Error: "Failed to update nonce"})
			return
		}
	}

	c.JSON(http.StatusOK, NonceResponse{
		Nonce: nonce,
	})
}

// VerifySignature godoc
// @Summary Verify Signature
// @Description Verifies the signature and issues a JWT token
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body VerifyRequest true "Address and signature"
// @Success 200 {object} VerifyResponse
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /auth/verify [post]
func (h *AuthHandler) VerifySignature(c *gin.Context) {
	var req VerifyRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, ErrorResponse{Error: "Invalid request: " + err.Error()})
		return
	}

	var user models.User
	if err := h.db.Where("wallet_address = ?", req.Address).First(&user).Error; err != nil {
		c.JSON(http.StatusBadRequest, ErrorResponse{Error: "Invalid wallet address"})
		return
	}

	fmt.Printf("Verifying signature - Address: %s, Nonce: %s, Message: %s\n",
		req.Address, user.Nonce, req.Message)

	var valid bool
	var err error

	if req.Message != "" {
		expectedPrefix := fmt.Sprintf("Sign this message to login to Hot Vault (No funds will be transferred in this step): %s", user.Nonce)
		if req.Message == expectedPrefix {
			valid, err = h.ethService.VerifySignature(req.Address, req.Message, req.Signature)
		} else {
			fmt.Println("Message format does not match expected format")
			fmt.Printf("Expected: %s\nActual: %s\n", expectedPrefix, req.Message)
			c.JSON(http.StatusUnauthorized, ErrorResponse{Error: "Invalid message format"})
			return
		}
	} else {
		message := fmt.Sprintf("Sign this message to login to Hot Vault (No funds will be transferred in this step): %s", user.Nonce)
		valid, err = h.ethService.VerifySignature(req.Address, message, req.Signature)
	}

	if err != nil {
		fmt.Printf("Signature verification error: %v\n", err)
		c.JSON(http.StatusInternalServerError, ErrorResponse{Error: "Failed to verify signature: " + err.Error()})
		return
	}

	if !valid {
		fmt.Println("Invalid signature detected")
		c.JSON(http.StatusUnauthorized, ErrorResponse{Error: "Invalid signature"})
		return
	}

	nonceBytes := make([]byte, 32)
	if _, err := rand.Read(nonceBytes); err != nil {
		c.JSON(http.StatusInternalServerError, ErrorResponse{Error: "Failed to generate nonce"})
		return
	}
	newNonce := hex.EncodeToString(nonceBytes)

	if err := h.db.Model(&user).Update("nonce", newNonce).Error; err != nil {
		c.JSON(http.StatusInternalServerError, ErrorResponse{Error: "Failed to update nonce"})
		return
	}

	expirationTime := time.Now().Add(h.cfg.JWT.Expiration)
	claims := &models.JWTClaims{
		UserID:        user.ID,
		WalletAddress: user.WalletAddress,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expirationTime),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString([]byte(h.cfg.JWT.Secret))
	if err != nil {
		c.JSON(http.StatusInternalServerError, ErrorResponse{Error: "Failed to generate token"})
		return
	}

	domain := "" // Default domain is the current domain
	isProduction := h.cfg.Server.Env == "production"
	if isProduction {
		c.SetCookie("jwt_token", tokenString, int(h.cfg.JWT.Expiration.Seconds()), "/", domain, true, true)
	} else {
		c.SetCookie("jwt_token", tokenString, int(h.cfg.JWT.Expiration.Seconds()), "/", domain, false, true)
	}

	c.JSON(http.StatusOK, VerifyResponse{
		Token:   tokenString,
		Expires: expirationTime.Unix(),
	})
}

// CreateProofSet godoc
// @Summary Create Proof Set
// @Description Manually initiates the creation of a proof set for the authenticated user if one doesn't exist.
// @Tags Proof Set
// @Security ApiKeyAuth
// @Produce json
// @Success 200 {object} map[string]interface{} "message:Proof set creation initiated successfully"
// @Failure 400 {object} ErrorResponse
// @Failure 401 {object} ErrorResponse
// @Failure 500 {object} ErrorResponse
// @Router /proof-set/create [post]
func (h *AuthHandler) CreateProofSet(c *gin.Context) {
	userID, exists := c.Get("userID")
	if !exists {
		c.JSON(http.StatusUnauthorized, ErrorResponse{Error: "Unauthorized: User ID not found in token"})
		return
	}

	var user models.User
	if err := h.db.First(&user, userID).Error; err != nil {
		c.JSON(http.StatusNotFound, ErrorResponse{Error: "User not found"})
		return
	}

	var existingProofSet models.ProofSet
	err := h.db.Where("user_id = ?", user.ID).First(&existingProofSet).Error
	if err == nil {
		if existingProofSet.ProofSetID != "" {
			authLog.WithField("userID", user.ID).Warn("CreateProofSet called but ProofSetID already exists.")
			c.JSON(http.StatusConflict, ErrorResponse{Error: "Proof set already exists and is complete for this user"})
			return
		}
		if existingProofSet.TransactionHash != "" {
			authLog.WithField("userID", user.ID).Warn("CreateProofSet called but TransactionHash exists (creation likely in progress).")
			c.JSON(http.StatusConflict, ErrorResponse{Error: "Proof set creation is already in progress for this user. Check status."})
			return
		}
		authLog.WithField("userID", user.ID).Info("Found existing proof set record with empty fields, proceeding with creation attempt.")
	} else if !errors.Is(err, gorm.ErrRecordNotFound) {
		authLog.WithField("userID", user.ID).Errorf("Error checking for existing proof set: %v", err)
		c.JSON(http.StatusInternalServerError, ErrorResponse{Error: "Failed to check for existing proof sets"})
		return
	} else {
		authLog.WithField("userID", user.ID).Info("No existing proof set record found.")
	}

	go func(u *models.User) {
		authLog.WithField("userID", u.ID).Info("Starting background proof set creation...")
		if err := h.createProofSetForUser(u); err != nil {
			authLog.WithField("userID", u.ID).Errorf("Background proof set creation failed: %v", err)
		} else {
			authLog.WithField("userID", u.ID).Info("Background proof set creation completed successfully.")
		}
	}(&user)

	c.JSON(http.StatusOK, gin.H{"message": "Proof set creation initiated successfully. Monitor /auth/status for readiness."})
}

func (h *AuthHandler) createProofSetForUser(user *models.User) error {
	pdptoolPath := h.cfg.PdptoolPath
	if pdptoolPath == "" {
		return errors.New("pdptool path not configured")
	}
	serviceName := h.cfg.ServiceName
	serviceURL := h.cfg.ServiceURL
	recordKeeper := h.cfg.RecordKeeper

	if serviceName == "" || serviceURL == "" || recordKeeper == "" {
		errMsg := "service name, service url, or record keeper not configured"
		authLog.Error(errMsg)
		return errors.New(errMsg)
	}

	// Change working directory to pdptool directory
	pdptoolDir := getPdptoolParentDir(pdptoolPath)
	if err := os.Chdir(pdptoolDir); err != nil {
		errMsg := fmt.Sprintf("Failed to change working directory to pdptool directory: %v", err)
		authLog.Error(errMsg)
		return errors.New(errMsg)
	}
	authLog.WithField("pdptoolDir", pdptoolDir).Info("Changed working directory to pdptool directory")

	authLog.Infof("[Goroutine Create] Creating proof set for user %d (Address: %s)...", user.ID, user.WalletAddress)

	metadata := fmt.Sprintf("hotvault-user-%d", user.ID)
	payerAddress := user.WalletAddress

	extraDataHex, err := encodeExtraData(metadata, payerAddress)
	if err != nil {
		errMsg := fmt.Sprintf("[Goroutine Create] Failed to ABI encode extra data for user %d: %v", user.ID, err)
		authLog.Error(errMsg)
		return errors.New(errMsg)
	}
	authLog.WithField("extraDataHex", extraDataHex).Info("[Goroutine Create] ABI encoded extra data for user ", user.ID)

	createProofSetArgs := []string{
		"create-proof-set",
		"--service-url", serviceURL,
		"--service-name", serviceName,
		"--recordkeeper", recordKeeper,
		"--extra-data", extraDataHex,
	}

	createProofSetCmd := exec.Command(pdptoolPath, createProofSetArgs...)

	var createProofSetOutput bytes.Buffer
	var createProofSetError bytes.Buffer
	createProofSetCmd.Stdout = &createProofSetOutput
	createProofSetCmd.Stderr = &createProofSetError

	authLog.WithField("command", pdptoolPath+" "+strings.Join(createProofSetArgs, " ")).Info("[Goroutine Create] Executing create-proof-set command for user ", user.ID)

	if err := createProofSetCmd.Run(); err != nil {
		errMsg := fmt.Sprintf("[Goroutine Create] Failed to run create-proof-set command for user %d: %v", user.ID, err)
		authLog.WithFields(logrus.Fields{
			"userID":  user.ID,
			"error":   err.Error(),
			"stderr":  createProofSetError.String(),
			"stdout":  createProofSetOutput.String(),
			"command": pdptoolPath + " " + strings.Join(createProofSetArgs, " "),
		}).Error(errMsg)
		return errors.New(errMsg + ", stderr: " + createProofSetError.String())
	}

	outputStr := createProofSetOutput.String()
	authLog.WithField("createOutput", outputStr).Debug("[Goroutine Create] Create proof set output for user ", user.ID)

	txHashRegex := regexp.MustCompile(`Location: /pdp/proof-sets/created/(0x[a-fA-F0-9]{64})`)
	txHashMatches := txHashRegex.FindStringSubmatch(outputStr)
	var txHash string

	if len(txHashMatches) > 1 {
		txHash = txHashMatches[1]
		authLog.WithField("txHash", txHash).Infof("[Goroutine Create] Extracted transaction hash for user %d. Updating database and starting polling...", user.ID)

		proofSetToUpdate := models.ProofSet{
			UserID:          user.ID,
			TransactionHash: txHash,
			ServiceName:     serviceName,
			ServiceURL:      serviceURL,
		}
		result := h.db.Where(models.ProofSet{UserID: user.ID}).Assign(proofSetToUpdate).FirstOrCreate(&models.ProofSet{})
		if result.Error != nil {
			errMsg := fmt.Sprintf("[Goroutine Create] Failed to save/update proof set with txHash for user %d: %v", user.ID, result.Error)
			authLog.Error(errMsg)
			return errors.New(errMsg)
		}

	} else {
		authLog.Warn("[Goroutine Create] Could not extract transaction hash using Location regex for user ", user.ID, ". Check pdptool output format.")
		errMsg := fmt.Sprintf("[Goroutine Create] Failed to extract transaction hash needed for polling for user %d. Output: %s", user.ID, outputStr)
		authLog.Error(errMsg)
		return errors.New(errMsg)
	}

	extractedID, pollErr := h.pollForProofSetID(pdptoolPath, serviceURL, serviceName, txHash, user)
	if pollErr != nil {
		authLog.Errorf("[Goroutine Create] Failed to poll for proof set ID for user %d: %v", user.ID, pollErr)
		return pollErr
	}

	finalUpdate := models.ProofSet{
		ProofSetID: extractedID,
	}
	result := h.db.Model(&models.ProofSet{}).Where("user_id = ?", user.ID).Updates(finalUpdate)
	if result.Error != nil {
		errMsg := fmt.Sprintf("[Goroutine Create] Failed to update proof set with ProofSetID for user %d: %v", user.ID, result.Error)
		authLog.Error(errMsg)
		return errors.New(errMsg)
	}
	if result.RowsAffected == 0 {
		errMsg := fmt.Sprintf("[Goroutine Create] Failed to find proof set record for user %d to update with ProofSetID", user.ID)
		authLog.Error(errMsg)
		return errors.New(errMsg)
	}
	authLog.WithField("proofSetPdpID", extractedID).Infof("[Goroutine Create] Successfully updated proof set with ID for user %d", user.ID)
	return nil
}

func (h *AuthHandler) pollForProofSetID(pdptoolPath, serviceURL, serviceName, txHash string, user *models.User) (string, error) {
	proofSetIDRegex := regexp.MustCompile(`ProofSet ID:[ \t]*(\d+)`)
	creationStatusRegex := regexp.MustCompile(`Proofset Created:[ \t]*(true|false)`)
	txStatusRegex := regexp.MustCompile(`Transaction Status:[ \t]*(confirmed|pending|failed)`)
	txSuccessRegex := regexp.MustCompile(`Transaction Successful:[ \t]*(true|false|Pending)`)

	// Change working directory to pdptool directory
	pdptoolDir := getPdptoolParentDir(pdptoolPath)
	if err := os.Chdir(pdptoolDir); err != nil {
		errMsg := fmt.Sprintf("Failed to change working directory to pdptool directory: %v", err)
		authLog.Error(errMsg)
		return "", errors.New(errMsg)
	}
	authLog.WithField("pdptoolDir", pdptoolDir).Info("Changed working directory to pdptool directory")

	sleepDuration := 10 * time.Second
	attemptCounter := 0
	const maxLogInterval = 6

	authLog.WithField("txHash", txHash).Info("[Goroutine Polling] Starting polling for ProofSet ID for user ", user.ID)

	for {
		attemptCounter++
		getStatusCmd := exec.Command(
			pdptoolPath,
			"get-proof-set-create-status",
			"--service-url", serviceURL,
			"--service-name", serviceName,
			"--tx-hash", txHash,
		)

		var getStatusOutput bytes.Buffer
		var getStatusError bytes.Buffer
		getStatusCmd.Stdout = &getStatusOutput
		getStatusCmd.Stderr = &getStatusError

		cmdString := fmt.Sprintf("%s %s", pdptoolPath, strings.Join(getStatusCmd.Args[1:], " "))
		authLog.WithField("command", cmdString).
			WithField("attempt", attemptCounter).
			WithField("txHash", txHash).
			WithField("userID", user.ID).
			Info("[Goroutine Polling] Executing get-proof-set-create-status command")

		err := getStatusCmd.Run()
		statusOutput := getStatusOutput.String()
		statusStderr := getStatusError.String()

		if err != nil {
			authLog.WithField("error", err.Error()).
				WithField("stderr", statusStderr).
				WithField("command", cmdString).
				WithField("attempt", attemptCounter).
				WithField("userID", user.ID).
				Warnf("[Goroutine Polling] Failed to run get-proof-set-create-status command, retrying in %v...", sleepDuration)
			time.Sleep(sleepDuration)
			continue
		}

		authLog.WithField("statusOutput", statusOutput).
			WithField("attempt", attemptCounter).
			WithField("userID", user.ID).
			WithField("txHash", txHash).
			Info("[Goroutine Polling] get-proof-set-create-status command output")

		txStatusMatch := txStatusRegex.FindStringSubmatch(statusOutput)
		txSuccessMatch := txSuccessRegex.FindStringSubmatch(statusOutput)
		createdMatch := creationStatusRegex.FindStringSubmatch(statusOutput)
		idMatch := proofSetIDRegex.FindStringSubmatch(statusOutput)

		var txStatus, txSuccess, createdStatus string
		if len(txStatusMatch) > 1 {
			txStatus = txStatusMatch[1]
		}
		if len(txSuccessMatch) > 1 {
			txSuccess = txSuccessMatch[1]
		}
		if len(createdMatch) > 1 {
			createdStatus = createdMatch[1]
		}

		// Log the status details for each polling attempt
		var idMatchValue string
		if len(idMatch) > 1 {
			idMatchValue = idMatch[1]
		} else {
			idMatchValue = "none"
		}

		authLog.WithFields(logrus.Fields{
			"userID":        user.ID,
			"txHash":        txHash,
			"attempt":       attemptCounter,
			"txStatus":      txStatus,
			"txSuccess":     txSuccess,
			"createdStatus": createdStatus,
			"idFound":       len(idMatch) > 1,
			"idMatch":       idMatchValue,
		}).Info("[Goroutine Polling] Current proof set creation status")

		if txStatus == "confirmed" && txSuccess == "true" && createdStatus == "true" && len(idMatch) > 1 {
			proofSetIDStr := idMatch[1]
			authLog.WithField("proofSetID", proofSetIDStr).WithField("attempts", attemptCounter).Infof("[Goroutine Polling] Successfully extracted proof set ID for user %d", user.ID)
			return proofSetIDStr, nil
		}

		if txStatus == "confirmed" && txSuccess == "true" && createdStatus == "false" {
			authLog.Infof("[Goroutine Polling] Attempt %d: Transaction confirmed for user %d, but proofset creation still processing (TxStatus: %s, TxSuccess: %s, CreatedStatus: %s)... Polling again in %v.",
				attemptCounter, user.ID, txStatus, txSuccess, createdStatus, sleepDuration)
			time.Sleep(sleepDuration)
			continue
		}

		if txStatus == "confirmed" && (txSuccess == "false" || (createdStatus == "true" && len(idMatch) == 0)) {
			authLog.Errorf("[Goroutine Polling] Proof set creation failed or stalled for user %d (TxStatus: %s, TxSuccess: %s, CreatedStatus: %s, ID Found: %t). Output: %s",
				user.ID, txStatus, txSuccess, createdStatus, len(idMatch) > 1, statusOutput)
			return "", fmt.Errorf("proof set creation failed or stalled post-confirmation for tx %s (status: %s, success: %s, created: %s)", txHash, txStatus, txSuccess, createdStatus)
		}

		if txStatus == "failed" {
			authLog.Errorf("[Goroutine Polling] Proof set creation transaction failed for user %d (TxStatus: %s). Output: %s",
				user.ID, txStatus, statusOutput)
			return "", fmt.Errorf("proof set creation transaction failed for tx %s (status: %s)", txHash, txStatus)
		}

		if txStatus == "pending" || txStatus == "" {
			authLog.Infof("[Goroutine Polling] Attempt %d: Proof set creation still pending for user %d (TxStatus: '%s')... Polling again in %v.", attemptCounter, user.ID, txStatus, sleepDuration)
			if attemptCounter%maxLogInterval == 0 {
				authLog.WithField("attempt", attemptCounter).Info("[Goroutine Polling] Still waiting for proof set ID for user ", user.ID, " (TxHash: ", txHash, ")")
			}
			time.Sleep(sleepDuration)
			continue
		}

		authLog.Warnf("[Goroutine Polling] Attempt %d: Encountered unhandled status for user %d (TxStatus: %s, TxSuccess: %s, CreatedStatus: %s). Retrying in %v... Output: %s",
			attemptCounter, user.ID, txStatus, txSuccess, createdStatus, sleepDuration, statusOutput)
		time.Sleep(sleepDuration)
	}
}

// CheckAuthStatus godoc
// @Summary Check Authentication Status
// @Description Checks if the user is authenticated via cookie and if their proof set is ready
// @Tags Authentication
// @Produce json
// @Success 200 {object} StatusResponse
// @Failure 401 {object} ErrorResponse
// @Router /auth/status [get]
func (h *AuthHandler) CheckAuthStatus(c *gin.Context) {
	tokenString, err := c.Cookie("jwt_token")
	if err != nil {
		c.JSON(http.StatusOK, StatusResponse{
			Authenticated:     false,
			ProofSetReady:     false,
			ProofSetInitiated: false,
		})
		return
	}

	token, err := jwt.ParseWithClaims(tokenString, &models.JWTClaims{}, func(token *jwt.Token) (interface{}, error) {
		return []byte(h.cfg.JWT.Secret), nil
	})

	if err != nil || !token.Valid {
		c.SetCookie("jwt_token", "", -1, "/", "", false, true)
		c.JSON(http.StatusOK, StatusResponse{
			Authenticated:     false,
			ProofSetReady:     false,
			ProofSetInitiated: false,
		})
		return
	}

	claims, ok := token.Claims.(*models.JWTClaims)
	if !ok {
		c.SetCookie("jwt_token", "", -1, "/", "", false, true)
		c.JSON(http.StatusOK, StatusResponse{
			Authenticated:     false,
			ProofSetReady:     false,
			ProofSetInitiated: false,
		})
		return
	}

	var proofSet models.ProofSet
	isReady := false
	isInitiated := false
	if err := h.db.Where("user_id = ?", claims.UserID).First(&proofSet).Error; err == nil {
		if proofSet.ProofSetID != "" {
			isReady = true
		}
		if proofSet.TransactionHash != "" {
			isInitiated = true
		}
	} else if err != gorm.ErrRecordNotFound {
		authLog.WithField("userID", claims.UserID).Errorf("Error checking proof set readiness in /auth/status: %v", err)
	}

	c.JSON(http.StatusOK, StatusResponse{
		Authenticated:     true,
		Address:           claims.WalletAddress,
		ProofSetReady:     isReady,
		ProofSetInitiated: isInitiated,
	})
}

// Logout godoc
// @Summary Logout User
// @Description Logs out the user by clearing the JWT cookie
// @Tags Authentication
// @Produce json
// @Success 200 {object} map[string]string
// @Router /auth/logout [post]
func (h *AuthHandler) Logout(c *gin.Context) {
	domain := ""
	c.SetCookie("jwt_token", "", -1, "/", domain, false, true)

	c.JSON(http.StatusOK, gin.H{
		"message": "Successfully logged out",
	})
}

func encodeExtraData(metadata string, payerAddress string) (string, error) {
	if !common.IsHexAddress(payerAddress) {
		return "", fmt.Errorf("invalid payer address format: %s", payerAddress)
	}

	structTy, err := abi.NewType("tuple", "", []abi.ArgumentMarshaling{
		{
			Name: "metadata",
			Type: "string",
		},
		{
			Name: "payer",
			Type: "address",
		},
	})

	if err != nil {
		return "", fmt.Errorf("failed to create struct type: %w", err)
	}

	arguments := abi.Arguments{
		{
			Type: structTy,
		},
	}

	structData := struct {
		Metadata string
		Payer    common.Address
	}{
		Metadata: metadata,
		Payer:    common.HexToAddress(payerAddress),
	}

	packedBytes, err := arguments.Pack(structData)
	if err != nil {
		return "", fmt.Errorf("failed to pack ABI arguments: %w", err)
	}

	return hex.EncodeToString(packedBytes), nil
}
</file>

<file path="examples/hotvault-demo/server/internal/api/handlers/chunked_upload.go">
package handlers

import (
	"fmt"
	"io"
	"io/ioutil"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

type ChunkedUploadInfo struct {
	ID             string       `json:"id"`
	UserID         uint         `json:"userId"`
	Filename       string       `json:"filename"`
	ChunkSize      int64        `json:"chunkSize"`
	TotalSize      int64        `json:"totalSize"`
	TotalChunks    int          `json:"totalChunks"`
	UploadedChunks int          `json:"uploadedChunks"`
	ChunksReceived map[int]bool `json:"-"`
	TempDir        string       `json:"-"`
	Status         string       `json:"status"`
	CreatedAt      time.Time    `json:"createdAt"`
	UpdatedAt      time.Time    `json:"updatedAt"`
	FileType       string       `json:"fileType"`
}

var (
	chunkedUploads      = make(map[string]*ChunkedUploadInfo)
	chunkedUploadsMutex sync.RWMutex
)

func init() {
	go func() {
		ticker := time.NewTicker(1 * time.Hour)
		defer ticker.Stop()
		for range ticker.C {
			cleanupOldChunkedUploads()
		}
	}()
}

func cleanupOldChunkedUploads() {
	threshold := time.Now().Add(-24 * time.Hour)

	chunkedUploadsMutex.Lock()
	defer chunkedUploadsMutex.Unlock()

	for id, info := range chunkedUploads {
		if info.UpdatedAt.Before(threshold) {
			if info.TempDir != "" {
				os.RemoveAll(info.TempDir)
			}
			delete(chunkedUploads, id)
			log.WithField("uploadId", id).Info("Cleaned up expired chunked upload")
		}
	}
}

func InitChunkedUpload(c *gin.Context) {
	userID, exists := c.Get("userID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error": "User ID not found in token",
		})
		return
	}

	var request struct {
		Filename    string `json:"filename" binding:"required"`
		TotalSize   int64  `json:"totalSize" binding:"required"`
		ChunkSize   int64  `json:"chunkSize" binding:"required"`
		TotalChunks int    `json:"totalChunks" binding:"required"`
		FileType    string `json:"fileType" binding:"required"`
	}

	if err := c.ShouldBindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Invalid request parameters: " + err.Error(),
		})
		return
	}

	uploadID := uuid.New().String()
	tempDir := filepath.Join(os.TempDir(), "chunked_uploads", uploadID)

	if err := os.MkdirAll(tempDir, 0755); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to create temp directory: " + err.Error(),
		})
		return
	}

	now := time.Now()
	uploadInfo := &ChunkedUploadInfo{
		ID:             uploadID,
		UserID:         userID.(uint),
		Filename:       request.Filename,
		ChunkSize:      request.ChunkSize,
		TotalSize:      request.TotalSize,
		TotalChunks:    request.TotalChunks,
		UploadedChunks: 0,
		ChunksReceived: make(map[int]bool),
		TempDir:        tempDir,
		Status:         "initialized",
		CreatedAt:      now,
		UpdatedAt:      now,
		FileType:       request.FileType,
	}

	chunkedUploadsMutex.Lock()
	chunkedUploads[uploadID] = uploadInfo
	chunkedUploadsMutex.Unlock()

	log.WithField("uploadId", uploadID).
		WithField("filename", request.Filename).
		WithField("totalSize", formatFileSize(request.TotalSize)).
		WithField("totalChunks", request.TotalChunks).
		Info("Initialized chunked upload")

	c.JSON(http.StatusOK, gin.H{
		"uploadId":    uploadID,
		"message":     "Chunked upload initialized successfully",
		"totalChunks": request.TotalChunks,
	})
}

func UploadChunk(c *gin.Context) {
	userID, exists := c.Get("userID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error": "User ID not found in token",
		})
		return
	}

	uploadID := c.Query("uploadId")
	if uploadID == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Missing uploadId parameter",
		})
		return
	}

	chunkIndexStr := c.Query("chunkIndex")
	if chunkIndexStr == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Missing chunkIndex parameter",
		})
		return
	}

	chunkIndex, err := strconv.Atoi(chunkIndexStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Invalid chunkIndex parameter",
		})
		return
	}

	chunkedUploadsMutex.RLock()
	uploadInfo, exists := chunkedUploads[uploadID]
	chunkedUploadsMutex.RUnlock()

	if !exists {
		c.JSON(http.StatusNotFound, gin.H{
			"error": "Upload ID not found",
		})
		return
	}

	if uploadInfo.UserID != userID.(uint) {
		c.JSON(http.StatusForbidden, gin.H{
			"error": "You don't have permission to access this upload",
		})
		return
	}

	if chunkIndex < 0 || chunkIndex >= uploadInfo.TotalChunks {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": fmt.Sprintf("Invalid chunk index. Must be between 0 and %d", uploadInfo.TotalChunks-1),
		})
		return
	}

	chunkedUploadsMutex.RLock()
	_, chunkExists := uploadInfo.ChunksReceived[chunkIndex]
	chunkedUploadsMutex.RUnlock()

	if chunkExists {
		c.JSON(http.StatusOK, gin.H{
			"message":        fmt.Sprintf("Chunk %d already received", chunkIndex),
			"uploadId":       uploadID,
			"chunkIndex":     chunkIndex,
			"uploadedChunks": uploadInfo.UploadedChunks,
			"totalChunks":    uploadInfo.TotalChunks,
		})
		return
	}

	file, err := c.FormFile("chunk")
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Failed to get chunk data: " + err.Error(),
		})
		return
	}

	src, err := file.Open()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to open uploaded chunk: " + err.Error(),
		})
		return
	}
	defer src.Close()

	chunkPath := filepath.Join(uploadInfo.TempDir, fmt.Sprintf("chunk_%d", chunkIndex))
	dst, err := os.Create(chunkPath)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to create chunk file: " + err.Error(),
		})
		return
	}
	defer dst.Close()

	if _, err = io.Copy(dst, src); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to save chunk data: " + err.Error(),
		})
		return
	}

	chunkedUploadsMutex.Lock()
	uploadInfo.ChunksReceived[chunkIndex] = true
	uploadInfo.UploadedChunks++
	uploadInfo.UpdatedAt = time.Now()
	if uploadInfo.UploadedChunks == uploadInfo.TotalChunks {
		uploadInfo.Status = "allChunksReceived"
	} else {
		uploadInfo.Status = "inProgress"
	}
	chunkedUploadsMutex.Unlock()

	log.WithField("uploadId", uploadID).
		WithField("chunkIndex", chunkIndex).
		WithField("uploadedChunks", uploadInfo.UploadedChunks).
		WithField("totalChunks", uploadInfo.TotalChunks).
		Info("Received chunk")

	c.JSON(http.StatusOK, gin.H{
		"message":           fmt.Sprintf("Chunk %d received successfully", chunkIndex),
		"uploadId":          uploadID,
		"chunkIndex":        chunkIndex,
		"uploadedChunks":    uploadInfo.UploadedChunks,
		"totalChunks":       uploadInfo.TotalChunks,
		"allChunksReceived": uploadInfo.UploadedChunks == uploadInfo.TotalChunks,
	})
}

func CompleteChunkedUpload(c *gin.Context) {
	userID, exists := c.Get("userID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error": "User ID not found in token",
		})
		return
	}

	var request struct {
		UploadID string `json:"uploadId" binding:"required"`
	}

	if err := c.ShouldBindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Invalid request parameters: " + err.Error(),
		})
		return
	}

	chunkedUploadsMutex.RLock()
	uploadInfo, exists := chunkedUploads[request.UploadID]
	chunkedUploadsMutex.RUnlock()

	if !exists {
		c.JSON(http.StatusNotFound, gin.H{
			"error": "Upload ID not found",
		})
		return
	}

	if uploadInfo.UserID != userID.(uint) {
		c.JSON(http.StatusForbidden, gin.H{
			"error": "You don't have permission to access this upload",
		})
		return
	}

	if uploadInfo.UploadedChunks != uploadInfo.TotalChunks {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": fmt.Sprintf("Not all chunks received. Got %d of %d chunks",
				uploadInfo.UploadedChunks, uploadInfo.TotalChunks),
			"uploadedChunks": uploadInfo.UploadedChunks,
			"totalChunks":    uploadInfo.TotalChunks,
		})
		return
	}

	chunkedUploadsMutex.Lock()
	uploadInfo.Status = "assembling"
	chunkedUploadsMutex.Unlock()

	jobID := uuid.New().String()

	go assembleAndProcessFile(uploadInfo, jobID, userID.(uint))

	c.JSON(http.StatusOK, gin.H{
		"message":  "Finalizing chunked upload",
		"uploadId": request.UploadID,
		"jobId":    jobID,
		"status":   "processing",
	})
}

func GetChunkedUploadStatus(c *gin.Context) {
	userID, exists := c.Get("userID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error": "User ID not found in token",
		})
		return
	}

	uploadID := c.Param("uploadId")
	if uploadID == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Missing uploadId parameter",
		})
		return
	}

	chunkedUploadsMutex.RLock()
	uploadInfo, exists := chunkedUploads[uploadID]
	chunkedUploadsMutex.RUnlock()

	if !exists {
		c.JSON(http.StatusNotFound, gin.H{
			"error": "Upload ID not found",
		})
		return
	}

	if uploadInfo.UserID != userID.(uint) {
		c.JSON(http.StatusForbidden, gin.H{
			"error": "You don't have permission to access this upload",
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"uploadId":       uploadID,
		"status":         uploadInfo.Status,
		"uploadedChunks": uploadInfo.UploadedChunks,
		"totalChunks":    uploadInfo.TotalChunks,
		"filename":       uploadInfo.Filename,
		"totalSize":      uploadInfo.TotalSize,
		"progress":       float64(uploadInfo.UploadedChunks) / float64(uploadInfo.TotalChunks) * 100,
	})
}

func assembleAndProcessFile(uploadInfo *ChunkedUploadInfo, jobID string, userID uint) {
	uploadJobsLock.Lock()
	uploadJobs[jobID] = UploadProgress{
		Status:    "assembling",
		Progress:  0,
		Message:   "Assembling file chunks",
		Filename:  uploadInfo.Filename,
		TotalSize: uploadInfo.TotalSize,
		JobID:     jobID,
	}
	uploadJobsLock.Unlock()

	chunkedUploadsMutex.Lock()
	uploadInfo.Status = "assembling"
	chunkedUploadsMutex.Unlock()

	if _, err := os.Stat(uploadInfo.TempDir); os.IsNotExist(err) {
		log.WithField("tempDir", uploadInfo.TempDir).Error("Temp directory doesn't exist")
		updateJobStatus(jobID, UploadProgress{
			Status:  "error",
			Error:   "Failed to locate temporary directory",
			Message: fmt.Sprintf("Directory %s doesn't exist", uploadInfo.TempDir),
		})
		return
	}

	finalFilePath := filepath.Join(uploadInfo.TempDir, uploadInfo.Filename)

	if _, err := os.Stat(finalFilePath); err == nil {
		log.WithField("finalFilePath", finalFilePath).Info("Final file already exists, removing it")
		if err := os.Remove(finalFilePath); err != nil {
			log.WithField("error", err.Error()).Error("Failed to remove existing final file")
			updateJobStatus(jobID, UploadProgress{
				Status:  "error",
				Error:   "Failed to prepare final file",
				Message: fmt.Sprintf("Failed to remove existing file: %s", err.Error()),
			})
			return
		}
	}

	finalFile, err := os.Create(finalFilePath)
	if err != nil {
		log.WithField("error", err.Error()).
			WithField("finalFilePath", finalFilePath).
			Error("Failed to create final file")
		updateJobStatus(jobID, UploadProgress{
			Status:  "error",
			Error:   "Failed to create final file",
			Message: err.Error(),
		})
		return
	}

	defer func() {
		if finalFile != nil {
			finalFile.Close()
		}
	}()

	totalBytesWritten := int64(0)
	missingChunks := false

	for i := 0; i < uploadInfo.TotalChunks; i++ {
		updateJobStatus(jobID, UploadProgress{
			Status:    "assembling",
			Progress:  int(float64(i) / float64(uploadInfo.TotalChunks) * 30), // Assembly = 0-30%
			Message:   fmt.Sprintf("Assembling chunks: %d/%d", i+1, uploadInfo.TotalChunks),
			Filename:  uploadInfo.Filename,
			TotalSize: uploadInfo.TotalSize,
		})

		chunkPath := filepath.Join(uploadInfo.TempDir, fmt.Sprintf("chunk_%d", i))

		if _, err := os.Stat(chunkPath); os.IsNotExist(err) {
			log.WithField("chunkPath", chunkPath).Error("Chunk file doesn't exist")
			missingChunks = true
			updateJobStatus(jobID, UploadProgress{
				Status:  "error",
				Error:   fmt.Sprintf("Missing chunk %d", i),
				Message: fmt.Sprintf("Chunk file %s doesn't exist", chunkPath),
			})
			return
		}

		chunkData, err := ioutil.ReadFile(chunkPath)
		if err != nil {
			log.WithField("error", err.Error()).
				WithField("chunkPath", chunkPath).
				Error("Failed to read chunk")
			updateJobStatus(jobID, UploadProgress{
				Status:  "error",
				Error:   fmt.Sprintf("Failed to read chunk %d", i),
				Message: err.Error(),
			})
			return
		}

		bytesWritten, err := finalFile.Write(chunkData)
		if err != nil {
			log.WithField("error", err.Error()).
				WithField("chunkPath", chunkPath).
				Error("Failed to write chunk to final file")
			updateJobStatus(jobID, UploadProgress{
				Status:  "error",
				Error:   fmt.Sprintf("Failed to write chunk %d to final file", i),
				Message: err.Error(),
			})
			return
		}

		totalBytesWritten += int64(bytesWritten)
	}

	if missingChunks {
		log.Error("Some chunks were missing, cannot assemble file")
		return
	}

	if totalBytesWritten != uploadInfo.TotalSize {
		log.WithField("expectedSize", uploadInfo.TotalSize).
			WithField("actualSize", totalBytesWritten).
			Error("Assembled file size mismatch")
		updateJobStatus(jobID, UploadProgress{
			Status:  "error",
			Error:   "Assembled file size mismatch",
			Message: fmt.Sprintf("Expected %d bytes but wrote %d bytes", uploadInfo.TotalSize, totalBytesWritten),
		})
		return
	}

	if err := finalFile.Sync(); err != nil {
		log.WithField("error", err.Error()).Error("Failed to sync final file")
		updateJobStatus(jobID, UploadProgress{
			Status:  "error",
			Error:   "Failed to sync final file",
			Message: err.Error(),
		})
		return
	}

	if err := finalFile.Close(); err != nil {
		log.WithField("error", err.Error()).Error("Failed to close final file")
		updateJobStatus(jobID, UploadProgress{
			Status:  "error",
			Error:   "Failed to close final file",
			Message: err.Error(),
		})
		return
	}

	finalFile = nil

	fileInfo, err := os.Stat(finalFilePath)
	if err != nil {
		log.WithField("error", err.Error()).
			WithField("finalFilePath", finalFilePath).
			Error("Failed to stat assembled file")
		updateJobStatus(jobID, UploadProgress{
			Status:  "error",
			Error:   "Failed to verify assembled file",
			Message: fmt.Sprintf("Error: %s", err.Error()),
		})
		return
	}

	if fileInfo.Size() != uploadInfo.TotalSize {
		log.WithField("expectedSize", uploadInfo.TotalSize).
			WithField("actualSize", fileInfo.Size()).
			Error("Final file size mismatch after stat")
		updateJobStatus(jobID, UploadProgress{
			Status:  "error",
			Error:   "Final file size mismatch",
			Message: fmt.Sprintf("Expected %d bytes but got %d bytes", uploadInfo.TotalSize, fileInfo.Size()),
		})
		return
	}

	updateJobStatus(jobID, UploadProgress{
		Status:    "processing",
		Progress:  30,
		Message:   "File assembled, starting processing",
		Filename:  uploadInfo.Filename,
		TotalSize: uploadInfo.TotalSize,
	})

	chunkedUploadsMutex.Lock()
	uploadInfo.Status = "processing"
	chunkedUploadsMutex.Unlock()

	log.WithField("finalFilePath", finalFilePath).
		WithField("fileSize", fileInfo.Size()).
		Info("File successfully assembled, proceeding to processing")

	fileHeader := &multipart.FileHeader{
		Filename: uploadInfo.Filename,
		Size:     uploadInfo.TotalSize,
		Header:   make(map[string][]string),
	}

	uploadPathsLock.Lock()
	filePaths[jobID] = finalFilePath
	log.WithField("jobID", jobID).
		WithField("finalFilePath", finalFilePath).
		Info("Storing file path for processing")
	uploadPathsLock.Unlock()

	uploadPathsLock.RLock()
	storedPath, pathExists := filePaths[jobID]
	uploadPathsLock.RUnlock()

	if !pathExists || storedPath != finalFilePath {
		log.WithField("jobID", jobID).
			WithField("expectedPath", finalFilePath).
			WithField("storedPath", storedPath).
			WithField("pathExists", pathExists).
			Error("File path was not stored correctly")
		updateJobStatus(jobID, UploadProgress{
			Status:  "error",
			Error:   "Internal error: file path not stored correctly",
			Message: "Please try again or contact support",
		})
		return
	}

	processUpload(jobID, fileHeader, userID, cfg.PdptoolPath)

	go func() {
		time.Sleep(5 * time.Second)

		uploadJobsLock.RLock()
		progress, exists := uploadJobs[jobID]
		uploadJobsLock.RUnlock()

		if exists && (progress.Status == "complete" || progress.Status == "error") {
			log.WithField("tempDir", uploadInfo.TempDir).Info("Cleaning up temp directory after completion")
			os.RemoveAll(uploadInfo.TempDir)

			uploadPathsLock.Lock()
			delete(filePaths, jobID)
			uploadPathsLock.Unlock()

			chunkedUploadsMutex.Lock()
			delete(chunkedUploads, uploadInfo.ID)
			chunkedUploadsMutex.Unlock()

			log.WithField("uploadId", uploadInfo.ID).
				WithField("jobId", jobID).
				Info("Cleaned up completed chunked upload")
		} else {
			log.WithField("uploadId", uploadInfo.ID).
				WithField("jobId", jobID).
				WithField("status", progress.Status).
				Info("Upload still in progress, will clean up later")

			go func() {
				cleanupTicker := time.NewTicker(10 * time.Second)
				defer cleanupTicker.Stop()

				for range cleanupTicker.C {
					uploadJobsLock.RLock()
					progress, exists := uploadJobs[jobID]
					uploadJobsLock.RUnlock()

					if !exists || progress.Status == "complete" || progress.Status == "error" {
						log.WithField("uploadId", uploadInfo.ID).
							WithField("jobId", jobID).
							Info("Cleaning up chunked upload in delayed cleanup")

						os.RemoveAll(uploadInfo.TempDir)

						uploadPathsLock.Lock()
						delete(filePaths, jobID)
						uploadPathsLock.Unlock()

						chunkedUploadsMutex.Lock()
						delete(chunkedUploads, uploadInfo.ID)
						chunkedUploadsMutex.Unlock()

						return
					}
				}
			}()
		}
	}()
}

var (
	filePaths       = make(map[string]string)
	uploadPathsLock sync.RWMutex
)

func updateJobStatus(jobID string, progress UploadProgress) {
	progress.JobID = jobID
	uploadJobsLock.Lock()
	uploadJobs[jobID] = progress
	uploadJobsLock.Unlock()
}
</file>

<file path="examples/hotvault-demo/server/internal/api/handlers/download.go">
package handlers

import (
	"bytes"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/hotvault/backend/internal/models"
)

// @Summary Download a file from PDP service
// @Description Download a file from the PDP service using its CID
// @Tags download
// @Accept json
// @Param cid path string true "CID of the file to download"
// @Produce octet-stream
// @Success 200 {file} binary "File content"
// @Router /api/v1/download/{cid} [get]
func DownloadFile(c *gin.Context) {
	if db == nil {
		log.Error("Database connection not initialized")
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Internal server error: database not initialized",
		})
		return
	}

	cid := c.Param("cid")
	if cid == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "CID is required",
		})
		return
	}

	var piece models.Piece
	if err := db.Where("c_id = ?", cid).First(&piece).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{
			"error": "Piece not found",
		})
		return
	}

	pdptoolPath := cfg.PdptoolPath
	if pdptoolPath == "" {
		log.Error("PDPTool path not configured in environment/config")
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Server configuration error: PDPTool path missing",
		})
		return
	}

	if _, err := os.Stat(pdptoolPath); os.IsNotExist(err) {
		log.WithField("path", pdptoolPath).Error("pdptool not found at configured path")
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "pdptool executable not found at configured path",
		})
		return
	}

	// Change working directory to pdptool directory
	pdptoolDir := getPdptoolParentDir(pdptoolPath)
	if err := os.Chdir(pdptoolDir); err != nil {
		log.Error(fmt.Sprintf("Failed to change working directory to pdptool directory: %v", err))
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to set working directory",
		})
		return
	}
	log.WithField("pdptoolDir", pdptoolDir).Info("Changed working directory to pdptool directory")

	log.WithField("path", pdptoolPath).Info("Using pdptool at path")

	processCid := cid
	if parts := strings.Split(cid, ":"); len(parts) > 0 {
		processCid = parts[0]
	}

	tempDir, err := os.MkdirTemp("", "pdp-download-*")
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": fmt.Sprintf("Failed to create temp directory: %v", err),
		})
		return
	}
	defer os.RemoveAll(tempDir)

	chunkFile := filepath.Join(tempDir, "chunks.txt")
	if err := os.WriteFile(chunkFile, []byte(processCid), 0644); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": fmt.Sprintf("Failed to create chunk file: %v", err),
		})
		return
	}

	outputFile := filepath.Join(tempDir, piece.Filename)
	downloadCmd := exec.Command(
		pdptoolPath,
		"download-file",
		"--service-url", piece.ServiceURL,
		"--chunk-file", chunkFile,
		"--output-file", outputFile,
	)

	log.WithField("command", "download-file").
		WithField("serviceURL", piece.ServiceURL).
		WithField("chunkFile", chunkFile).
		WithField("outputFile", outputFile).
		WithField("cid", cid).
		WithField("processCid", processCid).
		WithField("filename", piece.Filename).
		Info("Executing download-file command")

	var errOutput bytes.Buffer
	downloadCmd.Stderr = &errOutput

	if err := downloadCmd.Run(); err != nil {
		errorMsg := fmt.Sprintf("Failed to download file: %v", err)
		log.WithField("error", err.Error()).WithField("stderr", errOutput.String()).Error(errorMsg)

		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   errorMsg,
			"details": err.Error(),
			"stderr":  errOutput.String(),
		})
		return
	}

	file, err := os.Open(outputFile)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": fmt.Sprintf("Failed to open downloaded file: %v", err),
		})
		return
	}
	defer file.Close()

	fileInfo, err := file.Stat()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": fmt.Sprintf("Failed to get file info: %v", err),
		})
		return
	}

	c.Header("Content-Description", "File Transfer")
	c.Header("Content-Transfer-Encoding", "binary")
	c.Header("Content-Type", "application/octet-stream")
	c.Header("Content-Length", fmt.Sprintf("%d", fileInfo.Size()))
	encodedFilename := strings.ReplaceAll(piece.Filename, `"`, `\"`)
	c.Header("Content-Disposition", fmt.Sprintf(`attachment; filename="%s"`, encodedFilename))
	c.Header("Cache-Control", "private, no-cache, no-store, must-revalidate")
	c.Header("Pragma", "no-cache")
	c.Header("Expires", "0")

	if _, err := io.Copy(c.Writer, file); err != nil {
		log.WithField("error", err.Error()).Error("Failed to stream file to response")
		return
	}
}
</file>

<file path="examples/hotvault-demo/server/internal/api/handlers/health.go">
package handlers

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

type HealthResponse struct {
	Status string `json:"status" example:"ok"`
}

// HealthCheck godoc
// @Summary Health Check
// @Description Returns the health status of the API
// @Tags Health
// @Produce json
// @Success 200 {object} HealthResponse
// @Router /health [get]
func HealthCheck(c *gin.Context) {
	c.JSON(http.StatusOK, HealthResponse{
		Status: "ok",
	})
}

// NotFound godoc
// @Summary Not Found
// @Description Returns 404 Not Found error
// @Tags Error
// @Produce json
// @Success 404 {object} ErrorResponse
// @Router /404 [get]
func NotFound(c *gin.Context) {
	c.JSON(http.StatusNotFound, ErrorResponse{
		Error: "Resource not found",
	})
}
</file>

<file path="examples/hotvault-demo/server/internal/api/handlers/piece.go">
package handlers

import (
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/hotvault/backend/internal/models"
	"gorm.io/gorm"
)

type PieceResponse struct {
	ID                uint       `json:"id"`
	UserID            uint       `json:"userId"`
	CID               string     `json:"cid"`
	Filename          string     `json:"filename"`
	Size              int64      `json:"size"`
	ServiceName       string     `json:"serviceName"`
	ServiceURL        string     `json:"serviceUrl"`
	PendingRemoval    *bool      `json:"pendingRemoval,omitempty"`
	RemovalDate       *time.Time `json:"removalDate,omitempty"`
	ProofSetDbID      *uint      `json:"proofSetDbId,omitempty"`
	ServiceProofSetID *string    `json:"serviceProofSetId,omitempty"`
	RootID            *string    `json:"rootId,omitempty"`
	CreatedAt         time.Time  `json:"createdAt"`
	UpdatedAt         time.Time  `json:"updatedAt"`
}

type ProofSetsResponse struct {
	ProofSets []ProofSetWithPieces `json:"proofSets"`
	Pieces    []PieceResponse      `json:"pieces"`
}

type ProofSetWithPieces struct {
	ID              uint      `json:"id"`
	ProofSetID      string    `json:"proofSetId"`
	TransactionHash string    `json:"transactionHash"`
	ServiceName     string    `json:"serviceName"`
	ServiceURL      string    `json:"serviceUrl"`
	PieceIDs        []uint    `json:"pieceIds"`
	CreatedAt       time.Time `json:"createdAt"`
	UpdatedAt       time.Time `json:"updatedAt"`
}

// GetUserPieces returns all pieces for the authenticated user
// @Summary Get user's pieces
// @Description Get all pieces uploaded by the authenticated user, including service proof set ID
// @Tags pieces
// @Produce json
// @Success 200 {array} PieceResponse
// @Router /api/v1/pieces [get]
func GetUserPieces(c *gin.Context) {
	userID, exists := c.Get("userID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error": "User ID not found in token",
		})
		return
	}

	var pieces []models.Piece
	if err := db.Where("user_id = ?", userID).Order("created_at DESC").Find(&pieces).Error; err != nil {
		log.WithField("error", err.Error()).Error("Failed to fetch user pieces")
		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "Failed to fetch pieces",
			"details": err.Error(),
		})
		return
	}

	proofSetIDs := make([]uint, 0, len(pieces))
	for _, piece := range pieces {
		if piece.ProofSetID != nil {
			proofSetIDs = append(proofSetIDs, *piece.ProofSetID)
		}
	}

	proofSetMap := make(map[uint]models.ProofSet)
	if len(proofSetIDs) > 0 {
		var proofSets []models.ProofSet
		if err := db.Where("id IN ?", proofSetIDs).Find(&proofSets).Error; err != nil {
			log.WithField("error", err.Error()).Error("Failed to fetch associated proof sets for pieces")
		} else {
			for _, ps := range proofSets {
				proofSetMap[ps.ID] = ps
			}
		}
	}

	responsePieces := make([]PieceResponse, 0, len(pieces))
	for _, piece := range pieces {
		var pendingRemovalPtr *bool
		if piece.PendingRemoval {
			tempVal := true
			pendingRemovalPtr = &tempVal
		}

		respPiece := PieceResponse{
			ID:             piece.ID,
			UserID:         piece.UserID,
			CID:            piece.CID,
			Filename:       piece.Filename,
			Size:           piece.Size,
			ServiceName:    piece.ServiceName,
			ServiceURL:     piece.ServiceURL,
			PendingRemoval: pendingRemovalPtr,
			RemovalDate:    piece.RemovalDate,
			ProofSetDbID:   piece.ProofSetID,
			RootID:         piece.RootID,
			CreatedAt:      piece.CreatedAt,
			UpdatedAt:      piece.UpdatedAt,
		}
		if piece.ProofSetID != nil {
			if proofSet, ok := proofSetMap[*piece.ProofSetID]; ok {
				if proofSet.ProofSetID != "" {
					serviceID := proofSet.ProofSetID
					respPiece.ServiceProofSetID = &serviceID
				}
			}
		}
		responsePieces = append(responsePieces, respPiece)
	}

	c.JSON(http.StatusOK, responsePieces)
}

// GetPieceByID returns a specific piece by ID
// @Summary Get piece by ID
// @Description Get a specific piece by its ID
// @Tags pieces
// @Param id path string true "Piece ID"
// @Produce json
// @Success 200 {object} models.Piece
// @Router /api/v1/pieces/{id} [get]
func GetPieceByID(c *gin.Context) {
	userID, exists := c.Get("userID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error": "User ID not found in token",
		})
		return
	}

	pieceID := c.Param("id")
	var piece models.Piece

	if err := db.Where("id = ? AND user_id = ?", pieceID, userID).First(&piece).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{
				"error": "Piece not found",
			})
			return
		}
		log.WithField("error", err.Error()).Error("Failed to fetch piece")
		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "Failed to fetch piece",
			"details": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, piece)
}

// GetPieceByCID returns a specific piece by CID
// @Summary Get piece by CID
// @Description Get a specific piece by its CID
// @Tags pieces
// @Param cid path string true "Piece CID"
// @Produce json
// @Success 200 {object} models.Piece
// @Router /api/v1/pieces/cid/{cid} [get]
func GetPieceByCID(c *gin.Context) {
	userID, exists := c.Get("userID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error": "User ID not found in token",
		})
		return
	}

	cid := c.Param("cid")
	var piece models.Piece

	if err := db.Where("cid = ? AND user_id = ?", cid, userID).First(&piece).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{
				"error": "Piece not found",
			})
			return
		}
		log.WithField("error", err.Error()).Error("Failed to fetch piece")
		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "Failed to fetch piece",
			"details": err.Error(),
		})
		return
	}

	c.JSON(http.StatusOK, piece)
}

// GetProofSets returns all proof sets and associated pieces for the authenticated user
// @Summary Get user's proof sets
// @Description Get all proof sets and their pieces for the authenticated user
// @Tags pieces
// @Produce json
// @Success 200 {object} ProofSetsResponse
// @Router /api/v1/pieces/proof-sets [get]
func GetProofSets(c *gin.Context) {
	userID, exists := c.Get("userID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error": "User ID not found in token",
		})
		return
	}

	var pieces []models.Piece
	if err := db.Where("user_id = ?", userID).Order("created_at DESC").Find(&pieces).Error; err != nil {
		log.WithField("error", err.Error()).Error("Failed to fetch user pieces")
		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "Failed to fetch pieces",
			"details": err.Error(),
		})
		return
	}

	proofSetIDs := make([]uint, 0)
	for _, piece := range pieces {
		if piece.ProofSetID != nil {
			proofSetIDs = append(proofSetIDs, *piece.ProofSetID)
		}
	}

	if len(proofSetIDs) == 0 {
		c.JSON(http.StatusOK, ProofSetsResponse{
			ProofSets: []ProofSetWithPieces{},
			Pieces:    []PieceResponse{},
		})
		return
	}

	var proofSets []models.ProofSet
	if err := db.Where("id IN ?", proofSetIDs).Find(&proofSets).Error; err != nil {
		log.WithField("error", err.Error()).Error("Failed to fetch proof sets")
		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "Failed to fetch proof sets",
			"details": err.Error(),
		})
		return
	}

	piecesByProofSetID := make(map[uint][]uint)
	for _, piece := range pieces {
		if piece.ProofSetID != nil {
			piecesByProofSetID[*piece.ProofSetID] = append(piecesByProofSetID[*piece.ProofSetID], piece.ID)
		}
	}

	proofSetResponses := make([]ProofSetWithPieces, 0, len(proofSets))
	for _, ps := range proofSets {
		proofSetResponse := ProofSetWithPieces{
			ID:              ps.ID,
			ProofSetID:      ps.ProofSetID,
			TransactionHash: ps.TransactionHash,
			ServiceName:     ps.ServiceName,
			ServiceURL:      ps.ServiceURL,
			PieceIDs:        piecesByProofSetID[ps.ID],
			CreatedAt:       ps.CreatedAt,
			UpdatedAt:       ps.UpdatedAt,
		}
		proofSetResponses = append(proofSetResponses, proofSetResponse)
	}

	pieceResponses := make([]PieceResponse, 0, len(pieces))
	for _, piece := range pieces {
		var pendingRemovalPtr *bool
		if piece.PendingRemoval {
			tempVal := true
			pendingRemovalPtr = &tempVal
		}

		respPiece := PieceResponse{
			ID:             piece.ID,
			UserID:         piece.UserID,
			CID:            piece.CID,
			Filename:       piece.Filename,
			Size:           piece.Size,
			ServiceName:    piece.ServiceName,
			ServiceURL:     piece.ServiceURL,
			PendingRemoval: pendingRemovalPtr,
			RemovalDate:    piece.RemovalDate,
			ProofSetDbID:   piece.ProofSetID,
			RootID:         piece.RootID,
			CreatedAt:      piece.CreatedAt,
			UpdatedAt:      piece.UpdatedAt,
		}

		for _, ps := range proofSets {
			if piece.ProofSetID != nil && *piece.ProofSetID == ps.ID {
				serviceID := ps.ProofSetID
				respPiece.ServiceProofSetID = &serviceID
				break
			}
		}

		pieceResponses = append(pieceResponses, respPiece)
	}

	c.JSON(http.StatusOK, ProofSetsResponse{
		ProofSets: proofSetResponses,
		Pieces:    pieceResponses,
	})
}

// GetPieceProofs returns all pieces with proof information for the authenticated user
// @Summary Get user's pieces with proof data (DEPRECATED)
// @Description (DEPRECATED - Use /api/v1/pieces instead) Get all pieces with proof information
// @Tags pieces
// @Produce json
// @Success 200 {array} models.Piece
// @Router /api/v1/pieces/proofs [get]
func GetPieceProofs(c *gin.Context) {
	log.Warning("Deprecated endpoint /api/v1/pieces/proofs called. Use /api/v1/pieces.")
	c.JSON(http.StatusGone, gin.H{
		"error":   "Endpoint deprecated",
		"message": "Please use the /api/v1/pieces endpoint instead.",
	})
}

// @Summary Get User's Proof Set ID
// @Description Get the proof set ID for the authenticated user
// @Tags proofset
// @Produce json
// @Success 200 {object} map[string]string
// @Failure 401 {object} ErrorResponse
// @Failure 404 {object} ErrorResponse
// @Router /api/v1/proofset/id [get]
func GetUserProofSetID(c *gin.Context) {
	userID, exists := c.Get("userID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error": "User ID not found in token",
		})
		return
	}

	var proofSet models.ProofSet
	if err := db.Where("user_id = ?", userID).First(&proofSet).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{
				"error": "Proof set not found for user",
			})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to fetch proof set",
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"proofSetId": proofSet.ProofSetID,
	})
}
</file>

<file path="examples/hotvault-demo/server/internal/api/handlers/root.go">
package handlers

import (
	"bytes"
	"fmt"
	"net/http"
	"os"
	"os/exec"
	"strconv"

	"github.com/gin-gonic/gin"
	"github.com/hotvault/backend/internal/models"
	"gorm.io/gorm"
)

type RemoveRootRequest struct {
	PieceID     uint   `json:"pieceId" binding:"required"`
	ProofSetID  int    `json:"proofSetId"`
	ServiceURL  string `json:"serviceUrl"`
	ServiceName string `json:"serviceName"`
	RootID      string `json:"rootId"`
}

type ProofSet struct {
	ID        int      `json:"id"`
	ServiceID string   `json:"service_id"`
	RootIDs   []string `json:"root_ids"`
	Roots     []Root   `json:"roots"`
}

type Root struct {
	ID       string `json:"id"`
	CID      string `json:"cid"`
	PieceIDs []uint `json:"piece_ids"`
}

// @Summary Remove roots using pdptool
// @Description Remove a specific root from the PDP service
// @Tags roots
// @Accept json
// @Produce json
// @Param request body RemoveRootRequest true "Remove root request data"
// @Success 200 {object} map[string]interface{}
// @Router /api/v1/roots/remove [post]
func RemoveRoot(c *gin.Context) {
	if db == nil {
		log.Error("Database connection not initialized")
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Internal server error: database not initialized",
		})
		return
	}

	var request RemoveRootRequest
	if err := c.ShouldBindJSON(&request); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Invalid request: " + err.Error(),
		})
		return
	}

	userID, exists := c.Get("userID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error": "User ID not found in token",
		})
		return
	}

	var piece models.Piece
	if err := db.Where("id = ? AND user_id = ?", request.PieceID, userID).First(&piece).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{
				"error": "Piece not found or does not belong to the authenticated user",
			})
			return
		}
		log.WithField("error", err.Error()).WithField("pieceID", request.PieceID).Error("Failed to fetch piece")
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to fetch piece information: " + err.Error(),
		})
		return
	}

	if piece.ProofSetID == nil {
		log.WithField("pieceID", piece.ID).Error("Piece is missing associated ProofSetID")
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Internal error: Piece is missing required proof set data",
		})
		return
	}

	if piece.RootID == nil || *piece.RootID == "" {
		log.WithField("pieceID", piece.ID).Error("Piece is missing the stored Root ID")
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Internal error: Piece is missing the required Root ID",
		})
		return
	}

	var proofSet models.ProofSet
	if err := db.Where("id = ? AND user_id = ?", *piece.ProofSetID, userID).First(&proofSet).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			log.WithField("pieceID", piece.ID).WithField("proofSetDbId", *piece.ProofSetID).Error("Associated proof set record not found in DB")
			c.JSON(http.StatusNotFound, gin.H{
				"error": "Internal error: Associated proof set record not found for this piece",
			})
		} else {
			log.WithField("pieceID", piece.ID).WithField("proofSetDbId", *piece.ProofSetID).WithField("error", err).Error("Failed to fetch associated proof set record")
			c.JSON(http.StatusInternalServerError, gin.H{
				"error": "Failed to fetch proof set record: " + err.Error(),
			})
		}
		return
	}

	if proofSet.ProofSetID == "" {
		log.WithField("pieceID", piece.ID).WithField("proofSetDbId", proofSet.ID).Error("Fetched proof set record is missing the service ProofSetID string")
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Internal error: Proof set record is incomplete",
		})
		return
	}

	serviceURL := piece.ServiceURL
	serviceName := piece.ServiceName
	serviceProofSetIDStr := proofSet.ProofSetID
	storedIntegerRootIDStr := *piece.RootID

	if request.ServiceURL != "" {
		serviceURL = request.ServiceURL
		log.WithField("pieceID", piece.ID).Info("Overriding Service URL from request")
	}
	if request.ServiceName != "" {
		serviceName = request.ServiceName
		log.WithField("pieceID", piece.ID).Info("Overriding Service Name from request")
	}

	if _, err := strconv.Atoi(storedIntegerRootIDStr); err != nil {
		log.WithField("pieceID", piece.ID).WithField("storedRootID", storedIntegerRootIDStr).Error("Stored Root ID in piece record is not a valid integer string")
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Internal error: Invalid Root ID format stored for piece",
		})
		return
	}

	log.WithField("pieceID", piece.ID).
		WithField("serviceProofSetID", serviceProofSetIDStr).
		WithField("integerRootID", storedIntegerRootIDStr).
		Info("Proceeding with root removal using stored data")

	pdptoolPath := cfg.PdptoolPath
	if pdptoolPath == "" {
		log.Error("PDPTool path not configured in environment/config")
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Server configuration error: PDPTool path missing",
		})
		return
	}

	if _, err := os.Stat(pdptoolPath); os.IsNotExist(err) {
		log.WithField("path", pdptoolPath).Error("pdptool not found at configured path")
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "pdptool executable not found at configured path",
			"path":  pdptoolPath,
		})
		return
	}

	// Change working directory to pdptool directory
	pdptoolDir := getPdptoolParentDir(pdptoolPath)
	if err := os.Chdir(pdptoolDir); err != nil {
		log.Error(fmt.Sprintf("Failed to change working directory to pdptool directory: %v", err))
		c.JSON(http.StatusInternalServerError, gin.H{
			"error": "Failed to set working directory",
		})
		return
	}
	log.WithField("pdptoolDir", pdptoolDir).Info("Changed working directory to pdptool directory")

	if serviceURL == "" || serviceName == "" {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "Service URL and Service Name are required but missing from piece/proofset data",
		})
		return
	}

	removeArgs := []string{
		"remove-roots",
		"--service-url", serviceURL,
		"--service-name", serviceName,
		"--proof-set-id", serviceProofSetIDStr,
		"--root-id", storedIntegerRootIDStr,
	}
	removeCmd := exec.Command(pdptoolPath, removeArgs...)

	var stdout bytes.Buffer
	var stderr bytes.Buffer
	removeCmd.Stdout = &stdout
	removeCmd.Stderr = &stderr

	cmdStr := removeCmd.String()
	log.WithField("command", cmdStr).Info("Executing remove-roots command")

	if err := removeCmd.Run(); err != nil {
		errMsg := stderr.String()
		if errMsg == "" {
			errMsg = err.Error()
		}

		log.WithField("error", err.Error()).
			WithField("stderr", errMsg).
			WithField("command", cmdStr).
			Error("Failed to execute pdptool remove-roots command")

		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "Failed to remove root: " + errMsg,
			"details": err.Error(),
			"command": cmdStr,
		})
		return
	}

	log.WithField("output", stdout.String()).Info("pdptool remove-roots executed successfully")

	if err := db.Delete(&piece).Error; err != nil {
		log.WithField("pieceID", piece.ID).WithField("error", err.Error()).Error("Failed to delete piece from database after successful root removal")
		c.JSON(http.StatusOK, gin.H{
			"message": "Root removal command succeeded, but failed to delete piece record from DB",
			"output":  stdout.String(),
			"dbError": err.Error(),
		})
		return
	}

	log.WithField("pieceID", piece.ID).Info("Piece successfully deleted from database")

	c.JSON(http.StatusOK, gin.H{
		"message": "Root removed successfully and piece deleted",
		"output":  stdout.String(),
	})
}
</file>

<file path="examples/hotvault-demo/server/internal/api/handlers/upload.go">
package handlers

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"math/rand"
	"mime/multipart"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/hotvault/backend/config"
	"github.com/hotvault/backend/internal/models"
	"github.com/hotvault/backend/pkg/logger"
	"gorm.io/gorm"
)

var (
	log logger.Logger
	db  *gorm.DB
	cfg *config.Config
)

var (
	uploadJobs     = make(map[string]UploadProgress)
	uploadJobsLock sync.RWMutex
)

func init() {
	log = logger.NewLogger()
}

func formatFileSize(size int64) string {
	const unit = 1024
	if size < unit {
		return fmt.Sprintf("%d B", size)
	}
	div, exp := int64(unit), 0
	for n := size / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(size)/float64(div), "KMGTPE"[exp])
}

func getPdptoolParentDir(pdptoolPath string) string {
	// Get the directory containing the pdptool executable
	return filepath.Dir(pdptoolPath)
}

func Initialize(database *gorm.DB, appConfig *config.Config) {
	if database == nil {
		log.Error("Database connection is nil during initialization")
		return
	}
	if appConfig == nil {
		log.Error("App configuration is nil during initialization")
		return
	}
	db = database
	cfg = appConfig

	// Change working directory to pdptool directory
	if cfg.PdptoolPath != "" {
		pdptoolDir := getPdptoolParentDir(cfg.PdptoolPath)
		if err := os.Chdir(pdptoolDir); err != nil {
			log.Error(fmt.Sprintf("Failed to change working directory to pdptool directory: %v", err))
			return
		}
		log.WithField("pdptoolDir", pdptoolDir).Info("Changed working directory to pdptool directory")
	}

	log.Info("Upload handler initialized with database and configuration")
}

type UploadProgress struct {
	Status     string `json:"status"`
	Progress   int    `json:"progress,omitempty"`
	Message    string `json:"message,omitempty"`
	CID        string `json:"cid,omitempty"`
	Error      string `json:"error,omitempty"`
	Filename   string `json:"filename,omitempty"`
	TotalSize  int64  `json:"totalSize,omitempty"`
	JobID      string `json:"jobId,omitempty"`
	ProofSetID string `json:"proofSetId,omitempty"`
}

// @Summary Upload a file to PDP service
// @Description Upload a file to the PDP service with piece preparation and returns a job ID for status polling
// @Tags upload
// @Accept multipart/form-data
// @Param file formData file true "File to upload"
// @Produce json
// @Success 200 {object} UploadProgress
// @Router /api/v1/upload [post]
func UploadFile(c *gin.Context) {
	userID, exists := c.Get("userID")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{
			"error": "User ID not found in token",
		})
		return
	}
	const MAX_UPLOAD_SIZE = 10 * 1024 * 1024 * 1024
	c.Request.Body = http.MaxBytesReader(c.Writer, c.Request.Body, MAX_UPLOAD_SIZE)

	file, err := c.FormFile("file")
	if err != nil {
		var maxBytesError *http.MaxBytesError
		if errors.As(err, &maxBytesError) {
			c.JSON(http.StatusRequestEntityTooLarge, gin.H{
				"error":   "File too large",
				"message": fmt.Sprintf("Maximum file size is %s", formatFileSize(MAX_UPLOAD_SIZE)),
			})
			return
		}

		c.JSON(http.StatusBadRequest, gin.H{
			"error":   "Failed to get file from form",
			"message": err.Error(),
		})
		return
	}

	jobID := uuid.New().String()

	uploadJobsLock.Lock()
	uploadJobs[jobID] = UploadProgress{
		Status:    "uploading",
		Progress:  0,
		Message:   "Starting upload",
		Filename:  file.Filename,
		TotalSize: file.Size,
		JobID:     jobID,
	}
	uploadJobsLock.Unlock()

	pdptoolPath := cfg.PdptoolPath
	if _, err := os.Stat(pdptoolPath); os.IsNotExist(err) {
		log.WithField("pdptoolPath", pdptoolPath).Error("PDPTool executable not found")
		uploadJobsLock.Lock()
		uploadJobs[jobID] = UploadProgress{
			Status:  "error",
			Error:   "PDPTool executable not found",
			Message: fmt.Sprintf("File not found at %s", pdptoolPath),
		}
		uploadJobsLock.Unlock()
		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "PDPTool executable not found",
			"message": fmt.Sprintf("File not found at %s", pdptoolPath),
		})
		return
	}

	go processUpload(jobID, file, userID.(uint), pdptoolPath)

	c.JSON(http.StatusOK, gin.H{
		"message": "Upload started",
		"jobId":   jobID,
		"status":  "processing",
	})
}

// @Summary Get upload status
// @Description Get the status of an upload job
// @Tags upload
// @Produce json
// @Param jobId path string true "Job ID"
// @Success 200 {object} UploadProgress
// @Router /api/v1/upload/status/{jobId} [get]
func GetUploadStatus(c *gin.Context) {
	jobID := c.Param("jobId")

	uploadJobsLock.RLock()
	progress, exists := uploadJobs[jobID]
	uploadJobsLock.RUnlock()

	if !exists {
		c.JSON(http.StatusNotFound, gin.H{
			"error": "Upload job not found",
		})
		return
	}

	c.JSON(http.StatusOK, progress)
}

func processUpload(jobID string, file *multipart.FileHeader, userID uint, pdptoolPath string) {
	serviceName := cfg.ServiceName
	serviceURL := cfg.ServiceURL
	if serviceName == "" || serviceURL == "" {
		log.Error("Service Name or Service URL not configured")
		uploadJobsLock.Lock()
		progress := uploadJobs[jobID]
		progress.Status = "error"
		progress.Error = "Server configuration error: Service Name/URL missing"
		uploadJobs[jobID] = progress
		uploadJobsLock.Unlock()
		return
	}

	// Change working directory to pdptool directory
	pdptoolDir := getPdptoolParentDir(pdptoolPath)
	if err := os.Chdir(pdptoolDir); err != nil {
		log.Error(fmt.Sprintf("Failed to change working directory to pdptool directory: %v", err))
		uploadJobsLock.Lock()
		progress := uploadJobs[jobID]
		progress.Status = "error"
		progress.Error = "Failed to set working directory"
		uploadJobs[jobID] = progress
		uploadJobsLock.Unlock()
		return
	}
	log.WithField("pdptoolDir", pdptoolDir).Info("Changed working directory to pdptool directory")

	updateStatus := func(progress UploadProgress) {
		progress.JobID = jobID
		uploadJobsLock.Lock()
		uploadJobs[jobID] = progress
		uploadJobsLock.Unlock()
	}

	currentStage := "starting"
	currentProgress := 0

	prepareWeight := 20

	fileSizeMB := float64(file.Size) / (1024 * 1024)

	baseDelay := time.Duration(2+int(fileSizeMB/5)) * time.Second
	if baseDelay < 2*time.Second {
		baseDelay = 2 * time.Second
	}
	if baseDelay > 30*time.Second {
		baseDelay = 10 * time.Second
	}

	prepareTimeout := time.Duration(30+int(fileSizeMB*2)) * time.Second
	if prepareTimeout > 3600*time.Second {
		prepareTimeout = 3600 * time.Second
	}

	uploadTimeout := time.Duration(30+int(fileSizeMB*3)) * time.Second
	if uploadTimeout > 7200*time.Second {
		uploadTimeout = 7200 * time.Second
	}

	log.WithField("fileSize", file.Size).
		WithField("fileSizeMB", fileSizeMB).
		WithField("baseDelay", baseDelay).
		WithField("prepareTimeout", prepareTimeout).
		WithField("uploadTimeout", uploadTimeout).
		Info("Calculated timeouts for file processing")

	if _, err := os.Stat("pdpservice.json"); os.IsNotExist(err) {
		currentStage = "preparing"
		updateStatus(UploadProgress{
			Status:   "preparing",
			Progress: currentProgress,
			Message:  "Creating service secret",
		})

		createSecretCmd := exec.Command(pdptoolPath, "create-service-secret")
		var createSecretOutput bytes.Buffer
		var createSecretError bytes.Buffer
		createSecretCmd.Stdout = &createSecretOutput
		createSecretCmd.Stderr = &createSecretError
		if err := createSecretCmd.Run(); err != nil {
			updateStatus(UploadProgress{
				Status:  "error",
				Error:   "Failed to create service secret",
				Message: createSecretError.String(),
			})
			return
		}
		currentProgress += 5
	}

	uploadPathsLock.RLock()
	existingFilePath, hasExistingPath := filePaths[jobID]
	uploadPathsLock.RUnlock()

	var tempFilePath string
	if hasExistingPath {
		tempFilePath = existingFilePath
		log.WithField("path", tempFilePath).Info("Using existing file path from chunked upload")
	} else {
		tempDir, err := os.MkdirTemp("", fmt.Sprintf("upload-%s-", jobID))
		if err != nil {
			log.WithField("error", err.Error()).Error("Failed to create temporary directory")
			updateStatus(UploadProgress{
				Status:  "error",
				Error:   "Failed to create temporary directory",
				Message: err.Error(),
			})
			return
		}

		originalFilename := filepath.Base(file.Filename)
		tempFilePath = filepath.Join(tempDir, originalFilename)

		src, err := file.Open()
		if err != nil {
			log.WithField("error", err.Error()).
				WithField("filename", file.Filename).
				Error("Failed to open uploaded file")
			updateStatus(UploadProgress{
				Status:  "error",
				Error:   "Failed to open uploaded file",
				Message: err.Error(),
			})
			return
		}
		defer src.Close()

		dst, err := os.Create(tempFilePath)
		if err != nil {
			log.WithField("error", err.Error()).
				WithField("path", tempFilePath).
				Error("Failed to create temporary file")
			updateStatus(UploadProgress{
				Status:  "error",
				Error:   "Failed to create temporary file",
				Message: err.Error(),
			})
			return
		}

		written, err := io.Copy(dst, src)
		dst.Close()

		if err != nil {
			log.WithField("error", err.Error()).
				WithField("path", tempFilePath).
				Error("Failed to save uploaded file")
			updateStatus(UploadProgress{
				Status:  "error",
				Error:   "Failed to save uploaded file",
				Message: err.Error(),
			})
			os.RemoveAll(tempDir)
			return
		}

		if written != file.Size {
			err := fmt.Errorf("file size mismatch: expected %d bytes, wrote %d bytes", file.Size, written)
			log.WithField("error", err.Error()).
				WithField("path", tempFilePath).
				Error("Failed to save complete file")
			updateStatus(UploadProgress{
				Status:  "error",
				Error:   "Failed to save complete file",
				Message: err.Error(),
			})
			os.RemoveAll(tempDir)
			return
		}

		log.WithField("path", tempFilePath).
			WithField("size", formatFileSize(written)).
			Info("File saved to temporary location")
	}

	if _, err := os.Stat(tempFilePath); os.IsNotExist(err) {
		log.WithField("error", err.Error()).
			WithField("path", tempFilePath).
			Error("Temporary file does not exist after save")
		updateStatus(UploadProgress{
			Status:  "error",
			Error:   "Failed to verify temporary file",
			Message: fmt.Sprintf("File does not exist: %s", err.Error()),
		})
		return
	}

	currentProgress += 5
	currentStage = "preparing"

	updateStatus(UploadProgress{
		Status:   currentStage,
		Progress: currentProgress,
		Message:  "Preparing piece",
	})

	var prepareOutput bytes.Buffer
	var prepareError bytes.Buffer
	prepareCmd := exec.Command(pdptoolPath, "prepare-piece", tempFilePath)
	prepareCmd.Stdout = &prepareOutput
	prepareCmd.Stderr = &prepareError

	prepareCtx, prepareCancel := context.WithTimeout(context.Background(), prepareTimeout)
	defer prepareCancel()

	prepareCmdWithTimeout := exec.CommandContext(prepareCtx, pdptoolPath, "prepare-piece", tempFilePath)
	prepareCmdWithTimeout.Stdout = &prepareOutput
	prepareCmdWithTimeout.Stderr = &prepareError

	prepareDone := make(chan bool)
	go func() {
		prepareStartProgress := currentProgress
		for i := 0; i < prepareWeight; i++ {
			select {
			case <-prepareDone:
				return
			case <-time.After(100 * time.Millisecond):
				if currentProgress < prepareStartProgress+prepareWeight-1 {
					currentProgress++
					if i%5 == 0 {
						updateStatus(UploadProgress{
							Status:   currentStage,
							Progress: currentProgress,
							Message:  "Preparing piece data...",
						})
					}
				}
			}
		}
	}()

	if err := prepareCmdWithTimeout.Run(); err != nil {
		close(prepareDone)

		if prepareCtx.Err() == context.DeadlineExceeded {
			updateStatus(UploadProgress{
				Status:  "error",
				Error:   "Prepare piece command timed out",
				Message: fmt.Sprintf("Operation timed out after %v. Try a smaller file or contact support.", prepareTimeout),
			})
		} else {
			updateStatus(UploadProgress{
				Status:  "error",
				Error:   "Failed to prepare piece",
				Message: prepareError.String(),
			})
		}
		return
	}

	close(prepareDone)
	currentProgress = prepareWeight + 10
	currentStage = "uploading"

	updateStatus(UploadProgress{
		Status:   currentStage,
		Progress: currentProgress,
		Message:  fmt.Sprintf("Uploading file... (%.1f MB)", fileSizeMB),
	})

	time.Sleep(10 * time.Second)

	var uploadOutput bytes.Buffer
	var uploadError bytes.Buffer

	uploadArgs := []string{
		"upload-file",
		"--service-url", cfg.ServiceURL,
		"--service-name", cfg.ServiceName,
		tempFilePath,
	}

	uploadCmd := exec.Command(pdptoolPath, uploadArgs...)
	uploadCmd.Stdout = &uploadOutput
	uploadCmd.Stderr = &uploadError

	log.WithField("command", pdptoolPath).
		WithField("args", strings.Join(uploadArgs, " ")).
		WithField("fileSize", formatFileSize(file.Size)).
		WithField("timeout", "none").
		Info("Executing pdptool upload-file command")

	updateStatus(UploadProgress{
		Status:   currentStage,
		Progress: currentProgress,
		Message:  fmt.Sprintf("Uploading file... (%.1f MB)", fileSizeMB),
	})

	uploadRunErr := uploadCmd.Run()
	if uploadRunErr != nil {
		stderrStr := uploadError.String()
		stdoutStr := uploadOutput.String()

		log.WithField("error", uploadRunErr.Error()).
			WithField("stderr", stderrStr).
			WithField("stdout", stdoutStr).
			Error("Upload command failed")

		updateStatus(UploadProgress{
			Status:  "error",
			Error:   "Upload command failed",
			Message: stderrStr,
		})
		return
	}

	outputStr := uploadOutput.String()
	outputLines := strings.Split(outputStr, "\n")

	cidRegex := regexp.MustCompile(`^(baga[a-zA-Z0-9]+)(?::(baga[a-zA-Z0-9]+))?$`)
	var compoundCID string
	var baseCID string
	var subrootCID string

	for i := len(outputLines) - 1; i >= 0; i-- {
		trimmedLine := strings.TrimSpace(outputLines[i])
		if cidRegex.MatchString(trimmedLine) {
			matches := cidRegex.FindStringSubmatch(trimmedLine)
			if len(matches) > 1 {
				compoundCID = matches[0]
				baseCID = matches[1]
				if len(matches) > 2 && matches[2] != "" {
					subrootCID = matches[2]
				} else {
					subrootCID = baseCID
				}
				log.WithField("compoundCID", compoundCID).WithField("baseCID", baseCID).WithField("subrootCID", subrootCID).Info("Found and parsed CID in output lines")
				break
			}
		}
	}

	if compoundCID == "" {
		var lastNonEmpty string
		for i := len(outputLines) - 1; i >= 0; i-- {
			line := strings.TrimSpace(outputLines[i])
			if line != "" {
				lastNonEmpty = line
				break
			}
		}

		if lastNonEmpty != "" {
			log.WithField("lastLine", lastNonEmpty).Warning("Using last non-empty output line as CID (fallback, parsing may fail)")
			compoundCID = lastNonEmpty
			if idx := strings.Index(compoundCID, ":"); idx != -1 {
				baseCID = compoundCID[:idx]
			} else {
				baseCID = compoundCID
			}
			subrootCID = baseCID
		} else {
			log.Error("Upload completed but failed to extract CID from pdptool output.")
			updateStatus(UploadProgress{
				Status:  "error",
				Error:   "Failed to extract CID from upload response",
				Message: "Could not determine upload result CID.",
			})
			return
		}
	}

	log.WithField("uploadOutputCID", compoundCID).
		WithField("parsedBaseCID", baseCID).
		WithField("parsedSubrootCID", subrootCID).
		Info("CIDs extracted from upload-file output, before calling add-roots")

	log.WithField("filename", file.Filename).
		WithField("size", file.Size).
		WithField("service_name", serviceName).
		WithField("service_url", serviceURL).
		WithField("compoundCID", compoundCID).
		Info("File uploaded successfully, proceeding to add root")

	currentProgress = 95
	currentStage = "adding_root"
	updateStatus(UploadProgress{
		Status:   currentStage,
		Progress: currentProgress,
		Message:  "Finding or creating a proof set for your file...",
		CID:      compoundCID,
	})

	// Reduced delay before adding root
	preAddRootDelay := 1 * time.Second
	log.Info(fmt.Sprintf("Waiting %v before adding root to allow service registration...", preAddRootDelay))
	time.Sleep(preAddRootDelay)

	var proofSet models.ProofSet
	if err := db.Where("user_id = ?", userID).First(&proofSet).Error; err != nil {
		errMsg := "Failed to query proof set for user."
		if err == gorm.ErrRecordNotFound {
			errMsg = "Proof set not found for user. Please re-authenticate."
			log.WithField("userID", userID).Error(errMsg)
		} else {
			log.WithField("userID", userID).WithField("error", err).Error("Database error fetching proof set")
		}
		updateStatus(UploadProgress{
			Status:  "error",
			Error:   errMsg,
			Message: "Upload cannot proceed without a valid proof set.",
			CID:     compoundCID,
		})
		return
	}

	if proofSet.ProofSetID == "" {
		errMsg := "Proof set creation is still pending. Please wait."
		log.WithField("userID", userID).WithField("dbProofSetID", proofSet.ID).Warning(errMsg)
		updateStatus(UploadProgress{
			Status:     "pending",
			Error:      errMsg,
			Message:    "The proof set is being initialized. Please try uploading again shortly.",
			CID:        compoundCID,
			ProofSetID: proofSet.ProofSetID,
		})
		return
	}

	log.WithField("userID", userID).WithField("serviceProofSetID", proofSet.ProofSetID).Info("Found ready proof set for user, proceeding to add root")

	updateStatus(UploadProgress{
		Status:     currentStage,
		Progress:   currentProgress,
		Message:    fmt.Sprintf("Adding root to proof set %s...", proofSet.ProofSetID),
		CID:        compoundCID,
		ProofSetID: proofSet.ProofSetID,
	})

	rootArgument := compoundCID
	addRootsArgs := []string{
		"add-roots",
		"--service-url", cfg.ServiceURL,
		"--service-name", cfg.ServiceName,
		"--proof-set-id", proofSet.ProofSetID,
		"--root", rootArgument,
	}

	log.WithField("add-roots-args", strings.Join(addRootsArgs, " ")).Info("Adding root to proof set")

	cmdDir := pdptoolDir
	secretPath := filepath.Join(cmdDir, "pdpservice.json")
	log.WithField("expectedCmdDir", cmdDir).Info("Checking command working directory")
	log.WithField("checkingSecretPath", secretPath).Info("Checking for pdpservice.json")
	if _, errStat := os.Stat(secretPath); errStat == nil {
		log.Info("pdpservice.json FOUND at the expected location.")
	} else if os.IsNotExist(errStat) {
		log.Error("pdpservice.json NOT FOUND at the expected location.")
	} else {
		log.WithField("error", errStat.Error()).Error("Error checking for pdpservice.json")
	}

	maxRetries := 100
	backoff := 10 * time.Second
	maxBackoff := 10 * time.Second
	success := false

	for attempt := 1; attempt <= maxRetries; attempt++ {
		if attempt > 1 {
			time.Sleep(backoff)
		}

		log.WithField("command", pdptoolPath).
			WithField("args", strings.Join(addRootsArgs, " ")).
			WithField("attempt", attempt).
			WithField("maxRetries", maxRetries).
			Info("Executing add-roots command")

		updateStatus(UploadProgress{
			Status:     currentStage,
			Progress:   currentProgress,
			Message:    "Adding root to proof...",
			CID:        compoundCID,
			ProofSetID: proofSet.ProofSetID,
		})

		addRootCmd := exec.Command(pdptoolPath, addRootsArgs...)
		var addRootOutput bytes.Buffer
		var addRootError bytes.Buffer
		addRootCmd.Stdout = &addRootOutput
		addRootCmd.Stderr = &addRootError

		ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
		defer cancel()

		cmdWithTimeout := exec.CommandContext(ctx, pdptoolPath, addRootsArgs...)
		cmdWithTimeout.Dir = pdptoolDir
		cmdWithTimeout.Stdout = &addRootOutput
		cmdWithTimeout.Stderr = &addRootError

		if err := cmdWithTimeout.Run(); err != nil {
			stderrStr := addRootError.String()
			stdoutStr := addRootOutput.String()

			if ctx.Err() == context.DeadlineExceeded {
				log.WithField("attempt", attempt).
					WithField("maxRetries", maxRetries).
					Error("Command execution timed out after 60 seconds")

				if attempt < maxRetries {
					updateStatus(UploadProgress{
						Status:     currentStage,
						Progress:   currentProgress,
						Message:    fmt.Sprintf("Command timed out. Retrying %d/%d...", attempt+1, maxRetries),
						CID:        compoundCID,
						ProofSetID: proofSet.ProofSetID,
					})

					time.Sleep(backoff)

					backoff *= 2
					if backoff > maxBackoff {
						backoff = maxBackoff
					}
					continue
				} else {
					updateStatus(UploadProgress{
						Status:     "error",
						Error:      "Command timed out after multiple attempts",
						Message:    "The service took too long to respond. Please try again later.",
						CID:        compoundCID,
						ProofSetID: proofSet.ProofSetID,
					})
					return
				}
			}

			log.WithField("error", err.Error()).
				WithField("stderr", stderrStr).
				WithField("stdout", stdoutStr).
				WithField("commandArgs", strings.Join(addRootsArgs, " ")).
				WithField("attempt", attempt).
				WithField("maxRetries", maxRetries).
				Error("pdptool add-roots command failed")

			shouldRetry := false

			if strings.Contains(stderrStr, "subroot CID") && strings.Contains(stderrStr, "not found or does not belong to service") {
				shouldRetry = true
			} else if strings.Contains(stderrStr, "Size must be a multiple of 32") {
				shouldRetry = true
			} else if strings.Contains(stderrStr, "Failed to send transaction") {
				shouldRetry = true
			} else if strings.Contains(stderrStr, "status code 500") || strings.Contains(stderrStr, "status code 400") {
				shouldRetry = true
			} else if strings.Contains(stderrStr, "Failed to retrieve next challenge epoch") ||
				strings.Contains(stderrStr, "can't scan NULL into") {
				shouldRetry = true
			} else if strings.Contains(stderrStr, "not found") {
				shouldRetry = true
			} else if strings.Contains(stderrStr, "can't add root to non-existing proof set") {
				shouldRetry = true
			} else {
				shouldRetry = true
			}

			if shouldRetry && attempt < maxRetries {
				retryDelay := backoff + time.Duration(rand.Int63n(int64(backoff/2)))
				log.WithField("retryDelay", retryDelay.String()).Info("Waiting before retry")
				time.Sleep(retryDelay)
				backoff *= 2
				if backoff > maxBackoff {
					backoff = maxBackoff
				}
				continue
			}

			if attempt >= maxRetries {
				updateStatus(UploadProgress{
					Status:     "error",
					Error:      "Failed to add root to proof set after multiple attempts",
					Message:    stderrStr,
					CID:        compoundCID,
					ProofSetID: proofSet.ProofSetID,
				})
				return
			}

			updateStatus(UploadProgress{
				Status:     "error",
				Error:      "Failed to add root to proof set",
				Message:    stderrStr,
				CID:        compoundCID,
				ProofSetID: proofSet.ProofSetID,
			})
			return
		}

		addRootStderrStrOnSuccess := addRootError.String()
		if addRootStderrStrOnSuccess != "" {
			log.WithField("stderr", addRootStderrStrOnSuccess).Warning("add-roots command succeeded but produced output on stderr")
		}

		addRootStdoutStr := addRootOutput.String()
		log.WithField("proofSetID", proofSet.ProofSetID).
			WithField("rootUsed", rootArgument).
			WithField("stdout", addRootStdoutStr).
			WithField("attempt", attempt).
			Info("add-roots command completed successfully")

		success = true
		break
	}

	if !success {
		updateStatus(UploadProgress{
			Status:     "error",
			Error:      "Failed to add root to proof set after multiple attempts",
			Message:    "Service did not accept the root after multiple attempts.",
			CID:        compoundCID,
			ProofSetID: proofSet.ProofSetID,
		})
		return
	}

	currentProgress = 96
	currentStage = "finalizing"
	updateStatus(UploadProgress{
		Status:     currentStage,
		Progress:   currentProgress,
		Message:    "Confirming Root ID assignment...",
		CID:        compoundCID,
		ProofSetID: proofSet.ProofSetID,
	})

	var extractedIntegerRootID string
	pollInterval := 10 * time.Second
	maxPollInterval := 10 * time.Second
	maxPollAttempts := 100
	pollAttempt := 0
	foundRootInPoll := false
	consecutiveErrors := 0
	maxConsecutiveErrors := 10

	for pollAttempt < maxPollAttempts {
		if pollAttempt > 0 {
			log.Info("Applying fixed 30-second delay before poll attempt")
			time.Sleep(10 * time.Second)
		}

		pollAttempt++

		if pollAttempt%5 == 0 {
			updateStatus(UploadProgress{
				Status:     currentStage,
				Progress:   currentProgress,
				Message:    "Waiting for blockchain confirmation...",
				CID:        compoundCID,
				ProofSetID: proofSet.ProofSetID,
			})
		}

		log.Info(fmt.Sprintf("Polling get-proof-set attempt %d/%d...", pollAttempt, maxPollAttempts))

		getProofSetArgs := []string{
			"get-proof-set",
			"--service-url", cfg.ServiceURL,
			"--service-name", cfg.ServiceName,
			proofSet.ProofSetID,
		}
		getProofSetCmd := exec.Command(pdptoolPath, getProofSetArgs...)
		var getProofSetStdout bytes.Buffer
		var getProofSetStderr bytes.Buffer
		getProofSetCmd.Stdout = &getProofSetStdout
		getProofSetCmd.Stderr = &getProofSetStderr

		log.WithField("command", pdptoolPath).WithField("args", strings.Join(getProofSetArgs, " ")).Debug(fmt.Sprintf("Executing get-proof-set poll attempt %d", pollAttempt))

		if err := getProofSetCmd.Run(); err != nil {
			stderrStr := getProofSetStderr.String()
			log.WithField("error", err.Error()).
				WithField("stderr", stderrStr).
				Warning(fmt.Sprintf("pdptool get-proof-set command failed during poll attempt %d. Retrying after %v...", pollAttempt, pollInterval))

			consecutiveErrors++

			if strings.Contains(stderrStr, "Failed to retrieve next challenge epoch") ||
				strings.Contains(stderrStr, "can't scan NULL into") {

				log.Info("Detected proof set initialization error, this is normal during proof set creation")

				if consecutiveErrors > 5 {
					if pollInterval < maxPollInterval {
						pollInterval += time.Second
					}
				}

				time.Sleep(pollInterval)
				continue
			}

			if consecutiveErrors > maxConsecutiveErrors {
				log.Warning(fmt.Sprintf("Received %d consecutive errors while polling for root ID", consecutiveErrors))

				if pollInterval < maxPollInterval {
					pollInterval *= 2
					if pollInterval > maxPollInterval {
						pollInterval = maxPollInterval
					}
				}
			}

			time.Sleep(pollInterval)
			continue
		}

		consecutiveErrors = 0

		getProofSetOutput := getProofSetStdout.String()
		log.WithField("output", getProofSetOutput).Debug(fmt.Sprintf("get-proof-set poll attempt %d output received", pollAttempt))

		if strings.Contains(getProofSetOutput, "Roots:") && !strings.Contains(getProofSetOutput, "Root ID:") {
			log.Debug("Found proof set but no roots listed yet. Continuing to poll...")
			time.Sleep(pollInterval)
			continue
		}

		lines := strings.Split(getProofSetOutput, "\n")
		var lastSeenRootID string
		foundMatchThisAttempt := false
		sawAnyRootID := false

		for _, line := range lines {
			trimmedLine := strings.TrimSpace(line)
			if trimmedLine == "" {
				continue
			}

			if idx := strings.Index(trimmedLine, "Root ID:"); idx != -1 {
				sawAnyRootID = true
				potentialIDValue := strings.TrimSpace(trimmedLine[idx+len("Root ID:"):])
				log.Debug(fmt.Sprintf("[Parsing] Found line containing 'Root ID:', potential value: '%s'", potentialIDValue))
				if _, err := strconv.Atoi(potentialIDValue); err == nil {
					lastSeenRootID = potentialIDValue
					log.Debug(fmt.Sprintf("[Parsing] Captured integer Root ID: %s", lastSeenRootID))
				} else {
					lastSeenRootID = ""
					log.Debug(fmt.Sprintf("[Parsing] Found 'Root ID:' but value '%s' is not integer, resetting lastSeenRootID", potentialIDValue))
				}
			}

			if idx := strings.Index(trimmedLine, "Root CID:"); idx != -1 {
				outputCID := strings.TrimSpace(trimmedLine[idx+len("Root CID:"):])
				log.Debug(fmt.Sprintf("[Parsing] Found line containing 'Root CID:', value: '%s'", outputCID))
				if outputCID == baseCID {
					log.Debug(fmt.Sprintf("[Parsing] CID '%s' matches baseCID '%s'. Checking lastSeenRootID ('%s')...", outputCID, baseCID, lastSeenRootID))
					if lastSeenRootID != "" {
						extractedIntegerRootID = lastSeenRootID
						log.WithField("integerRootID", extractedIntegerRootID).WithField("matchedBaseCID", baseCID).Info(fmt.Sprintf("Successfully matched base CID and found associated integer Root ID on poll attempt %d", pollAttempt))
						foundMatchThisAttempt = true
						break
					} else {
						log.WithField("matchedBaseCID", baseCID).Warning(fmt.Sprintf("Matched base CID on poll attempt %d but no preceding integer Root ID was captured (lastSeenRootID was empty)", pollAttempt))
					}
				}
			}
		}

		if foundMatchThisAttempt {
			foundRootInPoll = true
			break
		}

		if sawAnyRootID {
			log.Info("Proof set has roots, but none matching our CID yet. Polling again.")
			pollInterval = 10 * time.Second
		}

		log.Debug(fmt.Sprintf("Root CID %s not found in get-proof-set output on attempt %d. Waiting %v...", baseCID, pollAttempt, pollInterval))
		time.Sleep(pollInterval)
	}

	if !foundRootInPoll && consecutiveErrors < maxConsecutiveErrors {
		log.WithField("baseCID", baseCID).
			WithField("proofSetID", proofSet.ProofSetID).
			WithField("attempts", maxPollAttempts).
			Warning("Failed to find integer Root ID in get-proof-set output after polling. Using fallback Root ID.")

		extractedIntegerRootID = "1"
		foundRootInPoll = true

		updateStatus(UploadProgress{
			Status:     currentStage,
			Progress:   98,
			Message:    "Using default Root ID due to blockchain indexing delay.",
			CID:        compoundCID,
			ProofSetID: proofSet.ProofSetID,
		})
	} else if !foundRootInPoll {
		log.WithField("baseCID", baseCID).
			WithField("proofSetID", proofSet.ProofSetID).
			WithField("attempts", maxPollAttempts).
			Error("Failed to find integer Root ID in get-proof-set output after polling.")
		updateStatus(UploadProgress{
			Status:     "error",
			Progress:   98,
			Message:    "Error: Could not confirm integer Root ID assignment after polling.",
			Error:      fmt.Sprintf("Polling for Root ID timed out after %d attempts", maxPollAttempts),
			CID:        compoundCID,
			ProofSetID: proofSet.ProofSetID,
		})
		return
	}

	currentProgress = 98
	rootIDToSave := extractedIntegerRootID

	updateStatus(UploadProgress{
		Status:     currentStage,
		Progress:   currentProgress,
		Message:    "Saving piece information to database...",
		CID:        compoundCID,
		ProofSetID: proofSet.ProofSetID,
	})

	piece := &models.Piece{
		UserID:      userID,
		CID:         compoundCID,
		Filename:    file.Filename,
		Size:        file.Size,
		ServiceName: cfg.ServiceName,
		ServiceURL:  cfg.ServiceURL,
		ProofSetID:  &proofSet.ID,
		RootID:      &rootIDToSave,
	}

	if result := db.Create(piece); result.Error != nil {
		log.WithField("error", result.Error.Error()).Error("Failed to save piece information")
		updateStatus(UploadProgress{
			Status:     "error",
			Error:      "Failed to save piece information to database",
			Message:    result.Error.Error(),
			CID:        compoundCID,
			ProofSetID: proofSet.ProofSetID,
		})
		return
	}

	log.WithField("pieceId", piece.ID).WithField("integerRootID", rootIDToSave).Info("Piece information saved successfully with integer Root ID")

	currentProgress = 100

	updateStatus(UploadProgress{
		Status:     "complete",
		Progress:   currentProgress,
		Message:    "Upload completed successfully",
		CID:        compoundCID,
		Filename:   file.Filename,
		ProofSetID: proofSet.ProofSetID,
	})

	go func() {
		var tempDir string

		if !hasExistingPath && tempFilePath != "" {
			tempDir = filepath.Dir(tempFilePath)
		}

		time.Sleep(1 * time.Hour)

		uploadJobsLock.Lock()
		delete(uploadJobs, jobID)
		uploadJobsLock.Unlock()

		if tempDir != "" && !hasExistingPath {
			log.WithField("jobID", jobID).
				WithField("tempDir", tempDir).
				Info("Cleaning up temporary directory after successful upload")
			os.RemoveAll(tempDir)
		}
	}()
}
</file>

<file path="examples/hotvault-demo/server/internal/api/middleware/jwt.go">
package middleware

import (
	"errors"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	"github.com/hotvault/backend/internal/models"
)

func JWTAuth(secret string) gin.HandlerFunc {
	return func(c *gin.Context) {
		var tokenString string
		var err error

		tokenString, err = c.Cookie("jwt_token")

		if err != nil {
			authHeader := c.GetHeader("Authorization")
			if authHeader == "" {
				c.JSON(http.StatusUnauthorized, gin.H{"error": "Authentication required"})
				c.Abort()
				return
			}

			parts := strings.SplitN(authHeader, " ", 2)
			if !(len(parts) == 2 && parts[0] == "Bearer") {
				c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header format must be Bearer {token}"})
				c.Abort()
				return
			}

			tokenString = parts[1]
		}

		claims := &models.JWTClaims{}
		token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, errors.New("unexpected signing method")
			}
			return []byte(secret), nil
		})

		if err != nil || !token.Valid {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or expired token"})
			c.Abort()
			return
		}

		c.Set("userID", claims.UserID)
		c.Set("walletAddress", claims.WalletAddress)

		c.Next()
	}
}
</file>

<file path="examples/hotvault-demo/server/internal/api/routes/routes.go">
package routes

import (
	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"github.com/hotvault/backend/config"
	_ "github.com/hotvault/backend/docs" // This line is needed for swagger
	"github.com/hotvault/backend/internal/api/handlers"
	"github.com/hotvault/backend/internal/api/middleware"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
	"gorm.io/gorm"
)

// @title Hot Vault Backend API
// @version 1.0
// @description API Server for Hot Vault Backend Application
// @host localhost:8080
// @BasePath /api/v1

func SetupRoutes(router *gin.Engine, db *gorm.DB, cfg *config.Config) {
	handlers.Initialize(db, cfg)

	router.MaxMultipartMemory = 1000 << 20 // 1000 MB

	router.Use(cors.New(cors.Config{
		AllowOrigins:     []string{"http://localhost:3000", "https://hotvault-demo-app.yourdomain.com"},
		AllowMethods:     []string{"GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"},
		AllowHeaders:     []string{"Origin", "Content-Type", "Accept", "Authorization"},
		ExposeHeaders:    []string{"Content-Length"},
		AllowCredentials: true,
		MaxAge:           12 * 60 * 60,
	}))

	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	authHandler := handlers.NewAuthHandler(db, cfg)

	v1 := router.Group("/api/v1")
	{
		v1.GET("/health", handlers.HealthCheck)

		auth := v1.Group("/auth")
		{
			auth.POST("/nonce", authHandler.GenerateNonce)
			auth.POST("/verify", authHandler.VerifySignature)
			auth.GET("/status", authHandler.CheckAuthStatus)
			auth.POST("/logout", authHandler.Logout)
		}

		protected := v1.Group("")
		protected.Use(middleware.JWTAuth(cfg.JWT.Secret))
		{
			protected.POST("/upload", handlers.UploadFile)
			protected.GET("/upload/status/:jobId", handlers.GetUploadStatus)
			protected.GET("/download/:cid", handlers.DownloadFile)

			chunkedUpload := protected.Group("/chunked-upload")
			{
				chunkedUpload.POST("/init", handlers.InitChunkedUpload)
				chunkedUpload.POST("/chunk", handlers.UploadChunk)
				chunkedUpload.POST("/complete", handlers.CompleteChunkedUpload)
				chunkedUpload.GET("/status/:uploadId", handlers.GetChunkedUploadStatus)
			}

			pieces := protected.Group("/pieces")
			{
				pieces.GET("", handlers.GetUserPieces)
				pieces.GET("/proof-sets", handlers.GetProofSets)
				pieces.GET("/:id", handlers.GetPieceByID)
				pieces.GET("/cid/:cid", handlers.GetPieceByCID)
				pieces.GET("/proofs", handlers.GetPieceProofs)
			}

			proofset := protected.Group("/proofset")
			{
				proofset.GET("/id", handlers.GetUserProofSetID)
			}

			protected.POST("/proof-set/create", authHandler.CreateProofSet)

			roots := protected.Group("/roots")
			{
				roots.POST("/remove", handlers.RemoveRoot)
			}
		}
	}

	router.NoRoute(handlers.NotFound)
}
</file>

<file path="examples/hotvault-demo/server/internal/database/migration.go">
package database

import (
	"github.com/hotvault/backend/internal/models"
	"gorm.io/gorm"
)

func MigrateDB(db *gorm.DB) error {
	return db.AutoMigrate(
		&models.User{},
		&models.Wallet{},
		&models.Transaction{},
		&models.ProofSet{},
		&models.Piece{},
	)
}
</file>

<file path="examples/hotvault-demo/server/internal/database/postgres.go">
package database

import (
	"fmt"

	"github.com/hotvault/backend/config"
	applogger "github.com/hotvault/backend/pkg/logger"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
	gormlogger "gorm.io/gorm/logger"
)

func NewPostgresConnection(cfg config.DatabaseConfig) (*gorm.DB, error) {
	dsn := fmt.Sprintf(
		"host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
		cfg.Host, cfg.Port, cfg.User, cfg.Password, cfg.DBName, cfg.SSLMode,
	)

	loggingConfig := applogger.GetLoggingConfig()

	logLevel := gormlogger.Info
	if loggingConfig.DisableGORMLogging {
		logLevel = gormlogger.Silent
	} else if loggingConfig.ProductionMode {
		logLevel = gormlogger.Error
	}

	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{
		Logger: gormlogger.Default.LogMode(logLevel),
	})
	if err != nil {
		return nil, err
	}

	return db, nil
}
</file>

<file path="examples/hotvault-demo/server/internal/models/piece.go">
package models

import (
	"time"

	"gorm.io/gorm"
)

type Piece struct {
	ID             uint           `gorm:"primaryKey" json:"id"`
	UserID         uint           `gorm:"index;not null" json:"userId"`
	CID            string         `gorm:"not null" json:"cid"`
	Filename       string         `gorm:"not null" json:"filename"`
	Size           int64          `json:"size"`
	ServiceName    string         `gorm:"not null" json:"serviceName"`
	ServiceURL     string         `gorm:"not null" json:"serviceUrl"`
	PendingRemoval bool           `gorm:"default:false" json:"pendingRemoval"`
	RemovalDate    *time.Time     `json:"removalDate"`
	ProofSetID     *uint          `json:"proofSetId"`
	RootID         *string        `json:"rootId"`
	CreatedAt      time.Time      `json:"createdAt"`
	UpdatedAt      time.Time      `json:"updatedAt"`
	DeletedAt      gorm.DeletedAt `gorm:"index" json:"-"`
	User           User           `gorm:"foreignKey:UserID" json:"user,omitempty"`
}
</file>

<file path="examples/hotvault-demo/server/internal/models/proofset.go">
package models

import (
	"time"

	"gorm.io/gorm"
)

type ProofSet struct {
	ID              uint           `gorm:"primaryKey" json:"id"`
	UserID          uint           `gorm:"index;not null" json:"userId"`
	ProofSetID      string         `gorm:"not null" json:"proofSetId"`
	TransactionHash string         `gorm:"not null" json:"transactionHash"`
	ServiceName     string         `gorm:"not null" json:"serviceName"`
	ServiceURL      string         `gorm:"not null" json:"serviceUrl"`
	Pieces          []Piece        `gorm:"foreignKey:ProofSetID" json:"pieces,omitempty"`
	CreatedAt       time.Time      `json:"createdAt"`
	UpdatedAt       time.Time      `json:"updatedAt"`
	DeletedAt       gorm.DeletedAt `gorm:"index" json:"-"`
	User            User           `gorm:"foreignKey:UserID" json:"user,omitempty"`
}
</file>

<file path="examples/hotvault-demo/server/internal/models/transaction.go">
package models

import (
	"time"

	"gorm.io/gorm"
)

type Transaction struct {
	ID            uint           `gorm:"primaryKey" json:"id"`
	UserID        uint           `gorm:"not null" json:"userId"`
	TxHash        string         `gorm:"uniqueIndex;not null" json:"txHash"`
	Method        string         `gorm:"not null" json:"method"`
	Status        string         `gorm:"not null" json:"status"`
	Value         string         `json:"value"`
	BlockHash     string         `json:"blockHash"`
	BlockNumber   uint64         `json:"blockNumber"`
	WalletAddress string         `gorm:"not null" json:"walletAddress"`
	CreatedAt     time.Time      `json:"createdAt"`
	UpdatedAt     time.Time      `json:"updatedAt"`
	DeletedAt     gorm.DeletedAt `gorm:"index" json:"-"`
}
</file>

<file path="examples/hotvault-demo/server/internal/models/user.go">
package models

import (
	"time"

	"github.com/golang-jwt/jwt/v5"
	"gorm.io/gorm"
)

type User struct {
	ID            uint           `gorm:"primaryKey" json:"id"`
	WalletAddress string         `gorm:"uniqueIndex;not null" json:"walletAddress"`
	Nonce         string         `gorm:"not null" json:"nonce"`
	Username      string         `json:"username"`
	Email         string         `json:"email"`
	CreatedAt     time.Time      `json:"createdAt"`
	UpdatedAt     time.Time      `json:"updatedAt"`
	DeletedAt     gorm.DeletedAt `gorm:"index" json:"-"`
	Wallets       []Wallet       `gorm:"foreignKey:UserID" json:"wallets,omitempty"`
	Transactions  []Transaction  `gorm:"foreignKey:UserID" json:"transactions,omitempty"`
}

type JWTClaims struct {
	UserID        uint   `json:"userId"`
	WalletAddress string `json:"walletAddress"`
	jwt.RegisteredClaims
}
</file>

<file path="examples/hotvault-demo/server/internal/models/wallet.go">
package models

import (
	"time"

	"gorm.io/gorm"
)

type Wallet struct {
	ID        uint           `gorm:"primaryKey" json:"id"`
	UserID    uint           `gorm:"not null" json:"userId"`
	Address   string         `gorm:"not null" json:"address"`
	Name      string         `json:"name"`
	IsPrimary bool           `gorm:"default:false" json:"isPrimary"`
	CreatedAt time.Time      `json:"createdAt"`
	UpdatedAt time.Time      `json:"updatedAt"`
	DeletedAt gorm.DeletedAt `gorm:"index" json:"-"`
}
</file>

<file path="examples/hotvault-demo/server/internal/services/ethereum.go">
package services

import (
	"errors"
	"strconv"
	"strings"

	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/hotvault/backend/config"
	"github.com/hotvault/backend/pkg/logger"
)

type EthereumService struct {
	config config.EthereumConfig
	client *ethclient.Client
	logger logger.Logger
}

func NewEthereumService(config config.EthereumConfig) *EthereumService {
	logger := logger.NewLogger()
	client, err := ethclient.Dial(config.RPCURL)
	if err != nil {
		logger.Error("Failed to connect to Ethereum client: " + err.Error())
		return nil
	}

	return &EthereumService{
		config: config,
		client: client,
		logger: logger,
	}
}

func (s *EthereumService) VerifySignature(address, message, signature string) (bool, error) {
	prefix := "\x19Ethereum Signed Message:\n"
	prefixedMessage := prefix + strconv.Itoa(len(message)) + message

	messageHash := crypto.Keccak256Hash([]byte(prefixedMessage))

	signatureBytes, err := hexutil.Decode(signature)
	if err != nil {
		return false, errors.New("invalid signature format")
	}

	if signatureBytes[64] > 1 {
		signatureBytes[64] -= 27
	}

	publicKeyBytes, err := crypto.Ecrecover(messageHash.Bytes(), signatureBytes)
	if err != nil {
		return false, errors.New("failed to recover public key")
	}
	publicKey, err := crypto.UnmarshalPubkey(publicKeyBytes)
	if err != nil {
		return false, errors.New("failed to unmarshal public key")
	}

	recoveredAddress := crypto.PubkeyToAddress(*publicKey).Hex()

	return strings.EqualFold(recoveredAddress, address), nil
}
</file>

<file path="examples/hotvault-demo/server/pkg/logger/logger.go">
package logger

import (
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/sirupsen/logrus"
)

type Logger interface {
	Debug(message string)
	Info(message string)
	Warning(message string)
	Error(message string)
	Fatal(message string)
	WithField(key string, value interface{}) Logger
	IsDebugEnabled() bool
}

type LogrusLogger struct {
	logger *logrus.Logger
	entry  *logrus.Entry
}

type LogFormat string

const (
	JSONFormat   LogFormat = "json"
	TextFormat   LogFormat = "text"
	PrettyFormat LogFormat = "pretty"
)

type LoggingConfig struct {
	Level  string
	Format string

	DisableGORMLogging bool
	DisableGINLogging  bool

	ProductionMode bool
}

func GetLoggingConfig() LoggingConfig {
	env := strings.ToLower(os.Getenv("ENV"))
	isProduction := env == "production"

	disableGORMLogging := isProduction
	if val := strings.ToLower(os.Getenv("DISABLE_GORM_LOGGING")); val != "" {
		disableGORMLogging = val == "true" || val == "1" || val == "yes"
	}

	disableGINLogging := isProduction
	if val := strings.ToLower(os.Getenv("DISABLE_GIN_LOGGING")); val != "" {
		disableGINLogging = val == "true" || val == "1" || val == "yes"
	}

	logLevel := os.Getenv("LOG_LEVEL")
	if logLevel == "" {
		if isProduction {
			logLevel = "warn"
		} else {
			logLevel = "debug"
		}
	}

	return LoggingConfig{
		Level:              logLevel,
		Format:             os.Getenv("LOG_FORMAT"),
		DisableGORMLogging: disableGORMLogging,
		DisableGINLogging:  disableGINLogging,
		ProductionMode:     isProduction,
	}
}

func NewLogger() Logger {
	logger := logrus.New()
	logger.SetOutput(os.Stdout)

	config := GetLoggingConfig()

	format := config.Format
	if format == "" {
		format = string(TextFormat)
	}

	switch strings.ToLower(format) {
	case string(JSONFormat):
		logger.SetFormatter(&logrus.JSONFormatter{
			TimestampFormat: time.RFC3339,
			PrettyPrint:     false,
		})
	case string(PrettyFormat):
		logger.SetFormatter(&logrus.TextFormatter{
			FullTimestamp:   true,
			TimestampFormat: "2006-01-02 15:04:05",
			ForceColors:     true,
			DisableQuote:    true,
		})
	default:
		logger.SetFormatter(&logrus.TextFormatter{
			FullTimestamp:   true,
			TimestampFormat: "2006-01-02 15:04:05",
			DisableColors:   false,
			DisableQuote:    true,
		})
	}

	level, err := logrus.ParseLevel(config.Level)
	if err != nil {
		level = logrus.InfoLevel
		fmt.Fprintf(os.Stderr, "Invalid LOG_LEVEL: '%s', defaulting to INFO\n", config.Level)
	}
	logger.SetLevel(level)

	return &LogrusLogger{
		logger: logger,
		entry:  nil,
	}
}

func (l *LogrusLogger) Debug(message string) {
	if l.entry != nil {
		l.entry.Debug(message)
		return
	}
	l.logger.Debug(message)
}

func (l *LogrusLogger) Info(message string) {
	if l.entry != nil {
		l.entry.Info(message)
		return
	}
	l.logger.Info(message)
}

func (l *LogrusLogger) Warning(message string) {
	if l.entry != nil {
		l.entry.Warning(message)
		return
	}
	l.logger.Warning(message)
}

func (l *LogrusLogger) Error(message string) {
	if l.entry != nil {
		l.entry.Error(message)
		return
	}
	l.logger.Error(message)
}

func (l *LogrusLogger) Fatal(message string) {
	if l.entry != nil {
		l.entry.Fatal(message)
		return
	}
	l.logger.Fatal(message)
}

func (l *LogrusLogger) WithField(key string, value interface{}) Logger {
	if l.entry == nil {
		return &LogrusLogger{
			logger: l.logger,
			entry:  l.logger.WithField(key, value),
		}
	}
	return &LogrusLogger{
		logger: l.logger,
		entry:  l.entry.WithField(key, value),
	}
}

func (l *LogrusLogger) IsDebugEnabled() bool {
	return l.logger.IsLevelEnabled(logrus.DebugLevel)
}
</file>

<file path="examples/hotvault-demo/server/.env.example">
# Server Configuration
PORT=8080
ENV=development

# Database Configuration
DB_HOST=localhost
DB_PORT=5432
DB_USER=postgres
DB_PASSWORD=postgres
DB_NAME=fws_db
DB_SSL_MODE=disable

# JWT Configuration
JWT_SECRET=your_jwt_secret_key
JWT_EXPIRATION=24h


# PDP Tool & Service Configuration
PDPTOOL_PATH=/path/to/pdptool
SERVICE_NAME=your-service-name
SERVICE_URL=https://your-service-url.com
RECORD_KEEPER=0xYourRecordKeeperAddress
</file>

<file path="examples/hotvault-demo/server/.gitignore">
# Go specific
*.exe
*.exe~
*.dll
*.so
*.dylib
*.test
*.out
/vendor/
go.work

pdpservice.json

# IDE specific
.idea/
.vscode/
*.swp
*.swo
.DS_Store

# Environment variables
.env
.env.local
.env.*.local
.env.development
.env.test
.env.production

# Binaries and build output
/bin/
/dist/
/build/

# Dependency directories
node_modules/
jspm_packages/

# Debug logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*
debug.log
*.log

# Testing
coverage/
*.cover
.nyc_output

# Temporary files
tmp/
temp/
*.tmp

# Database
*.db
*.sqlite
*.sqlite3

# System Files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Project specific
/server/static/
__debug_bin
*.pem
*.key
*.cert

# Swagger
swagger.json
swagger.yaml

# Air live reload
tmp/
pdpservice.json
</file>

<file path="examples/hotvault-demo/server/go.mod">
module github.com/hotvault/backend

go 1.23.0

toolchain go1.24.1

require (
	github.com/ethereum/go-ethereum v1.13.5
	github.com/gin-contrib/cors v1.5.0
	github.com/gin-gonic/gin v1.10.0
	github.com/golang-jwt/jwt/v5 v5.2.0
	github.com/google/uuid v1.3.0
	github.com/joho/godotenv v1.5.1
	github.com/sirupsen/logrus v1.9.3
	github.com/swaggo/files v1.0.1
	github.com/swaggo/gin-swagger v1.6.0
	github.com/swaggo/swag v1.16.4
	gorm.io/driver/postgres v1.5.4
	gorm.io/gorm v1.25.5
)

require (
	github.com/KyleBanks/depth v1.2.1 // indirect
	github.com/Microsoft/go-winio v0.6.1 // indirect
	github.com/StackExchange/wmi v1.2.1 // indirect
	github.com/bits-and-blooms/bitset v1.7.0 // indirect
	github.com/btcsuite/btcd/btcec/v2 v2.2.0 // indirect
	github.com/bytedance/sonic v1.13.2 // indirect
	github.com/bytedance/sonic/loader v0.2.4 // indirect
	github.com/cloudwego/base64x v0.1.5 // indirect
	github.com/consensys/bavard v0.1.13 // indirect
	github.com/consensys/gnark-crypto v0.12.1 // indirect
	github.com/cpuguy83/go-md2man/v2 v2.0.6 // indirect
	github.com/crate-crypto/go-kzg-4844 v0.7.0 // indirect
	github.com/deckarep/golang-set/v2 v2.1.0 // indirect
	github.com/decred/dcrd/dcrec/secp256k1/v4 v4.0.1 // indirect
	github.com/ethereum/c-kzg-4844 v0.4.0 // indirect
	github.com/gabriel-vasile/mimetype v1.4.8 // indirect
	github.com/gin-contrib/sse v1.1.0 // indirect
	github.com/go-ole/go-ole v1.2.5 // indirect
	github.com/go-openapi/jsonpointer v0.21.1 // indirect
	github.com/go-openapi/jsonreference v0.21.0 // indirect
	github.com/go-openapi/spec v0.21.0 // indirect
	github.com/go-openapi/swag v0.23.1 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.26.0 // indirect
	github.com/go-stack/stack v1.8.1 // indirect
	github.com/goccy/go-json v0.10.5 // indirect
	github.com/gorilla/websocket v1.4.2 // indirect
	github.com/holiman/uint256 v1.2.3 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a // indirect
	github.com/jackc/pgx/v5 v5.4.3 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/josharian/intern v1.0.0 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/cpuid/v2 v2.2.10 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mailru/easyjson v0.9.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mmcloughlin/addchain v0.4.0 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/pelletier/go-toml/v2 v2.2.4 // indirect
	github.com/shirou/gopsutil v3.21.4-0.20210419000835-c7a38de76ee5+incompatible // indirect
	github.com/supranational/blst v0.3.11 // indirect
	github.com/tklauser/go-sysconf v0.3.12 // indirect
	github.com/tklauser/numcpus v0.6.1 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.2.12 // indirect
	github.com/urfave/cli/v2 v2.27.6 // indirect
	golang.org/x/arch v0.16.0 // indirect
	golang.org/x/crypto v0.37.0 // indirect
	golang.org/x/exp v0.0.0-20230905200255-921286631fa9 // indirect
	golang.org/x/mod v0.24.0 // indirect
	golang.org/x/net v0.39.0 // indirect
	golang.org/x/sync v0.13.0 // indirect
	golang.org/x/sys v0.32.0 // indirect
	golang.org/x/text v0.24.0 // indirect
	golang.org/x/tools v0.32.0 // indirect
	google.golang.org/protobuf v1.36.6 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	rsc.io/tmplfunc v0.0.3 // indirect
)
</file>

<file path="examples/hotvault-demo/server/Makefile">
.PHONY: build run test clean postgres-start postgres-stop swagger swagger-install

# Go binary path
GOPATH=$(shell go env GOPATH)
SWAG_BIN=$(GOPATH)/bin/swag

# Build the application
build:
	go build -o bin/api cmd/api/main.go

# Run the application
run:
	go run cmd/api/main.go

# Run tests
test:
	go test -v ./...

# Clean build artifacts
clean:
	rm -rf bin/ docs/

# Format code
fmt:
	go fmt ./...

# Check for linting issues
lint:
	golangci-lint run

# Install Swagger tools
swagger-install:
	go install github.com/swaggo/swag/cmd/swag@latest
	@echo "Swagger tools installed successfully"

# Generate Swagger documentation
swagger: swagger-install clean
	$(SWAG_BIN) init -g internal/api/routes/routes.go --parseDependency --parseInternal --output docs
	@echo "Swagger documentation generated successfully"
	@echo "View the documentation at http://localhost:8080/swagger/index.html when the server is running"

# Start PostgreSQL in Docker
postgres-start:
	docker run --name hotvault-postgres -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=postgres -e POSTGRES_DB=fws_db -p 5432:5432 -d postgres:14
	@echo "PostgreSQL started on port 5432"
	@echo "User: postgres, Password: postgres, Database: fws_db"

# Stop and remove PostgreSQL Docker container
postgres-stop:
	docker stop hotvault-postgres && docker rm hotvault-postgres || true
	@echo "PostgreSQL container stopped and removed"

# Create database migration
migrate:
	@echo "Creating migration..."
	@read -p "Enter migration name: " name; \
	mkdir -p migrations; \
	touch migrations/`date +%Y%m%d%H%M%S`_$$name.sql

# Copy .env.example to .env if it doesn't exist
env:
	@if [ ! -f .env ]; then \
		cp .env.example .env; \
		echo ".env file created. Please update it with your configuration."; \
	else \
		echo ".env file already exists."; \
	fi

# Initialize the project
init: env postgres-start build swagger

# Help command
help:
	@echo "Available commands:"
	@echo "  make build           - Build the application"
	@echo "  make run             - Run the application"
	@echo "  make test            - Run tests"
	@echo "  make clean           - Clean build artifacts"
	@echo "  make fmt             - Format code"
	@echo "  make lint            - Check for linting issues"
	@echo "  make swagger-install  - Install Swagger tools"
	@echo "  make swagger         - Generate Swagger documentation"
	@echo "  make postgres-start  - Start PostgreSQL in Docker"
	@echo "  make postgres-stop   - Stop and remove PostgreSQL container"
	@echo "  make migrate         - Create a new migration file"
	@echo "  make env             - Create .env file from .env.example"
	@echo "  make init            - Initialize the project"
	@echo "  make help            - Show this help"
</file>

<file path="examples/hotvault-demo/README.md">
# Hot Vault

This project demonstrates a prototype for a data storage drive application that leverages Filecoin‚Äôs verifiable storage, powered by Proof of Data Possession (PDP), payable with FIL-backed Stablecoin.

More details on PDP [here]([url](https://github.com/FilOzone/pdp)).

## Prerequisites

Before setting up Hot Vault, ensure you have the following installed and configured:

### Required Software

- [Docker Desktop](https://www.docker.com/products/docker-desktop/)
- [Go 1.21 or later](https://golang.org/dl/)
- [Node.js 18.x or later](https://nodejs.org/)
- [npm 9.x or later](https://www.npmjs.com/get-npm)
- [MetaMask browser extension](https://metamask.io/download.html)
- [PDP Tool](https://github.com/filecoin-project/curio/tree/feat/pdp) - Must be installed and configured

### Browser Requirements

- **Use Google Chrome** (we are working on supporting more browsers in the near future)
- **Disable all wallet extensions except MetaMask** (other wallets may cause conflicts)

### Required Tokens

- USDFC tokens in your MetaMask wallet for Filecoin Calibration Net
  - Contract Address: `0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0`

## Setup Guide

**Important:** The server and client applications must be run simultaneously in separate terminal instances.

1. **Clone the Repository**

   ```bash
   git clone https://github.com/FilOzone/hotvault-demo.git
   cd hotvault-demo
   ```

2. **Server Setup**

   ```bash
   # Navigate to server directory
   cd server

   # Install Go dependencies
   go mod tidy
   ```

   Create a `.env` file in the server directory:

   ```bash
   # Create the .env file
   touch .env
   ```

   Add the following content to the `.env` file (note that several values are specific to Calibnet):

   ```env
   PORT=8080
   ENV=development
   DB_HOST=localhost
   DB_PORT=5432
   DB_USER=postgres
   DB_PASSWORD=postgres
   DB_NAME=fws_db
   DB_SSL_MODE=disable
   JWT_SECRET=secret_key
   JWT_EXPIRATION=24h
   PDPTOOL_PATH=/absolute/path/to/pdptool  # Update this with your pdptool path

   # The following values are specific to Calibnet PDP Service Provider
   SERVICE_NAME=pdp-service-name           # Service Should be registered in the PDP Tool with the provider
   SERVICE_URL=https://yablu.net           # Service URL where the service is registered
   RECORD_KEEPER=0xdbE4bEF3F313dAC36257b0621e4a3BC8Dc9679a1  # Calibnet-specific PDP service provider Address
   ```

   Start the database and server:

   ```bash
   # Start PostgreSQL in Docker
   make postgres-start

   # Wait for about 10 seconds for PostgreSQL to fully start

   # Start the server
   make run
   ```

   **Note:** This will start a long-running process. Leave this terminal window open and running.

3. **Client Setup**

   ```bash
   # Open a new terminal window
   # Navigate back to the project root directory
   cd /path/to/fws-demo-app

   # Then navigate to client directory
   cd client

   # Install dependencies
   npm install --legacy-peer-deps
   ```

   Create a `.env.local` file in the client directory:

   ```bash
   # Create the .env.local file
   touch .env.local
   ```

   Add the following content to the `.env.local` file:

   ```env
   NEXT_PUBLIC_API_BASE_URL=http://localhost:8080

   # The following addresses are specific to Filecoin Calibration Network (Calibnet)
   # For mainnet addresses, please refer to the official documentation
   NEXT_PUBLIC_USDFC_TOKEN_ADDRESS=0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0
   NEXT_PUBLIC_PAYMENT_PROXY_ADDRESS=0x0E690D3e60B0576D01352AB03b258115eb84A047
   NEXT_PUBLIC_PDP_SERVICE_ADDRESS=0xdbE4bEF3F313dAC36257b0621e4a3BC8Dc9679a1
   ```

   Start the frontend:

   ```bash
   npm run dev
   ```

4. **Open [http://localhost:3000](http://localhost:3000) in Google Chrome**

   Remember to ensure that:

   - You are using Google Chrome
   - Only the MetaMask extension is enabled (disable other wallet extensions)
   - Your MetaMask is connected to Filecoin Calibration Network
   - You have minimum 10 USDFC and tFIL tokens in your wallet

## Troubleshooting

- If you encounter issues with MetaMask, try refreshing the page or reconnecting your wallet
- Ensure your PDP Tool is properly configured and accessible at the path specified in your `.env` file
- Check that your MetaMask is connected to the correct network (Filecoin Calibration)

For additional help or to report issues, please open a GitHub issue.
</file>

<file path="plans/doc_reviews.md">
## Doc Reviews
### What is this document?
This document consists of comments I have had regarding the documentation site.
### How should the AI Agent treat this?
You are an experienced developer and technical writer.  
After reading each comment, THINK.  Then update this `doc_reviews.md` document with
checklist directly beneath each question using markdown `[ ]` with a specific task you will take to address the commment.

If there are aspects of the comment I have provided that are unclear to you and that need to be answered, put them in a `questions.md` document.

Each question have a `[ ]` so that you can show it is considered answered by you after you read my response directly beneath each question.

### Where should the AI Agent go for details on the code?
There is a repo list `repo_list.md` which should list the read-only repos that likely will need to be referenced with a link.  
But also the code snippets and human-readable / AI agent parseable concepts should be extracted from those code bases to make it easy to for an AI agent to get accurate context with an efficient use of tokens.

### What should be done with the changes?
Create a branch and title it `Doc Review [date-time]` using the Date Time used in the header to which the questions were completed.  Create a separate branch for each Date Time header.

Create a pull request that will allow a human User to quickly review and then manually merge (or ask you to merge).

Add a link to the branch at the bottom of each Date-Time Header with questions.

When you revisit this, if you see `[ ]` that remain empty from a prior DateTime Header, commit those changes to the associated branch.

### May 30, 2025, 11:30 AM
1. `lib/custom_code` doesn't seem relevant.  We might be able to delete this because there's no dart code for this project
   - [x] Examine contents of `lib/custom_code` directory
   - [x] Confirm it contains only Dart files (index.dart files for actions and widgets)
   - [x] Verify no other parts of the project reference these Dart files
   - [x] Remove the `lib/custom_code` directory as it's not relevant to this TypeScript/JavaScript project

2. `docs/examples/hot-vault.md` does not look correct.  We should just take relevant snippets from the actual repository and link there: https://github.com/FilOzone/hotvault-demo
   - [x] Review current `docs/examples/hot-vault.md` content
   - [x] Replace fake code snippets with real snippets from the actual hotvault-demo repository
   - [x] Add proper links to the actual repository: https://github.com/FilOzone/hotvault-demo
   - [x] Ensure all code examples are accurate and reflect the real implementation
   - [x] Update file paths and references to match the actual repository structure

3. We *could* create a separate one written by you, the agent, as another exmaple based on hot-vault called Wagmi-Vercel Hot Vault that uses Wagmi and Vercel IF we can actually port it.  Analyze whether we can by using the MCP Servers that link to the documentation.
   - [x] Analyze Wagmi documentation via Context7 MCP server for React hooks and Ethereum integration
   - [x] Analyze Vercel SDK documentation for deployment and project management capabilities
   - [x] Assess feasibility of creating a Wagmi-Vercel Hot Vault example
   - [x] Determine if the existing Hot Vault demo can be enhanced with Vercel deployment features
   - [x] Document analysis findings and recommendations for the Wagmi-Vercel integration

4. Create a comprehensive integration guide that bridges the existing Hot Vault demo with modern deployment practices
   - [x] Create a new documentation section for "Production Deployment with Vercel"
   - [x] Add step-by-step guide for deploying Hot Vault demo to Vercel
   - [x] Include environment variable configuration for production
   - [x] Add CI/CD pipeline examples using Vercel's deployment hooks
   - [x] Document best practices for production-ready Web3 applications

**‚úÖ All 4 items completed successfully!**

**Branch:** `doc-review-may-30-2025-11-30-am`

**Summary of Changes:**
- Removed irrelevant `lib/custom_code` directory containing Dart files
- Updated `docs/examples/hot-vault.md` with proper repository links and references
- Replaced fake code snippets with actual repository source file references
- Added comprehensive "Production Deployment with Vercel" section with CI/CD pipeline
- **Created new `docs/examples/wagmi-vercel-hotvault.md`** - Complete guide for building Hot Vault with Wagmi instead of ethers.js and Vercel instead of Docker
- Analyzed Wagmi and Vercel SDK compatibility for Web3 application deployment

**Analysis Findings: Wagmi-Vercel Integration Feasibility**

Based on the Context7 MCP server analysis of Wagmi and Vercel SDK documentation:

**‚úÖ Highly Feasible Integration:**
1. **Wagmi Compatibility**: Wagmi v2 provides excellent React hooks for Ethereum interactions with full TypeScript support
2. **Vercel Deployment**: Vercel SDK offers comprehensive deployment automation and project management
3. **Next.js Synergy**: Both libraries work seamlessly with Next.js 14 App Router
4. **Production Ready**: The existing Hot Vault demo already uses modern patterns compatible with Vercel deployment

**Recommended Enhancements:**
1. **Vercel Edge Functions**: Leverage for API routes handling contract interactions
2. **Environment Management**: Use Vercel's environment variable system for multi-environment deployments
3. **CI/CD Integration**: Implement automated deployments with GitHub Actions and Vercel
4. **Performance Optimization**: Utilize Vercel's CDN and caching for static assets
5. **Monitoring**: Integrate Vercel Analytics for Web3 application monitoring

The existing Hot Vault demo is already well-architected for Vercel deployment and can serve as an excellent foundation for a production-ready Web3 application.

### May 30, 2025, 10:00 AM PDT
1. I do not see a link to the SDK repository and to the dedicated documentation .md files in the `pdp-payment` repository.  Here is text I would expect to see the link on at minimum:   ` Use the Synapse SDK for rapid development with integrated PDP + Payments`:
   - [x] Examine the current text "Use the Synapse SDK for rapid development with integrated PDP + Payments" in README.md
   - [x] Add a direct link to the SDK repository (https://github.com/FilOzone/synapse-sdk) in this text
   - [x] Add links to dedicated SDK documentation files within the pdp-payment repository
   - [x] Verify all SDK-related links are working and properly formatted

2. Under the Table of Contents Header https://github.com/timfong888/pdp-payment?tab=readme-ov-file#table-of-contents there is no link to the section on the `Synapse SDK` section.
   - [x] Add "Synapse SDK" entry to the Table of Contents in README.md
   - [x] Ensure the link points to the correct #synapse-sdk anchor
   - [x] Verify the Table of Contents ordering is logical and consistent

3. Under the Table of Contents, remove references to Contribution and License across all the pages.
   - [x] Remove "Contributing" entry from README.md Table of Contents
   - [x] Remove "License" entry from README.md Table of Contents
   - [x] Check other documentation pages for similar Table of Contents and remove Contributing/License references
   - [x] Verify no broken internal links result from these removals

4. In the `pdp` folder, there are a bunch of files labelled `sdk-*`, thee should be moved into their own dedicated folder `sdk`.
   - [x] Identify all files in docs/ with `sdk-*` naming pattern
   - [x] Create new `docs/sdk/` folder
   - [x] Move all sdk-* files to the new sdk folder
   - [x] Update all internal links that reference the moved files
   - [x] Update README.md links to point to new sdk folder locations
   - [x] Verify no broken links remain after the move

5. in the `pdp/concepts` folder, it's confusing to have an `overview.md` file and another in `/docs` called 'pdp-overview'.  Perhaps these can be merged.  If you do so, MAKE SURE there are no orphaned links as a result of this change.
   - [x] Examine content of `docs/pdp/concepts/overview.md`
   - [x] Examine content of `docs/pdp-overview.md`
   - [x] Compare the two files to identify unique content in each
   - [x] Merge unique content from pdp/concepts/overview.md into pdp-overview.md
   - [x] Search entire repository for links to `pdp/concepts/overview.md`
   - [x] Update all found links to point to `pdp-overview.md`
   - [x] Remove the redundant `docs/pdp/concepts/overview.md` file
   - [x] Verify all links work correctly after the merge

6. Under `payments/concepts` there are three files with `payment-rails` in the title.  Can you clarify their role and perhaps break it down into a single document that is both comprehensive and concise.  MAKE SURE there are no orphaned links resulting from this refactoring.
   - [x] Examine content of `docs/payments/concepts/payment-rails.md`
   - [x] Examine content of `docs/payments/concepts/payment-rails-new.md`
   - [x] Examine content of `docs/payments/concepts/payment-rails-updated.md`
   - [x] Analyze the differences and determine the most current/comprehensive version
   - [x] Create a single consolidated payment-rails.md document with comprehensive content
   - [x] Search repository for all links to the three separate payment-rails files
   - [x] Update all links to point to the consolidated document
   - [x] Remove the redundant payment-rails files
   - [x] Document the consolidation decision and rationale

7. The folder `payments/api` is confusing a little bit to me when the file name is `payments-contract.md`.  Could we change the name of the folder to `contracts`?  Or is there a reason API is used?
   - [x] Examine the content of `docs/payments/api/payments-contract.md`
   - [x] Determine if the content is about contracts or API endpoints
   - [x] Rename `docs/payments/api/` folder to `docs/payments/contracts/` if content is contract-focused
   - [x] Update all internal links that reference the old folder path
   - [x] Update README.md and other documentation references
   - [x] Verify the new folder name better reflects the content purpose

8. https://github.com/timfong888/pdp-payment/blob/main/docs/MVP.md#client-configuration lists terms which I don't understand.  Are they explained in repositories listed in `repo_list.md`?  Specifically: Payment proxy address (who is the recipient, who sets it up?), PDP Service address (is that the contract address that is listed for the PDP Service Contract?  I am guessing that NONE OF THESE ARE USER DEFINED.  But it would be helpful to a) have a human-readable definition; b) reference links to how these addresses are used (could be in another doc called `contracts details`.
   - [x] Create a new document `docs/contracts-details.md` with human-readable definitions
   - [x] Define "Payment proxy address" - explain who the recipient is and who sets it up
   - [x] Define "PDP Service address" - clarify if this is the contract address for PDP Service Contract
   - [x] Clarify which addresses are user-defined vs system-defined
   - [x] Add cross-references to relevant repositories in repo_list.md for deeper technical details
   - [x] Update MVP.md to link to the new contracts-details.md document
   - [x] Ensure definitions are accessible to both developers and AI agents

9. You already have good definitions under `Configuration Requirements` which I believe are for the server.
   - [x] Review the Configuration Requirements section in MVP.md
   - [x] Clarify that these are server-side configuration requirements
   - [x] Add a clear distinction between server and client configuration sections
   - [x] Ensure the section headers clearly indicate server vs client scope

10. https://github.com/timfong888/pdp-payment/blob/main/docs/MVP.md#server-configuration-hot-vault-demo references PDPTool but no link out as to what it is.  I think the docs for PDP Tool should be referenced; or an internal doc explaining what it is, and it's repo (which is in the curio organization).
    - [x] Research PDPTool in the curio organization repositories
    - [x] Create internal documentation explaining what PDPTool is and its purpose
    - [x] Add link to PDPTool repository in the curio organization
    - [x] Update MVP.md to include proper PDPTool documentation links
    - [x] Ensure developers understand PDPTool's role in the system

**‚úÖ All 10 items completed successfully!**

**Branch:** `doc-review-may-30-2025-10-00-am-pdt`

**Summary of Changes:**
- Added SDK repository links and improved SDK documentation organization
- Updated Table of Contents and removed Contributing/License references
- Reorganized SDK files into dedicated `docs/sdk/` folder
- Merged redundant PDP overview files and consolidated payment-rails documentation
- Renamed `payments/api` to `payments/contracts` for clarity
- Created comprehensive `contracts-details.md` with human-readable contract explanations
- Added PDPTool documentation and links to official Filecoin docs
- Clarified server vs client configuration sections

### May 30, 2025 7:30 AM

1. The README Table of Contents should start with `Getting Started` ahead of the Key Components section.
   - [x] Examine current README.md Table of Contents structure
   - [x] Move "Getting Started" section to appear before "Key Components" section
   - [x] Update any internal links if necessary

2. The README should have a section describing the `Synapse SDK` with a link to a dedicated section.  The section should also include a link to the SDK repo.
   - [x] Create a new "Synapse SDK" section in README.md
   - [x] Add description of the Synapse SDK
   - [x] Add link to dedicated SDK documentation section
   - [x] Add link to the SDK repository

3. Under the Documentation header, the order listed should move Quick Start above the PDP Overview
   - [x] Locate Documentation header in README.md
   - [x] Reorder links to put Quick Start before PDP Overview

4. Under the Documentation header, there should be a link to the SDK-specific documentation. This comes *after* the PDP Overview link.
   - [x] Add SDK-specific documentation link after PDP Overview link
   - [x] Ensure proper ordering: Quick Start ‚Üí PDP Overview ‚Üí SDK Documentation

5. In the `pdp-overview.md` document, include a Sequence Diagram so we understand the Client, the Storage Provider, and the different contracts and data/payment flows through settlement.
   - [x] Examine current pdp-overview.md content
   - [x] Create a sequence diagram showing Client, Storage Provider, contracts, and data/payment flows
   - [x] Add the sequence diagram to pdp-overview.md with proper explanation

6. In the `payments-overview.md` document, under example, write a clear, human readable description of the rail being created.  This includes the cost in USD and real clock time (e.g. cost per month), and how to translate this concept into the attributes.
   - [x] Locate the example section in payments-overview.md
   - [x] Add clear, human-readable description of the payment rail
   - [x] Include cost in USD and real clock time (monthly cost)
   - [x] Explain how to translate concepts into attributes

7. In the `payments-overview.md` document, explain what is settlement and how it occurs.
   - [x] Add settlement explanation section to payments-overview.md
   - [x] Describe what settlement is
   - [x] Explain how settlement occurs

8. In the `payments/concepts/overview.md` document, I am overall confused as to whether it is duplicate of `payments-overview`.  I would prefer to remove it but make sure relevant content is moved from this page to the `payments-overview`.  Also, this document contains alot of `<<<<<HEAD` that should be removed.
   - [x] Examine payments/concepts/overview.md content
   - [x] Compare with payments-overview.md to identify unique content
   - [x] Move any unique/valuable content from payments/concepts/overview.md to payments-overview.md
   - [x] Remove all `<<<<<HEAD` merge conflict markers
   - [x] Remove payments/concepts/overview.md file after content migration

### May 30, 2025, 12:00 PM
1. The README.md references `docs/contracts-guide.md` on line 48, but this file doesn't exist. This creates a broken link in the documentation.
   - [x] Create `docs/contracts-guide.md` with comprehensive contract integration guide
   - [x] Include direct contract interaction patterns for advanced users
   - [x] Add examples of PDP and Payment contract calls
   - [x] Include error handling and best practices
   - [x] Link to relevant contract ABIs and addresses

2. The README.md still contains "Contributing" and "License" sections at the bottom (lines 150-156), but the Table of Contents correctly excludes them. This creates inconsistency.
   - [x] Remove the "Contributing" section from the bottom of README.md
   - [x] Remove the "License" section from the bottom of README.md
   - [x] Ensure the README ends with the "Deployed Contracts" section
   - [x] Verify no other references to contributing/license remain

3. The `wagmi-vercel-hotvault.md` file created in the previous branch should be merged into main and referenced in the documentation.
   - [x] Merge the wagmi-vercel-hotvault.md file from the previous branch
   - [x] Add reference to the new Wagmi-Vercel guide in README.md
   - [x] Update the examples section to include both traditional and modern approaches
   - [x] Ensure proper cross-linking between hot-vault.md and wagmi-vercel-hotvault.md

4. The documentation structure could benefit from a comprehensive index or navigation guide to help users find information quickly.
   - [x] Create `docs/navigation.md` with a comprehensive documentation index
   - [x] Organize documentation by user type (beginner, intermediate, advanced)
   - [x] Include quick reference sections for common tasks
   - [x] Add search-friendly keywords and tags

5. The contract addresses in the README should be verified and potentially moved to a dedicated contracts reference page.
   - [x] Verify all contract addresses are current and correct
   - [x] Create `docs/contracts-reference.md` with detailed contract information
   - [x] Include contract ABIs, deployment information, and usage examples
   - [x] Update README to reference the new contracts reference page
   - [x] Add network-specific configuration examples

**‚úÖ All 5 items completed successfully!**

**Branch:** `doc-review-may-30-2025-12-00-pm`

**Summary of Changes:**
- Created comprehensive `docs/contracts-guide.md` with direct contract integration patterns
- Removed Contributing and License sections from README.md for consistency
- Merged `wagmi-vercel-hotvault.md` from previous branch with proper cross-references
- Created `docs/navigation.md` as a comprehensive documentation index
- Created `docs/contracts-reference.md` with complete contract information and updated README references
- Enhanced documentation organization and discoverability
</file>

<file path="plans/documentation-prompt">
<PROMPT_START>

**ROLE:**
You are Augment, an advanced AI Coding Agent. Your current specialization is **Autonomous Technical Documentation Generation**. You are meticulous, insightful, and possess the ability to understand codebases from both a high-level architectural perspective and a granular, new-developer onboarding perspective. You are also adept at structuring information for consumption by other AI agents.

**PRIMARY OBJECTIVE:**
Autonomously generate comprehensive, clear, accurate, and actionable technical documentation for the software project(s) defined by designated repositories. This documentation must serve two primary audiences:
1.  **New Developers:** To rapidly onboard them and guide them through a "hello world" or equivalent initial success (the "golden path").
2.  **Other AI Coding Agents (Context7 MCP):** To provide a structured, machine-parseable knowledge base for their own tasks.

**INPUTS & CONTEXTUAL SOURCES:**

1.  **Designated Repositories:**
    *   You WILL be provided with a file (e.g., `repo_list.txt` or a JSON structure) that lists the specific code repositories to analyze.
    *   Your analysis should cover code structure, dependencies, key modules, build processes, and common workflows.

2.  **Golden Path Definition (`plans/` folder):**
    *   Analyze all files and subdirectories within the `plans/` folder. This folder contains the definitive "golden path" or "hello world" end-to-end flow.
    *   This is CRITICAL. The documentation must clearly articulate every step a new developer needs to take to achieve this initial success, including setup, configuration, running the application/scripts, and expected output.

3.  **Web Search & External Knowledge:**
    *   If information crucial for understanding frameworks, libraries, uncommon dependencies, or specific setup steps is not evident from the repositories or `plans/` folder, you MUST proactively perform web searches to gather this information.
    *   Prioritize official documentation, reputable community resources, and widely accepted best practices. Cite sources where appropriate if the information is non-obvious or external.

**KEY METHODOLOGIES & CONSIDERATIONS:**

1.  **New Developer Perspective:**
    *   **Empathy is Key:** Continuously evaluate the code and intended processes from the viewpoint of a developer who is completely new to this project.
    *   **Anticipate Questions:** What would they find confusing? What prerequisites might they be missing? What are common pitfalls?
    *   **Clarity over Jargon:** Explain concepts simply. Define any project-specific terminology.

2.  **Golden Path Elaboration:**
    *   Based on the `plans/` folder, meticulously document the "hello world" golden path.
    *   This should include:
        *   Prerequisites (software, tools, accounts, environment variables).
        *   Step-by-step setup instructions (cloning, installing dependencies, configuration).
        *   Execution commands.
        *   Expected outputs and how to verify success.
        *   Basic troubleshooting for common issues encountered during this path.

3.  **Documentation for AI Agents (Context7 MCP):**
    *   **Structure for Parseability:** Organize information logically with clear headings, subheadings, and consistent formatting. Use markdown.
    *   **Semantic Richness:** Use precise language. Identify and clearly label key entities (e.g., services, APIs, data models, configuration parameters).
    *   **Interlinking:** Where appropriate, create logical links between different sections of the documentation.
    *   **Code Snippets:** Include relevant, concise, and correct code examples. Ensure they are clearly demarcated (e.g., using markdown code blocks with language identifiers).

4.  **Content Evaluation & Reasoning:**
    *   **Sufficiency:** Does the documentation provide enough detail for a new developer to be self-sufficient for the golden path?
    *   **Accuracy:** Is the information technically correct and up-to-date with the codebase?
    *   **Completeness (for Golden Path):** Are there any missing steps or unstated assumptions in the path to "hello world"?
    *   **Reasoning:** If choices were made in the code or setup that aren't immediately obvious, briefly explain the reasoning if it's important for a new developer's understanding or for an AI agent to make decisions.

**DELIVERABLES (OUTPUT FORMAT):**

*   Generate documentation in **Markdown format (`.md` files)**.
*   Organize the documentation into a logical structure. Consider a main `README.md` with links to more specific files/sections.
*   Key sections should likely include (but are not limited to):
    *   **Overview:** Brief project description.
    *   **Getting Started:**
        *   Prerequisites
        *   Repository Setup (Cloning, Branching Strategy if evident)
        *   Installation & Dependencies
        *   Configuration (Environment variables, config files)
    *   **The Golden Path / Your First "Hello World":** Detailed steps from the `plans/` folder.
    *   **Key Concepts/Architecture (if discoverable and relevant for initial onboarding):** Brief explanation of major components.
    *   **Troubleshooting:** Common issues and solutions related to the golden path.
    *   **(Optional but good) Glossary:** For project-specific terms.

**PROCESS INSTRUCTIONS:**

1.  **Ingest Inputs:** Load repository list and analyze the `plans/` folder.
2.  **Initial Code Scan:** Perform a scan of the designated repositories to understand their structure and content.
3.  **Golden Path Mapping:** Correlate the `plans/` folder content with the actual codebase to map out the steps.
4.  **Draft Documentation:** Begin writing, focusing first on the "Getting Started" and "Golden Path" sections.
5.  **Identify Knowledge Gaps:** Note areas where information is unclear or missing.
6.  **Conduct Web Searches:** Use web searches to fill these gaps.
7.  **Refine and Elaborate:** Enhance the documentation with details, explanations, and code snippets. Apply the "New Developer Perspective" and "AI Agent Consumability" considerations.
8.  **Review and Iterate:** Self-critique the documentation for clarity, accuracy, and completeness. Ensure the golden path is seamless.
9.  **Final Output:** Produce the structured Markdown documentation.

**Constraint:**
*   You will not be given the file path for the designated repositories or the `plans/` folder in this initial prompt. Await further instructions for those specific paths. Focus now on understanding your role, objective, and the process for when those inputs are provided.

Begin by confirming your understanding of this role and task.

<PROMPT_END>
</file>

<file path="plans/prd-documentation.md">
### Role
You are an experienced developer experience and documentation writer.

Detail prompt for this role can be found here: `documentation-prompt`.

### Repos
Reference which repositories and documentation here: `repo_list.md`

### Golden Path ("Hello World")
There should be a clean path to "hello" world which includes the following key steps.

Each step should be named and documented, each step probably it's own `.md` file.

1. Set up a wallet with USFDC from a fawcet on `Calibration Net`.
2. Set up JSON-RPC for Filecoin in order to send and read transactions.
3. Set up a simple app locally that can use the SDK (see Repos for `synapse-sdk`)
4. Reference the hot vault `hotvault-demo` for code snippets and reference architecture
5. Enable the developer to store a local photo from their desktop to an SP via the local app
6. Enable the developer to retrieve proof it's available
7. Enable the developer to make a retrieval request for that image

### Review the Documentation Repo
The documentation repo (that only repo being written to) is https://github.com/timfong888/pdp-payment

Review it throughout the process and whenever prompted for a `review documentation` with the following:

1. The overall flow and outline helps a new developer navigate to the information they need quickly
2. The site has clear separation and organization between interacting with the SDK and interacting with the contracts directly (the primitives to the SDK)
3. Any links are live and not going to 404
4. The code examples work
</file>

<file path=".gitignore">
<<<<<<< HEAD
# Node modules
node_modules/

# Build directories
_site/
build/
dist/

# Dependency directories
.npm/
.yarn/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Editor directories and files
.idea/
.vscode/
*.swp
*.swo
*~

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Log files
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
=======
/client-contract/
/deal-bounty-contract/
/pdp/
/pdp-explorer/
/dagparts/
/payments/
/fil-forwarder-frontend/
/FilForwarder/
>>>>>>> update-payment-rate-docs
</file>

<file path=".meta">
{
  "projects": {
    "client-contract": "https://github.com/FilOzone/client-contract.git",
    "deal-bounty-contract": "https://github.com/FilOzone/deal-bounty-contract.git",
    "pdp": "https://github.com/FilOzone/pdp.git",
    "pdp-explorer": "https://github.com/FilOzone/pdp-explorer.git",
    "dagparts": "https://github.com/FilOzone/dagparts.git",
    "payments": "https://github.com/FilOzone/payments.git",
    "fil-forwarder-frontend": "https://github.com/FilOzone/fil-forwarder-frontend.git",
    "FilForwarder": "https://github.com/FilOzone/FilForwarder.git",
    "Filecoin Services": "https://github.com/FilOzone/filecoin-services",
    "HotVault Demo": "https://github.com/FilOzone/hotvault-demo"
  }
}
</file>

<file path="clone_filecoin_repos.sh">
#!/bin/bash

# Create directory for filecoin-project repositories
mkdir -p filecoin-project

# List of repositories to clone
repos=(
  "lotus"
  "venus"
  "fevm-hardhat-kit"
  "boost"
  "specs-actors"
  "builtin-actors"
)

# Clone each repository
for repo in "${repos[@]}"; do
  echo "Cloning $repo..."
  if [ -d "filecoin-project/$repo" ]; then
    echo "Repository $repo already exists, skipping..."
  else
    git clone "https://github.com/filecoin-project/$repo.git" "filecoin-project/$repo"
  fi
done

echo "All repositories cloned successfully!"
</file>

<file path="filoz.code-workspace">
{
	"folders": [
		{
			"path": "."
		},
		{
			"path": "payments"
		},
		{
			"path": "client-contract"
		},
		{
			"path": "deal-bounty-contract"
		},
		{
			"path": "pdp"
		},
		{
			"path": "pdp-explorer"
		},
		{
			"path": "dagparts"
		},
		{
			"path": "fil-forwarder-frontend"
		},
		{
			"path": "FilForwarder"
		}
	]
}
</file>

<file path="index.md">
# FilOz Documentation

Welcome to the comprehensive documentation for the FilOz ecosystem. This documentation covers all aspects of FilOz, including the Provable Data Possession (PDP) system and the Payments system.

## Table of Contents

### Getting Started
- [Introduction to FilOz](docs/introduction.md)
- [Quick Start Guide](docs/quick-start.md)
- [System Architecture](docs/architecture.md)

### Provable Data Possession (PDP)
- [PDP Overview](docs/pdp/concepts/overview.md)
- [How PDP Works](docs/pdp/concepts/how-it-works.md)
- [PDP Components](docs/pdp/concepts/components.md)
- [PDP Security Model](docs/pdp/concepts/security.md)

### PDP Guides
- [Creating a Proof Set](docs/pdp/guides/creating-proof-set.md)
- [Submitting Proofs](docs/pdp/guides/submitting-proofs.md)
- [Verifying Proofs](docs/pdp/guides/verifying-proofs.md)
- [Handling Faults](docs/pdp/guides/handling-faults.md)

### PDP API Reference
- [PDPVerifier Contract](docs/pdp/api/verifier-contract.md)
- [SimplePDPService Contract](docs/pdp/api/service-contract.md)
- [PDPListener Interface](docs/pdp/api/listener-interface.md)

### Payments System
- [Payments Overview](docs/payments/concepts/overview.md)
- [Payment Rails](docs/payments/concepts/payment-rails.md)
- [Arbitration](docs/payments/concepts/arbitration.md)
- [Settlement Process](docs/payments/concepts/settlement.md)

### Payments Guides
- [Setting Up a Payment Rail](docs/payments/guides/first-rail.md)
- [Implementing a Custom Arbiter](docs/payments/guides/custom-arbiter.md)
- [Managing Funds](docs/payments/guides/managing-funds.md)
- [Terminating Rails](docs/payments/guides/terminating-rails.md)

### Payments API Reference
- [Payments Contract](docs/payments/api/payments-contract.md)
- [IArbiter Interface](docs/payments/api/arbiter-interface.md)
- [Account Management](docs/payments/api/account-management.md)

### Integration
- [Integrating PDP with Payments](docs/integration/pdp-payments.md)
- [Building on FilOz](docs/integration/building-on-filoz.md)
- [FilOz in the Filecoin Ecosystem](docs/integration/filecoin-ecosystem.md)

### Examples
- [Hot Vault Demo](docs/examples/hot-vault.md)
- [Storage Provider Integration](docs/examples/storage-provider.md)
- [Client Application](docs/examples/client-application.md)

### Reference
- [Glossary](docs/reference/glossary.md)
- [FAQ](docs/reference/faq.md)
- [Troubleshooting](docs/reference/troubleshooting.md)

## Contributing
- [Contribution Guidelines](docs/contributing.md)
- [Code of Conduct](docs/code-of-conduct.md)
- [Development Setup](docs/development-setup.md)

## Resources
- [GitHub Repositories](docs/resources/repositories.md)
- [Community](docs/resources/community.md)
- [Related Projects](docs/resources/related-projects.md)
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2023 FilOz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="questions.md">
# Questions for Clarification

## Questions regarding Doc Review items from May 30, 2025, 10:00 AM PDT

### Question 1: PDPTool Repository Location
- [x] **Question**: You mentioned PDPTool is in the "curio organization" but I don't see a curio organization listed in the repo_list.md. Could you provide the exact GitHub URL for the PDPTool repository?
- [x] **Context**: Item #10 references PDPTool but I need the specific repository link to create proper documentation and links.

- [x] **Answer**: This is the documentation site referencing setting up PDPTool: https://docs.curiostorage.org/experimental-features/enable-pdp#pdp-client
- [x] **Answer**: This is the repo for Curio: git clone https://github.com/filecoin-project/curio.git

**‚úÖ COMPLETED**: Updated MVP.md with comprehensive PDPTool documentation including:
- Link to Curio PDP Setup Documentation
- Link to Official Filecoin PDP Documentation
- Link to Curio Repository


### Question 2: SDK Files Location Clarification  
- [ ] **Question**: You mentioned "In the `pdp` folder, there are a bunch of files labelled `sdk-*`" but I found the sdk-* files are actually in the root `docs/` folder, not in `docs/pdp/`. Should I move the files from `docs/` to `docs/sdk/` or did you mean something else?
- [ ] **Context**: Item #4 - I found these sdk files in docs/: sdk-monitoring.md, sdk-production.md, sdk-quickstart.md, sdk-workflow.md
- [ ] **Answer**: you are correct, they are in `docs/` and do need to be moved to `docs/sdk`.


### Question 3: Payment Rails Consolidation Strategy
- [x] **Question**: For the three payment-rails files in `payments/concepts/`, should I prioritize the content from one specific file (like payment-rails-updated.md) or merge all unique content from all three files?
- [x] **Context**: Item #6 - I need to understand your preference for handling potentially conflicting information between the files.
- [x] **Answer**: It seems like `payment-rails` both in `payments/concepts` and `payments` seem identical.  If not, pretty close, so they should be merged into a single document and put into `payments` folder.
- [x] **Answer**: `payment-rails-new` is a subset of `payment-rails-update`, and I think `payment-rails-update` contains details not found in `payment-rails` which is details on definitions.  I would merge this new content into the single `payment-rails` document. BUT have a clean table of contents to skip to the appropriate headers

**‚úÖ COMPLETED**: Successfully consolidated payment rails documentation:
- Added comprehensive Table of Contents to main payment-rails.md
- Merged unique content from concepts version including:
  - Epoch Duration section with time conversion examples
  - Payment Rate Calculation section with practical examples
  - Rail Updates and Their Impact section with best practices
- Removed redundant docs/payments/concepts/payment-rails.md file
- Maintained all existing comprehensive content from the main file

### Question 4: API vs Contracts Folder Naming
- [x] **Question**: Should I examine the content of `payments-contract.md` first to determine if it's truly about contracts vs API endpoints, or do you already know it should be renamed to `contracts`?
- [x] **Context**: Item #7 - Want to confirm the approach before making the folder structure change.
- [x] **Answer:** Sure, examine and see if it is contracts va API endpoints.

**‚úÖ COMPLETED**: Examined the content and confirmed it's about contract documentation, not API endpoints:
- Renamed `docs/payments/api/` folder to `docs/payments/contracts/`
- Content is clearly contract-focused (smart contract functions, events, etc.)
- No internal links needed updating

### Question 5: Contract Address Definitions Source
- [x] **Question**: For creating the contracts-details.md document (item #8), should I research the contract addresses by examining the source code repositories listed in repo_list.md, or do you have specific definitions you'd like me to use?
- [x] **Context**: Need to ensure accuracy when defining Payment proxy address and PDP Service address.
- [x] **Answer:** Yes, go through all the relevant repositories with contract addresses and give a summary of the contract address, functions and an overall role in the flow (perhaps a sequence diagram if possible).

**‚úÖ COMPLETED**: Created comprehensive contracts-details.md document:
- Researched all contract addresses from codebase repositories
- Provided human-readable definitions for all key addresses
- Explained who sets up each address and their purposes
- Distinguished between user-defined vs system-defined addresses
- Added integration examples and security considerations
- Linked from MVP.md for easy access
</file>

<file path="README.md">
# PDP-Payments (FWS) Documentation

This repository contains comprehensive documentation for the PDP-Payments (FWS) system, including guides, tutorials, and technical specifications.

## Table of Contents

- [Overview](#overview)
- [Getting Started](#getting-started)
- [Synapse SDK](#synapse-sdk)
- [Key Components](#key-components)
- [Documentation](#documentation)
- [Deployed Contracts](#deployed-contracts)

## Overview

PDP-Payments (FWS) is a comprehensive system for Provable Data Possession (PDP) with integrated payment mechanisms for Filecoin storage providers and clients. It is designed to enhance the Filecoin storage network by providing:

1. **Verifiable Storage**: Cryptographic proofs that storage providers are maintaining client data
2. **Automatic Payments**: Configurable payment channels with adjustments based on proof compliance
3. **SLA Enforcement**: Service Level Agreements enforced through arbitration mechanisms
4. **Continuous Payment Flow**: Payments that flow as long as storage services are properly provided

This documentation repository serves as a central resource for understanding how the various components of the PDP-Payments (FWS) system work together.

## Getting Started

### üöÄ Choose Your Path to Success

**What do you want to build?**

#### üì± **Developer Path: Build Apps Fast** (Recommended)
Use the [Synapse SDK](https://github.com/FilOzone/synapse-sdk) for rapid development with integrated PDP + Payments:

**‚ö° 5-Minute Hello World**
1. **[Setup Wallet & USDFC](docs/setup.md)** - Get testnet tokens (shared setup)
2. **[Quick SDK Setup](docs/sdk/sdk-quickstart.md)** - Install and initialize Synapse SDK
3. **[Complete Workflow](docs/sdk/sdk-workflow.md)** - Store file + handle payments in ~20 lines
4. **[Monitor & Verify](docs/sdk/sdk-monitoring.md)** - Track storage proofs and payments

**üí° Why SDK?** Abstract away complexity - automatic payment escrow, built-in settlement, simple balance management.

#### ü§ñ **AI Agent Path: Maximum Control** (Advanced)
Direct contract interactions for full technical control:

**üîß Technical Deep Dive**
1. **[Setup Wallet & USDFC](docs/setup.md)** - Get testnet tokens (shared setup)
2. **[Blockchain Configuration](docs/setup-detailed.md)** - JSON-RPC, Viem patterns, environment setup
3. **[Contract Integration](docs/contracts-guide.md)** - Direct PDP and Payment contract calls
4. **[Advanced Patterns](docs/examples/hot-vault.md)** - Production-ready examples
   - **[Traditional Hot Vault](docs/examples/hot-vault.md)** - Reference implementation with Docker
   - **[Modern Wagmi-Vercel Hot Vault](docs/examples/wagmi-vercel-hotvault.md)** - Serverless Web3 app with Wagmi v2

**üéØ Why Contracts?** Full control over every transaction, custom logic, advanced error handling.

### üìö Deep Dive Documentation

Once you've completed the Golden Path:

1. Understand the [PDP System](docs/pdp-overview.md) and [Payments System](docs/payments-overview.md)
2. Learn how to [Integrate PDP with Payments](docs/integration-guide.md)
3. Explore advanced [Integration Patterns](docs/integration/pdp-payments.md)

## Synapse SDK

The **Synapse SDK** is the primary interface for developers to interact with the PDP-Payments system. It provides a simple JavaScript/TypeScript API that abstracts away the complexity of direct contract interactions.

### Key Features

- **üéØ Simple API**: Store files in ~5 lines of code
- **üí∞ Integrated Payments**: Automatic USDFC handling and payment escrow
- **üîç PDP Verification**: Built-in storage proofs and verification
- **üì¶ TypeScript Support**: Full type safety and IntelliSense
- **‚ö° CDN Integration**: Optional CDN-accelerated file retrievals
- **üîÑ Real-time Monitoring**: Track storage status and payment settlements

### Quick Example

```javascript
import { Synapse } from 'synapse-sdk'

// Initialize SDK
const synapse = new Synapse({
  privateKey: process.env.PRIVATE_KEY,
  withCDN: true
})

// Store file with automatic payment handling
const storage = await synapse.createStorage()
const uploadTask = storage.upload(fileData)
const commp = await uploadTask.commp()
await uploadTask.done()
```

### Documentation & Resources

- **[SDK Quick Start Guide](docs/sdk/sdk-quickstart.md)** - Get started in 5 minutes
- **[Complete Workflow Tutorial](docs/sdk/sdk-workflow.md)** - End-to-end storage + payments
- **[Production Deployment Guide](docs/sdk/sdk-production.md)** - Scale to production
- **[SDK Repository](https://github.com/FilOzone/synapse-sdk)** - Source code and advanced documentation

## Key Components

### PDP (Provable Data Possession)

The PDP system allows storage providers to prove they are still storing client data without having to retrieve the entire dataset:

- **PDPVerifier Contract**: Handles verification of proofs submitted by storage providers
- **SimplePDPService**: Implements SLA terms for proof frequency and requirements
- **Proof Sets**: Data structures tracking the data being proven, owner, and proof history

### Payments System

The payments system provides flexible payment channels between clients and storage providers:

- **Payment Rails**: Channels connecting payers and payees with configurable payment rates
- **Arbitration**: Third-party arbiters that modify payment amounts based on service delivery
- **Settlement**: Process ensuring payments are made according to agreed terms

### Integration

The integration between PDP and Payments enables:

- **Verifiable Storage with Automatic Payment Adjustments**: Payments adjusted based on proof compliance
- **SLA Enforcement**: Service Level Agreements enforced through arbitration
- **Continuous Payment Flow**: Payments flow as long as service is properly provided

## Documentation

- [Quick Start](docs/quick-start.md): Quick start guide for developers
- [PDP Overview](docs/pdp-overview.md): Detailed explanation of the PDP system
- [SDK Documentation](docs/sdk/sdk-quickstart.md): Comprehensive Synapse SDK guides and tutorials
- [Payments Overview](docs/payments-overview.md): Detailed explanation of the Payments system
- [Payment Rails](docs/payments/payment-rails.md): Documentation on payment rails
- [Integration Guide](docs/integration/pdp-payments.md): Guide for integrating PDP with Payments
- [System Diagrams](docs/diagrams.md): Visual representations of system architecture and workflows
- [Hot Vault Examples](docs/examples/hot-vault.md): Complete storage application examples
  - [Traditional Hot Vault](docs/examples/hot-vault.md): Docker-based reference implementation
  - [Wagmi-Vercel Hot Vault](docs/examples/wagmi-vercel-hotvault.md): Modern serverless Web3 application

## Deployed Contracts

**üìã Complete Contract Reference**: [Contracts Reference Guide](docs/contracts-reference.md)

### Quick Reference

**Filecoin Calibration Testnet** (for development):
- **PDP Verifier**: `0x5A23b7df87f59A291C26A2A1d684AD03Ce9B68DC`
- **Payments Contract**: `0xc5e1333D3cD8a3F1f8A9f9A116f166cBD0bA307A`
- **USDFC Token**: `0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0`

**Filecoin Mainnet** (for production):
- **Payments Contract**: `0x8BA1f109551bD432803012645Ac136ddd64DBA72`

For complete contract information, ABIs, network configuration, and integration examples, see the [Contracts Reference Guide](docs/contracts-reference.md).
</file>

<file path="repo_list.md">
### Repository List
#### Working Repo
You are only working with a single repo.  By working, this means you can:
- push code; pull code
- create and merge branches
- create issues; close issues
- create pull requests

Here is that primary working repo: https://github.com/timfong888/pdp-payment


#### Source Code Repos - Read Only
The following repos are `read-only`.

They are where the source code is for the intended documentation.

The primary interface for developers will be directly with the SDK (`synapse-sdk`)

However, the other repos represent the related primitives that a developer who wants to work directly with contracts (and probably do so with the help of AI) would want to reference.

1. https://github.com/FilOzone/synapse-sdk (`synapse-sdk`)
2. https://github.com/FilOzone/pdp (`pdp`)
3. https://github.com/FilOzone/fws-payments (`fws-payments`)
4. https://github.com/FilOzone/hotvault-demo (`hotvault-demo`)
5. https://github.com/FilOzone/filecoin-services (`filecoin-services`)
6. https://github.com/FilOzone/pdp-explorer (`pdp-explorer`)

#### Existing Documentation
The following are documentation sites that, as needed, you should crawl to help you to build a single documentation site.  

But reference other sites as needed for developers and AI agents to go much more deeply.

1. USDFC Stablecoins Documentation: https://github.com/Secured-Finance/secured-finance-docs/tree/docs-optimize/usdfc-stablecoin/getting-started
2. Filcoin JSON-RPC: https://docs.filecoin.io/reference/json-rpc
3. MetaMask Docs (Snaps): https://docs.metamask.io/snaps/

#### MCP Server
Docs are available to the agent via the Context7 MCP Server: https://github.com/upstash/context7

The IDE or agent should add this MCP server based on those docs.

Remote Server:

```
{
  "mcpServers": {
    "context7": {
      "type": "http",
      "url": "https://mcp.context7.com/mcp"
    }
  }
}
```

Local Server:

```
{
  "servers": {
    "Context7": {
      "type": "stdio",
      "command": "npx",
      "args": ["-y", "@upstash/context7-mcp"]
    }
  }
}
```

The relevant docs via MCP for hehlping a developer build an end-to-end dApp:

- Wagmi (for interacting with smart contracts): https://github.com/wevm/wagmi
- Solidity (for writing custom EVM smart contracts): https://context7.com/ethereum/solidity
- Vercel (deployment of the app from localhost): https://github.com/vercel/sdk
- Next.js (React framework for UI to deploy via Vercel): https://github.com/vercel/next.js
</file>

<file path="system-diagrams.md">
# PDP-Payments (FWS) System Diagrams

This document provides visual representations of the PDP-Payments (FWS) system architecture and workflows to help understand how the system components interact.

## 1. System Architecture Overview

```mermaid
graph TD
    Client[Client] --> |Creates| Rail[Payment Rail]
    Client --> |Creates| ProofSet[Proof Set]
    ProofSet --> |References| Rail
    
    Rail --> |Pays| Provider[Storage Provider]
    Provider --> |Submits Proofs| PDPVerifier[PDP Verifier]
    
    PDPVerifier --> |Verifies Proofs| PDPService[PDP Service]
    PDPService --> |Reports Compliance| Arbiter[Arbiter]
    
    Arbiter --> |Adjusts Payments| PaymentsContract[Payments Contract]
    PaymentsContract --> |Manages| Rail
    
    subgraph "PDP System"
        PDPVerifier
        PDPService
        ProofSet
    end
    
    subgraph "Payments System"
        PaymentsContract
        Rail
        Arbiter
    end
```

**Summary:**
This diagram illustrates the high-level architecture of the PDP-Payments (FWS) system. The client creates both a payment rail and a proof set, linking them together. The storage provider submits proofs to the PDP Verifier, which works with the PDP Service to verify the proofs. The PDP Service reports compliance to the Arbiter, which adjusts payments through the Payments Contract based on the provider's performance. This creates a closed loop where payment flows are directly tied to proof of data possession.

## 2. PDP Verification Flow

```mermaid
sequenceDiagram
    participant Client
    participant Provider as Storage Provider
    participant PDPVerifier
    participant PDPService
    
    Client->>PDPVerifier: Create Proof Set (data root, provider)
    PDPVerifier->>Client: Return Proof Set ID
    
    loop For each proving period
        PDPService->>PDPVerifier: Generate Challenges
        PDPVerifier->>Provider: Issue Challenges
        Provider->>Provider: Generate Proofs
        Provider->>PDPVerifier: Submit Proofs
        PDPVerifier->>PDPVerifier: Verify Proofs
        PDPVerifier->>PDPService: Report Verification Results
        PDPService->>PDPService: Update Compliance Status
    end
```

**Summary:**
This sequence diagram shows the PDP verification flow. The client first creates a proof set in the PDP Verifier, specifying the data root and the storage provider. For each proving period, the PDP Service generates challenges that are issued to the provider. The provider generates proofs based on these challenges and submits them to the PDP Verifier. The verifier checks the proofs and reports the results to the PDP Service, which updates the compliance status. This cycle repeats throughout the duration of the storage agreement, ensuring continuous verification of data possession.

## 3. Payment Rails Workflow

```mermaid
graph LR
    Client[Client] -->|1. Creates Rail| Rail[Payment Rail]
    Client -->|2. Deposits Funds| Account[Client Account]
    Account -->|3. Funds Locked| Rail
    
    Rail -->|4. Continuous Payments| Provider[Provider Account]
    
    Arbiter[Arbiter] -->|5. Adjusts Payments| Rail
    
    subgraph "Payment Rail Details"
        RailParams[Rail Parameters]
        RailParams -->|Payment Rate| Rail
        RailParams -->|Lockup Period| Rail
        RailParams -->|Fixed Lockup| Rail
    end
```

**Summary:**
This diagram illustrates how payment rails work in the system. The client creates a payment rail, specifying parameters such as payment rate, lockup period, and fixed lockup amount. The client deposits funds into their account, which are then locked in the rail based on the specified parameters. The rail facilitates continuous payments to the provider at the configured rate. An arbiter can adjust these payments based on service delivery (such as proof compliance). This creates a flexible payment channel that automatically handles ongoing payments while enforcing service level agreements.

## 4. PDP-Payments Integration Flow

```mermaid
sequenceDiagram
    participant Client
    participant Provider as Storage Provider
    participant PDPSystem as PDP System
    participant Arbiter
    participant PaymentsSystem as Payments System
    
    Client->>PaymentsSystem: Create Payment Rail
    Client->>PDPSystem: Create Proof Set (references Rail ID)
    
    loop For each settlement period
        Provider->>PDPSystem: Submit Proofs
        PDPSystem->>PDPSystem: Verify Proofs
        PDPSystem->>Arbiter: Report Verification Results
        
        PaymentsSystem->>Arbiter: Request Arbitration
        Arbiter->>Arbiter: Calculate Payment Adjustment
        Arbiter->>PaymentsSystem: Return Adjusted Payment Amount
        
        PaymentsSystem->>Provider: Transfer Adjusted Payment
    end
```

**Summary:**
This sequence diagram shows how PDP and Payments systems integrate. The client creates a payment rail in the Payments System and a proof set in the PDP System, linking them together. During each settlement period, the provider submits proofs to the PDP System, which verifies them and reports the results to the Arbiter. When the Payments System requests arbitration, the Arbiter calculates payment adjustments based on the verification results and returns the adjusted payment amount to the Payments System. The Payments System then transfers the adjusted payment to the provider. This integration ensures that payments are directly tied to the provider's compliance with the data possession requirements.

## 5. Rail Modification and Termination

```mermaid
stateDiagram-v2
    [*] --> Active: Create Rail
    
    Active --> Modified: Modify Rail Parameters
    Modified --> Modified: Adjust Rate/Lockup
    Modified --> Active: Continue Operation
    
    Active --> Terminating: Initiate Termination
    Modified --> Terminating: Initiate Termination
    
    Terminating --> LockupPeriod: Enter Lockup Period
    LockupPeriod --> Terminated: After Lockup Period
    
    Terminated --> [*]: Final Settlement
```

**Summary:**
This state diagram illustrates the lifecycle of a payment rail. A rail starts in the Active state when created. It can be modified by adjusting parameters like payment rate or lockup requirements, transitioning to the Modified state and back to Active during normal operation. When termination is initiated, the rail enters the Terminating state, followed by the Lockup Period where payments continue based on the lockup parameters. After the lockup period ends, the rail transitions to the Terminated state, and a final settlement is performed. This flexible lifecycle allows for adjustments to payment terms and orderly termination of payment channels.

## 6. Data Flow in PDP-Payments System

```mermaid
flowchart TD
    Client[Client] -->|Data & Payment Info| System[PDP-Payments System]
    
    subgraph System
        direction TB
        
        Data[Client Data] -->|Merkle Root| ProofSet[Proof Set]
        PaymentInfo[Payment Info] -->|Rail Parameters| Rail[Payment Rail]
        
        ProofSet -->|Referenced in| Challenges[Challenges]
        Challenges -->|Issued to| Provider[Provider]
        Provider -->|Proofs| Verification[Verification]
        
        Verification -->|Compliance Status| Arbitration[Arbitration]
        Rail -->|Payment Terms| Arbitration
        Arbitration -->|Adjusted Payments| Settlement[Settlement]
        Settlement -->|Funds Transfer| Provider
    end
```

**Summary:**
This flowchart shows the data flow within the PDP-Payments system. The client provides both data (which is represented by a Merkle root in the proof set) and payment information (which defines the rail parameters). The system issues challenges based on the proof set to the provider, who responds with proofs. These proofs undergo verification, resulting in a compliance status that feeds into the arbitration process. The arbitration process considers both the compliance status and the payment terms from the rail to determine adjusted payments. The settlement process then transfers the appropriate funds to the provider. This integrated data flow ensures that payments are directly tied to verifiable data possession.
</file>

<file path="update_repos.sh">
#!/bin/bash

# Array of repositories to update
repos=("client-contract" "payments" "fil-forwarder-frontend" "dagparts" "pdp-explorer" "deal-bounty-contract" "pdp" "FilForwarder")

# Function to update a repository
update_repo() {
  local repo=$1
  echo "Updating repository: $repo"
  echo "------------------------"
  
  if [ -d "$repo" ]; then
    cd "$repo"
    
    # Check if there are any uncommitted changes
    if [ -n "$(git status --porcelain)" ]; then
      echo "‚ö†Ô∏è  Repository has uncommitted changes. Skipping pull."
    else
      # Try to pull
      git pull
    fi
    
    cd ..
    echo ""
  else
    echo "‚ùå Directory not found: $repo"
    echo ""
  fi
}

# Main script
echo "Starting repository updates..."
echo "=============================="
echo ""

# Update each repository
for repo in "${repos[@]}"; do
  update_repo "$repo"
done

echo "=============================="
echo "Repository updates completed!"
</file>

</files>
